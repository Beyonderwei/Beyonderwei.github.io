<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="A personal website.">
    <meta name="keyword"  content="beyonderwei, 瞌睡遇上枕头">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          Java设计模式 - beyonderwei
        
    </title>

    <link rel="canonical" href="http://beyonderwei.com/2019/06/18/Java设计模式/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="/css/dusign-dark.css">

        
<link rel="stylesheet" href="/css/dusign-common-dark.css">

        
<link rel="stylesheet" href="/css/font-awesome.css">

        
<link rel="stylesheet" href="/css/toc.css">

    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="/css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.5)), url('')
                /*post*/
            
        
    }
    
    #signature{
        background-image: url('/img/signature/beyonderwei.png');
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#设计模式" title="设计模式">设计模式</a>
                            
                              <a class="tag" href="/tags/#Java" title="Java">Java</a>
                            
                        </div>
                        <h1>Java设计模式</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Beyonderwei on
                            2019-06-18
                        </span>

                        
                            <div class="blank_box"></div>
                            <span class="meta">
                                Words <span class="post-count">12k</span> and
                                Reading Time <span class="post-count">41</span> Minutes
                            </span>
                            <div class="blank_box"></div>
                            <!-- 不蒜子统计 start -->
                            <span class="meta">
                                Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
                            </span>
                            <!-- 不蒜子统计 end -->
                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-dark.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-dark.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Beyonderwei</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">首页</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">关于作者</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">分类</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">归档</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/photography/">相册</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">标签</a>
                        </li>
                        
                    

                    <li>
                        <a href="https://github.com/Beyonderwei" target="_blank">Github</a>
                    </li>
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <p><strong>使用场景：面向对象-&gt;功能模块（设计模式+算法）-&gt;框架（多种设计模式）-&gt;架构</strong></p>
<h2 id="基础常识"><a href="#基础常识" class="headerlink" title="基础常识"></a>基础常识</h2><h3 id="1-设计模式的六-七-大原则"><a href="#1-设计模式的六-七-大原则" class="headerlink" title="1. 设计模式的六(七)大原则"></a>1. 设计模式的六(七)大原则</h3><ul>
<li>单一职责原则</li>
<li>接口隔离</li>
<li>依赖倒转</li>
<li>里氏替换</li>
<li>开闭原则（ocp）</li>
<li>迪米特法则</li>
<li>合成复用</li>
</ul>
<h3 id="2-设计模式解决的问题"><a href="#2-设计模式解决的问题" class="headerlink" title="2. 设计模式解决的问题"></a>2. 设计模式解决的问题</h3><p>最终实现：<strong>高内聚、低耦合</strong></p>
<ul>
<li>代码复用（相同功能不用重复编写）</li>
<li>可读性（增加程序的规范性，方便阅读）</li>
<li>可扩展（方便增加新的功能）</li>
<li>可靠性（增加新的功能后对原来的功能没有影响）</li>
</ul>
<h2 id="一、设计模式的七大原则"><a href="#一、设计模式的七大原则" class="headerlink" title="一、设计模式的七大原则"></a>一、设计模式的七大原则</h2><p><strong>设计模式的原则是设计模式为什么如此设计的依据。</strong></p>
<h3 id="1-单一职责"><a href="#1-单一职责" class="headerlink" title="1. 单一职责"></a>1. 单一职责</h3><p><strong>简介：</strong></p>
<p>​        一个类只能负责一项职责，如果类A负责两个职责，那么更改其中一个职责时就可能造成职责2执行错误。所以应该将A类分成A1、A2两个类。</p>
<p><strong>注意事项：</strong></p>
<ol>
<li>当类中方法足够少的时候，也可以在方法级别保持单一原则，只有当一个类的方法足够少时，才在方法级别保持单一原则</li>
<li>降低类的复杂度，一个类只负责一项原则</li>
<li>提高类的可读性、可维护性</li>
<li>降低变更引起的风险</li>
</ol>
<h3 id="2-接口隔离原则-ISP"><a href="#2-接口隔离原则-ISP" class="headerlink" title="2. 接口隔离原则(ISP)"></a>2. 接口隔离原则(ISP)</h3><p><strong>全称：</strong></p>
<pre><code>     Interface Segregation Principle
</code></pre><p><strong>简介：</strong></p>
<p>​        通常一个类对于另外一个类的依赖是通过接口依赖的，因此客户端不应该依赖他不需要的接口，即一个类对另一个类的依赖应该建立在<strong>最小的接口</strong>上。</p>
<p><strong>举例：</strong></p>
<p>​        如果类A通过<strong>接口1</strong>依赖类B，类C通过<strong>接口1</strong>依赖类D，如果接口1对于类A和类C来说不是最小接口，那么就造成类B和类D不得不实现他们不需要的方法。</p>
<p><strong>处理方式：</strong></p>
<p>​        将接口1进行拆分，使得类A和类C分别与他们需要的接口建立依赖关系——即接口隔离原则</p>
<h3 id="3-依赖倒置原则"><a href="#3-依赖倒置原则" class="headerlink" title="3. 依赖倒置原则"></a>3. 依赖倒置原则</h3><p>依赖倒置的核心思想是：<strong>面向接口编程。</strong> </p>
<p><strong>相关概念</strong></p>
<ul>
<li>抽象：一般指接口或者抽象类</li>
<li>细节：指具体实现</li>
</ul>
<p><strong>简介：</strong></p>
<ul>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象类</li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>抽象的东西相比于细节要稳定的多，要以抽象为基础搭建架构</li>
<li>使用接口和抽象类去制定好规范，而不涉及任何具体的操作，细节由实现类去完成。</li>
</ul>
<p><strong>依赖关系传递的三种方式（参考12）</strong></p>
<ul>
<li>接口传递</li>
<li>构造方法传递</li>
<li>setter方式传递</li>
</ul>
<p>注：@TODO 需要重新学一下</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>底层模块尽量都要有抽象类或者接口，或两者都有，程序的稳定性好</li>
<li>变量的声明类型尽量是抽象类或者接口，这样变量的引用和实际对象间存在一个缓冲层，利于扩展和优化。</li>
<li>继承时遵循里氏替换原则。</li>
</ul>
<h3 id="4-里氏替换原则"><a href="#4-里氏替换原则" class="headerlink" title="4. 里氏替换原则"></a>4. 里氏替换原则</h3><p><strong>解决的问题：</strong></p>
<p>​    继承带来便利的同时也带来了弊端，增加了对象间的耦合，当一个父类拥有多个子类时，当需要修改父类时，必须要考虑到所有子类，所涉及的子类的功能都可能产生故障。</p>
<p><strong>简介：</strong></p>
<ul>
<li>所引用基类的地方必须能够透明的使用其子类的对象，<strong>即子类尽量不要重写父类的方法，</strong>可以通过让子类和父类同时继承一个更基础的类。</li>
<li>继承实际上是让耦合增强了，在适当情况下可以通过 <strong>聚合、组合、依赖</strong> 来解决问题。</li>
</ul>
<p><strong>聚合、组合、依赖：</strong></p>
<p>前：B继承A，A继承BASE</p>
<p>后：A、B均继承BASE，但B还要使用A中的方法，采用下述方式 </p>
<ul>
<li>聚合：</li>
<li>组合：在B类中声明一个A的实例（组合了一个A的对象），B的方法中通过该实例来使用A的方法。</li>
<li>依赖：</li>
</ul>
<h3 id="5-开闭原则"><a href="#5-开闭原则" class="headerlink" title="5. 开闭原则"></a>5. 开闭原则</h3><p><strong>简介：</strong></p>
<ul>
<li>开闭原则是编程中最基础、最重要的设计原则</li>
<li>一个软件的实体，应该<strong>对扩展开放（对提供方），对修改关闭（对使用方）</strong>，用抽象构建框架（通过接口、或抽象方法实现），用实现扩展细节。</li>
<li>当软件需要变化时，通过扩展软件实体的方式来实现变化，儿不是通过修改已有代码来实现。</li>
<li>编程中的其他原则和设计模式的目的就是为了遵循开闭原则。</li>
</ul>
<h3 id="6-迪米特法则-最少知道原则"><a href="#6-迪米特法则-最少知道原则" class="headerlink" title="6. 迪米特法则(最少知道原则)"></a>6. 迪米特法则(最少知道原则)</h3><p><strong>简介：</strong></p>
<ul>
<li>一个对象应对其他对象保持最少的了解</li>
<li>类与类的关系越密切，耦合度越大</li>
<li>对于被依赖的类，<strong>不管多么复杂，尽量将逻辑封装在类的内部，对外除了提供public方法以外，不泄露任何信息。</strong></li>
</ul>
<p><strong>理解迪米特法则：</strong></p>
<p>对象之间<strong>只与直接朋友进行通信</strong>。</p>
<ul>
<li>直接朋友1——成员对象：A类中有B类的成员对象。</li>
<li>直接朋友2——方法参数：A类的方法的参数中，接收了B类的对象。</li>
<li>直接朋友3——方法返回值：A类的方法返回一个B类的对象。</li>
<li>非直接朋友——局部变量中的类：A的方法内部用到B，直接new了一个B的对象来使用。</li>
</ul>
<p><strong>注意事项:</strong></p>
<ul>
<li>迪米特法则的核心是降低类之间的依赖</li>
<li>迪米特法则只是要求降低类与类之间的依赖，并不是要求完全没有依赖关系。</li>
</ul>
<h3 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7. 合成复用原则"></a>7. 合成复用原则</h3><p><strong>基本介绍：</strong></p>
<p><strong>尽量使用合成、聚合方式，而不是使用继承</strong>。（依赖、合成、聚合、组合的具体意思在UML类图中介绍。）</p>
<h3 id="设计原则的核心思想"><a href="#设计原则的核心思想" class="headerlink" title="设计原则的核心思想"></a>设计原则的核心思想</h3><ul>
<li>找出应用中可能变化的部分，独立出来，不要和那些不需要变化的代码混在一起</li>
<li>针对接口编程而不是针对实现编程</li>
<li>为了交互对象之间的松耦合设计而努力</li>
</ul>
<h2 id="二、UML类图"><a href="#二、UML类图" class="headerlink" title="二、UML类图"></a>二、UML类图</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><ul>
<li><p>UML——Unified modeling language（统一建模语言），用于软件系统分析和设计的语言工具。</p>
</li>
<li><p>UML由一套符号规定，用来描述模型中各个元素之间的关系，如类、接口、实现、泛化、依赖、组合、聚合等</p>
</li>
<li><strong>一般编译器可以安装插件来画类图，并且把写好的类直接拖拽就可以自动生成类图。</strong></li>
</ul>
<h3 id="关系："><a href="#关系：" class="headerlink" title="关系："></a>关系：</h3><p>具体就记住泛化、实现、聚合、组合就可以。</p>
<h4 id="1-Dependency：依赖（使用）"><a href="#1-Dependency：依赖（使用）" class="headerlink" title="1. Dependency：依赖（使用）"></a>1. Dependency：依赖（使用）</h4><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>​        在A类中用到了B类，依赖关系就成立，A依赖于B。</p>
<ul>
<li>类中用到了对方</li>
<li>作为类的成员属性</li>
<li>作为A类中方法的返回类型</li>
<li>作为A类方法中接收的参数类型</li>
<li>方法中使用到</li>
</ul>
<h4 id="2-Generalization：泛化（继承）"><a href="#2-Generalization：泛化（继承）" class="headerlink" title="2. Generalization：泛化（继承）"></a>2. Generalization：泛化（继承）</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h5><p>​        <strong>泛化关系就是继承关系</strong>，是依赖关系的一种特例。</p>
<h4 id="3-Association：关联"><a href="#3-Association：关联" class="headerlink" title="3. Association：关联"></a>3. Association：关联</h4><h5 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h5><p>​        关联关系是类与类之间的一种联系，他是依赖关系的一种特例。具有导航性和多重性。</p>
<ul>
<li>单项的一对一的关系：A类的成员变量中有B类，但B类中没有A类的成员变量</li>
<li><p>双向的一对一的关系：A类的成员变量中有B类，B类中也有A类的成员变量</p>
</li>
<li><p>导航性：谁聚合谁，如A聚合B</p>
</li>
<li>多重性：即A中有多少个B的对象实例，由此分为单聚合和多重聚合。</li>
</ul>
<h4 id="4-Realization：实现"><a href="#4-Realization：实现" class="headerlink" title="4. Realization：实现"></a>4. Realization：实现</h4><h5 id="简介：-2"><a href="#简介：-2" class="headerlink" title="简介："></a>简介：</h5><p>​        实现关系就是A类实现了B类（通常B是接口），实现也是依赖关系的一种特例。具有导航的关联性和多重性。</p>
<h4 id="5-Aggregation：聚合"><a href="#5-Aggregation：聚合" class="headerlink" title="5. Aggregation：聚合"></a>5. Aggregation：聚合</h4><h5 id="简介：-3"><a href="#简介：-3" class="headerlink" title="简介："></a>简介：</h5><p>​        表示整体和部分的关系，整体与部分<strong>可以分开</strong>，聚合关系是关联关系的一种特例。</p>
<h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><p>​        如A类成员变量中有B类的实例，当B类可以从A类中分开时，称为<strong>聚合</strong>。即在创建A类的对象时并没有同时创建B类的对象（<strong>没有new</strong>），比如人和身份证的关系，人可以没有身份证，不需要new。</p>
<h4 id="6-Composite：组合"><a href="#6-Composite：组合" class="headerlink" title="6. Composite：组合"></a>6. Composite：组合</h4><h5 id="简介：-4"><a href="#简介：-4" class="headerlink" title="简介："></a>简介：</h5><p>​        表示整体和部分的关系，整体与部分<strong>不可以分开</strong>，组合关系是关联关系的一种特例。</p>
<h5 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h5><p>​        如A类成员变量中有B类的实例，当B类不可以从A类中分开时，称为<strong>聚合</strong>。即在创建A类的对象时同时创建B类的对象（<strong>有new</strong>），比如人和脑袋的关系，人不可以没有脑袋，需要new。##### </p>
<h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><p>​        对于<strong>级联删除</strong>，当我们删除一个对象时，连同另一个对象一起删除了，说此时两者之间发的关系就是组合。</p>
<ul>
<li>举例：当班级中所有的人都被删除后，班级就没有意义，需要顺带删除，此时Person与Class的关系就是组合。</li>
</ul>
<h2 id="三、设计模式分类‘"><a href="#三、设计模式分类‘" class="headerlink" title="三、设计模式分类‘"></a>三、设计模式分类‘</h2><h3 id="1-创建型模型"><a href="#1-创建型模型" class="headerlink" title="1. 创建型模型"></a>1. 创建型模型</h3><h4 id="简介：-5"><a href="#简介：-5" class="headerlink" title="简介："></a>简介：</h4><p>​        针对对象的创建</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>​        单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</p>
<h3 id="2-结构型模型"><a href="#2-结构型模型" class="headerlink" title="2. 结构型模型"></a>2. 结构型模型</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​        针对如何让软件有伸缩性、有弹性</p>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p>​        适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式</p>
<h3 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3. 行为型模式"></a>3. 行为型模式</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​        让我们的方法的设计更合理</p>
<h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><p>​        模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter）、状态模式、策略模式、职责链模式（职责链模式）。</p>
<h2 id="四、23种设计模式"><a href="#四、23种设计模式" class="headerlink" title="四、23种设计模式"></a>四、23种设计模式</h2><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><h4 id="简介：-6"><a href="#简介：-6" class="headerlink" title="简介："></a>简介：</h4><p>​        采取一种方法保证整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。</p>
<h4 id="JDK源码使用"><a href="#JDK源码使用" class="headerlink" title="JDK源码使用"></a>JDK源码使用</h4><p>​        java中的 Runtime类，使用的是饿汉式。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>单例保证了系统内存中只存在一个对象，对于一些需要频繁创建销毁的对象，使用单例模式可提高系统性能</li>
<li>创建对象时耗时过多或者耗费的资源过多（即重量级对象），但又经常用到的对象</li>
<li>工具类对象</li>
<li>频繁访问数据库或者文件的对象（如数据源、session工厂等）</li>
</ul>
<h4 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h4><h5 id="①-饿汉式1（静态常量）"><a href="#①-饿汉式1（静态常量）" class="headerlink" title="① 饿汉式1（静态常量）"></a>① 饿汉式1（静态常量）</h5><p><strong>步骤：</strong></p>
<ul>
<li>构造器私有化（防止外部new）</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法</li>
</ul>
<p><strong>代码实现：</strong></p>
<p>​        参考笔记</p>
<p><strong>优缺点：</strong></p>
<ul>
<li>在类装载的时候就完成了实例化，避免了线程同步问题</li>
<li>在类装载的时候就完成了实例化，没有达到懒加载的效果，如果自始至终未使用这个类会造成内存浪费</li>
<li>导致类装载的方式有很多种，不能确定有其他方式（或其他静态方法）导致类加载，这时候初始化类就没有达到懒加载效果。</li>
</ul>
<p><strong>总结：</strong></p>
<p>​        这种方式<strong>可用</strong>，可能会造成一个内存的浪费。</p>
<h5 id="②-饿汉式2（静态代码块）"><a href="#②-饿汉式2（静态代码块）" class="headerlink" title="② 饿汉式2（静态代码块）"></a>② 饿汉式2（静态代码块）</h5><p><strong>步骤：</strong></p>
<ul>
<li>构造器私有化（防止外部new）</li>
<li>类的内部创建对象（<strong>对象的创建在静态代码块中</strong>）</li>
<li>向外暴露一个静态的公共方法</li>
</ul>
<p><strong>代码实现：</strong></p>
<p>​        参考</p>
<p><strong>优缺点和总结：</strong></p>
<p>​        与饿汉式1的相同，仅仅是实现的方式不一样。</p>
<h5 id="③-懒汉式1（线程不安全）"><a href="#③-懒汉式1（线程不安全）" class="headerlink" title="③ 懒汉式1（线程不安全）"></a>③ 懒汉式1（线程不安全）</h5><p><strong>步骤：</strong></p>
<ul>
<li>声明静态对象</li>
<li>构造器私有化（防止外部new）</li>
<li>向外暴露一个静态的公共方法，在方法中创建类的实例（实例非空时才创建）</li>
</ul>
<p><strong>代码实现：</strong></p>
<p>​        参考</p>
<p><strong>优缺点和总结：</strong></p>
<ul>
<li>起到了懒加载的效果（即用到时才创建）</li>
<li>如果在多个线程下，比如两个线程同时进入了对创建实例的判断，会导致产生多个实例，就不符合单例模式</li>
</ul>
<p><strong>结论：</strong></p>
<p>​        实际开发中<strong>不使用</strong></p>
<h5 id="④-懒汉式2（线程安全）"><a href="#④-懒汉式2（线程安全）" class="headerlink" title="④ 懒汉式2（线程安全）"></a>④ 懒汉式2（线程安全）</h5><p><strong>步骤：</strong></p>
<ul>
<li>声明静态对象</li>
<li>构造器私有化（防止外部new）</li>
<li>向外暴露一个静态的公共方法，在方法中创建类的实例（实例非空时才创建），对该方法<strong>加入同步处理的代码（synchronized）</strong></li>
</ul>
<p><strong>代码实现：</strong></p>
<p>​        参考</p>
<p><strong>优缺点和总结：</strong></p>
<ul>
<li>通过synchronized 解决了线程不安全问题</li>
<li>效率太低了，每个线程在调用该公共的方法时都要进行同步，而实际上这个方法只要执行一次实例化的代码就够了，后面想获得直接return就OK。</li>
</ul>
<p><strong>总结：</strong></p>
<p>​        在实际开发中<strong>不推荐使用</strong></p>
<h5 id="⑤-懒汉式3（线程不安全、同步代码块）"><a href="#⑤-懒汉式3（线程不安全、同步代码块）" class="headerlink" title="⑤ 懒汉式3（线程不安全、同步代码块）"></a>⑤ 懒汉式3（线程不安全、同步代码块）</h5><p><strong>简介：</strong></p>
<p>​        相对于第二种写法，这种写法将线程同步放到了方法内部的代码块进行判断，但导致了线程不安全，<strong>实际开发中不使用</strong>。</p>
<p><strong>代码实现：</strong></p>
<p>​        参考33</p>
<h5 id="⑥-双重检查（推荐使用）"><a href="#⑥-双重检查（推荐使用）" class="headerlink" title="⑥ 双重检查（推荐使用）"></a>⑥ 双重检查（推荐使用）</h5><p><strong>步骤：</strong></p>
<ul>
<li>声明静态对象（通过<strong>volatile</strong>进行修饰，使得当其改变后会立即更新到储存）</li>
<li>构造器私有化（防止外部new）</li>
<li>向外暴露一个静态的公共方法，在方法中使用双重检查判断。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">//volatile让修改值立即更新到储存</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line">	<span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点和总结：</strong></p>
<ul>
<li>通过两次if(对象 == null)检查和同步代码，<strong>保证了线程安全</strong></li>
<li>实例化只执行一次，后面访问时直接返回实例化的对象，避免反复同步，<strong>效率高</strong>。</li>
<li>需要时才去创建，<strong>实现了懒加载</strong></li>
</ul>
<p><strong>结论：</strong></p>
<p>​        实际开发中<strong>推荐使用</strong></p>
<h5 id="⑦-静态内部类（推荐使用）"><a href="#⑦-静态内部类（推荐使用）" class="headerlink" title="⑦ 静态内部类（推荐使用）"></a>⑦ 静态内部类（推荐使用）</h5><p><strong>静态内部类：</strong></p>
<ul>
<li>在外部类装载时并不会导致内部类的装载，从而<strong>保证了懒加载</strong></li>
<li>当调用外部类方法时（因为返回的是 内部类的属性）会导致内部类的加载，而JVM在装载类的过程中是<strong>线程安全的</strong>。</li>
</ul>
<p><strong>步骤：</strong></p>
<ul>
<li>声明静态对象（通过<strong>volatile</strong>进行修饰，使得当其改变后会立即更新到储存）</li>
<li>构造器私有化（防止外部new）</li>
<li>写一个静态内部类，该类中有一个<strong>外部类的静态属性</strong> </li>
<li>向外暴露一个静态的公有方法，在方法中直接返回静态内部类的属性。</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器私有化</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点和总结：</strong></p>
<ul>
<li>利用静态内部类的特点，避免了线程不安全，实现了懒加载，效率高</li>
</ul>
<p><strong>结论：</strong></p>
<p>​        <strong>推荐使用</strong></p>
<h5 id="⑧-枚举方式（推荐使用）"><a href="#⑧-枚举方式（推荐使用）" class="headerlink" title="⑧ 枚举方式（推荐使用）"></a>⑧ 枚举方式（推荐使用）</h5><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE; <span class="comment">//属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ok~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点：</strong></p>
<ul>
<li>可以避免多线程的问题</li>
<li>可防止反序列化重新创建新的对象</li>
<li>java作者所提倡的方式</li>
</ul>
<p><strong>结论：</strong></p>
<ul>
<li>推荐使用</li>
</ul>
<h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h3><h4 id="①-简单工厂模式"><a href="#①-简单工厂模式" class="headerlink" title="① 简单工厂模式"></a>① 简单工厂模式</h4><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p>​        定义了一个创建对象的类（工厂类），<strong>这个类用来封装实例化对象的行为</strong>。当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。</p>
<h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><p>​    @TODO</p>
<h5 id="JDK源码使用-1"><a href="#JDK源码使用-1" class="headerlink" title="JDK源码使用"></a>JDK源码使用</h5><p>​    在Calendar类中，使用了简单工厂模式</p>
<h4 id="②-工厂方法模式"><a href="#②-工厂方法模式" class="headerlink" title="② 工厂方法模式"></a>② 工厂方法模式</h4><h5 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h5><p>​        定义一个创建对象的抽象工厂类，该工厂类中通过抽象方法来创建对象，由工厂子类决定要实例化的对象。工厂方法模式将对象实例化推迟到了子类。</p>
<h5 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h5><p>​    @TODO</p>
<h4 id="③-抽象工厂模式"><a href="#③-抽象工厂模式" class="headerlink" title="③ 抽象工厂模式"></a>③ 抽象工厂模式</h4><h5 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h5><ul>
<li>定义一个interface用于创建相关或者有依赖的对象簇，无需指明具体的类</li>
<li>抽象工厂模式是对简单工厂和工厂方法模式的整合</li>
<li>将工厂抽象成两层，抽象工厂和具体实现的工厂子类，这样就可根据创建的对象类型来使用对应的工厂子类。更便于维护。</li>
</ul>
<h5 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h5><p>​    @TODO</p>
<h4 id="工厂模式总结"><a href="#工厂模式总结" class="headerlink" title="工厂模式总结"></a>工厂模式总结</h4><ul>
<li>将实例化的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖和解耦，提高扩展性和可维护性</li>
<li>创建对象不要直接new类，把这个new的动作放到一个工厂的方法中，并返回。——即变量不要直接持有具体类的引用。</li>
<li>不要让类集成具体类，而是继承抽象类或实现接口。</li>
<li>不要覆盖基类中已经实现的方法。</li>
<li>遵循设计模式的<strong>依赖抽象原则</strong>。</li>
</ul>
<h3 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3. 原型模式"></a>3. 原型模式</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><ul>
<li>原型模式是指用原型实例指定创建对象的种类，并且<strong>通过拷贝这些原型来创建新的对象</strong>。</li>
<li>原型模式是创建型设计模式，将一个原型对象传给哪个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝他们自己来实施创建</li>
</ul>
<p>注：    java中的Object类是所有类的跟类，Object提供了一个clone()方法，该方法可以将java对象赋值一份，但是需要实现clone的java类必须要实现一个接口Cloneable，该接口表示该类该类具有复制的能力。</p>
<h4 id="Spring源码使用"><a href="#Spring源码使用" class="headerlink" title="Spring源码使用"></a>Spring源码使用</h4><p>​    在bean的创建中使用了原型模式。</p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><h5 id="简介：-7"><a href="#简介：-7" class="headerlink" title="简介："></a>简介：</h5><ul>
<li>浅拷贝是使用，默认的clone()方法来实现的</li>
<li>对数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性复制一份给新的对象</li>
<li>对数据类型是引用数据类型的成员变量（如数组、某个类的对象），浅拷贝会进行引用传递，实际上两个对象的该成员变量都指向同一个实例，这是在一个对象中修改成员变量会影响到另一个对象的该成员变量的值。</li>
</ul>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><h5 id="简介：-8"><a href="#简介：-8" class="headerlink" title="简介："></a>简介：</h5><ul>
<li>复制对象的所有基本数据类型的成员变量</li>
<li>为所有引用数据类型的成员变量申请内存空间，并复制每个引用数据类型成员变量所引用的对象。即深拷贝是对整个对象进行拷贝</li>
</ul>
<h5 id="实现方式：-1"><a href="#实现方式：-1" class="headerlink" title="实现方式："></a>实现方式：</h5><ul>
<li><p>重写clone方法来实现深拷贝，</p>
<ul>
<li>在重写的方法中将基本数据类型的属性clone拷贝，其他引用数类型单独通过该数据类型的clone拷贝进来。</li>
</ul>
</li>
<li><p>通过对象序列化实现深拷贝（<strong>推荐使用</strong>）</p>
<ul>
<li>先通过将对象序列化，然后再反序列化，得到对象的拷贝。</li>
<li>这样的方式避免了第一个方式中一个一个处理需要拷贝的对象的问题。</li>
<li>代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String name; <span class="comment">//String 属性</span></span><br><span class="line">	<span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//深拷贝 - 方式2 通过对象的序列化实现 (推荐)</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建流对象</span></span><br><span class="line">		ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">		ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//序列化</span></span><br><span class="line">			bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">			oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">			oos.writeObject(<span class="keyword">this</span>); <span class="comment">//当前这个对象以对象流的方式输出</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//反序列化</span></span><br><span class="line">			bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">			ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">			DeepProtoType copyObj = (DeepProtoType)ois.readObject();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> copyObj;</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//关闭流</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				bos.close();</span><br><span class="line">				oos.close();</span><br><span class="line">				bis.close();</span><br><span class="line">				ois.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">				System.out.println(e2.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</li>
<li>不用重新初始化对象，克隆时而可以动态的获取最新的对象的运行时状态</li>
<li>原始对象发生改变时，在克隆对象时也会发生变化，无需修改代码</li>
<li>在实现深克隆的时候可能需要比较复杂的代码</li>
<li>需要为每一个类配备一个克隆方法，对已有的类改造时会违反ocp原则。</li>
</ul>
<h3 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4. 建造者模式"></a>4. 建造者模式</h3><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><ul>
<li><p>建造者模式也叫生成器模式，是将产品（属性）和产品的创建过程解耦。</p>
</li>
<li><p>可以将复杂对象的建造过程抽象出来，抽象过程的不同实现方法可以构造出不同表现的对象。</p>
</li>
<li>一步步创建一个复杂的对象，允许用户只通过指定复杂对象的类型和内容就可以构建他们，而不需要知道具体的细节。</li>
</ul>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ul>
<li>Product（产品角色）：一个具体的产品对象</li>
<li>Builder（抽象的建造者）：创建一个product对象的各个部分指定的接口或抽象类。</li>
<li>ConcreteBuilder（具体建造者）：实现接口，创建和装配各个部件</li>
<li>Director（指挥者）：构建一个使用Builder接口的对象，用来创建一个复杂对象<ul>
<li>隔离用户与对象的生产过程</li>
<li>控制产品对象的生产过程</li>
</ul>
</li>
</ul>
<h4 id="JDK源码使用-2"><a href="#JDK源码使用-2" class="headerlink" title="JDK源码使用"></a>JDK源码使用</h4><p>​    建造者模式在StringBuilder中使用</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，相同的创建过程也可以创建不同的产品对象</p>
</li>
<li><p>用户使用不同的建造者可以得到不同的产品对象</p>
</li>
<li>可以更加精细的控制产品的创建过程，将产品的创建步骤分解在不同的方法，使得创建过程更加清晰</li>
<li>增加新的具体建造者无需修改原有的类库代码，复合开闭原则</li>
<li><strong>要求创建的产品具有较多的共同点，其组成部分相似</strong>，不然不适合使用建造者模式。</li>
<li>当产品的内部变化复杂时，会导致有很多具体的建造者的类。</li>
</ul>
<h4 id="与抽象工厂对比"><a href="#与抽象工厂对比" class="headerlink" title="与抽象工厂对比"></a>与抽象工厂对比</h4><ul>
<li><strong>抽象工厂：</strong>实现对产品家族的创建，<strong>具有不同维度的产品组合</strong>，抽象工厂模式不关心构建过程，只关心由什么工厂生产。</li>
<li><strong>建造者模式：</strong>要求按照指定的蓝图建造产品，主要是通过组装零配件而产生一个新的产品。</li>
</ul>
<h3 id="5-适配器模式（Adapter）"><a href="#5-适配器模式（Adapter）" class="headerlink" title="5. 适配器模式（Adapter）"></a>5. 适配器模式（Adapter）</h3><h4 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h4><ul>
<li>适配器模式又叫包装器</li>
<li>将某个类的接口转换成客户端期望的另一个接口表示，让原本因接口不匹配而不能一起工作的两个类可以协同工作。</li>
<li>分类：类适配器模式、对象适配器模式、接口适配器模式</li>
</ul>
<h4 id="①-类适配器模式"><a href="#①-类适配器模式" class="headerlink" title="① 类适配器模式"></a>① 类适配器模式</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>​    Adapter类通过继承src类，实现dst接口，完成适配。</p>
<h5 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h5><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><ul>
<li>Java是单继承机制，所以类适配器需要继承src类，要求dst必须是接口，有一定的局限性。</li>
<li>src类的方法在Adapter中都会暴露出来，增加了使用成本</li>
<li>由于Adapter继承了src类，可更具需求重写src方法，增加了灵活性。</li>
</ul>
<h4 id="②-对象适配器"><a href="#②-对象适配器" class="headerlink" title="② 对象适配器"></a>② 对象适配器</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><ul>
<li>基本思路与类适配器相同，只是让Adapter不再继承src类，而是持有src类的实例（聚合）来解决兼容的问题，即聚合src类来实现dst类的接口，完成src-&gt;dst的适配。</li>
<li>使用<strong>合成复用原则</strong>，用关联代替继承。</li>
</ul>
<h5 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h5><h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><ul>
<li>对象适配器和类适配器是同一种思想的不同实现方式，根据合成复用原则，使用组合代替继承，解决了类适配器必须继承src的局限性，不再要求dst必须是接口。</li>
<li>使用成本低，更灵活。</li>
</ul>
<h4 id="③-接口适配器"><a href="#③-接口适配器" class="headerlink" title="③ 接口适配器"></a>③ 接口适配器</h4><ul>
<li>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择的覆盖父类的某些方法来实现需求。</li>
<li>适用于不想使用一个接口所有方法的情况。</li>
</ul>
<h4 id="SpringMVC源码使用"><a href="#SpringMVC源码使用" class="headerlink" title="SpringMVC源码使用"></a>SpringMVC源码使用</h4><ul>
<li><p>spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类</p>
</li>
<li><p>适配器代替controller执行相应方法，扩展controller时只需要增加一个适配器就完成扩展。</p>
<p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode01.jpg" alt></p>
</li>
</ul>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul>
<li>类适配器：src为类，Adapter继承src</li>
<li>对象适配器：src为类，Adapter聚合src对象</li>
<li>接口适配器：Adapter将src作为一个接口来实现</li>
</ul>
<h3 id="6-桥接模式"><a href="#6-桥接模式" class="headerlink" title="6. 桥接模式"></a>6. 桥接模式</h3><h5 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h5><ul>
<li>将实现与抽象放在不同的类层次中，使两个层次可以独立改变</li>
<li>Bridge模式基于 <strong>类的最小设计原则（类尽可能少）</strong>，通过使用封装、聚合、继承等行为让不同的类承担不同的职责</li>
<li>把抽象与行为实现分离开来，保证各部分的独立性和功能扩展</li>
</ul>
<h5 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h5><p>原始方案：</p>
<p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode02.jpg" alt></p>
<p>桥接模式：</p>
<p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode03.jpg" alt></p>
<h5 id="JDBC源码使用"><a href="#JDBC源码使用" class="headerlink" title="JDBC源码使用"></a>JDBC源码使用</h5><p>​    JDBC的Driver接口</p>
<h5 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h5><p><strong>使用场景：</strong></p>
<ul>
<li>不希望使用继承或使用继承导致类爆炸问题的系统</li>
<li>转账分类：网上 转帐、柜台转账、ATM转账  </li>
<li>转账用户：普通用户、银卡用户、黑卡用户</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>将抽象与实现分层独立出来，有助于系统分层设计</li>
<li>对于高层部分，只需要知道抽象部分和实现部分的接口就可以了，其他的由具体业务来完成</li>
<li>桥接模式代替多层继承，可以减少子类的个数</li>
<li>桥接模式需要正确的识别出系统中两个独立变化的维度，有固定的使用场景。</li>
</ul>
<p>如：手机-直板手机-华为品牌-mate系列   这种多层继承的关系。</p>
<h3 id="7-装饰者模式（decorator）"><a href="#7-装饰者模式（decorator）" class="headerlink" title="7. 装饰者模式（decorator）"></a>7. 装饰者模式（decorator）</h3><h4 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h4><p>​    动态的将功能附加到对象上，再对象功能扩展方面，他比继承更具有弹性，也体现了OCP原则。</p>
<h4 id="问题模型"><a href="#问题模型" class="headerlink" title="问题模型"></a>问题模型</h4><pre><code>1. 用户去点不同的咖啡以及不同的多种配料组合的问题。
 2. 打包东西：多种不同的组合打包
 - 衣服、陶瓷：**被装饰者**
 - 报纸、泡沫、纸板、箱子：**装饰者**
</code></pre><h4 id="类图-6"><a href="#类图-6" class="headerlink" title="类图"></a>类图</h4><p>​    以点咖啡为例。</p>
<p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode04.jpg" alt></p>
<h4 id="JDK源码"><a href="#JDK源码" class="headerlink" title="JDK源码"></a>JDK源码</h4><p>​    Java的IO结构中，FilterInputStream就是装饰者，装饰了InputStream</p>
<h3 id="8-组合模式（部分整体模式）"><a href="#8-组合模式（部分整体模式）" class="headerlink" title="8.组合模式（部分整体模式）"></a>8.组合模式（部分整体模式）</h3><h4 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h4><ul>
<li>创建了对象组的树形结构，将对象组合丞树状结构以表示 <strong>部分-整体</strong> 的层次关系</li>
<li>通过树形结构来组合对象，用来表示部分和整体的层次</li>
<li>使得用户可以对单个对象和组合对象的访问具有一致性</li>
</ul>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>要处理的对象可以生成一颗树形结构，再我们对树上的结点和叶子进行操作时，它能够提供一致的方式</li>
<li>例如学校、学院、专业这种为<strong>组成关系</strong>的场景，他们之间没有继承关系，而是一个树形结构（<strong>更好实现管理</strong>）。</li>
</ul>
<h4 id="类图-7"><a href="#类图-7" class="headerlink" title="类图"></a>类图</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode05.jpg" alt></p>
<h4 id="JDK源码使用-3"><a href="#JDK源码使用-3" class="headerlink" title="JDK源码使用"></a>JDK源码使用</h4><p>​    Java集合类HashMap的实现使用了组合模式，put  和 putAll 方法</p>
<ul>
<li>Map：抽象的构建 -&gt; Component</li>
<li>HashMap：中间的构建 -&gt; composite （相当于College 或 University）</li>
<li>Node：叶子结点   -&gt; Department</li>
</ul>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><ul>
<li>客户端只需要面对一致的对象，不用考虑整体部分或叶子结点的问题</li>
<li>扩展性较强，方便做出复杂的层次结构，容易添加结点或叶子，从而创建出复杂的树形结构</li>
<li><strong>需要遍历组织机构，或者处理的对象具有树形结构时</strong>，适合使用组合模式</li>
<li>如果<strong>叶子和结点有很多差异的话，如很多方法属性都不同</strong>，那么久<strong>不适合使用组合模式</strong>。</li>
</ul>
<h3 id="9-外观模式（过程模式）"><a href="#9-外观模式（过程模式）" class="headerlink" title="9 外观模式（过程模式）"></a>9 外观模式（过程模式）</h3><h4 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h4><ul>
<li>外观模式为子系统中的一组接口提供一个一致的界面，即定义了一个<strong>高层接口</strong>，这个接口可以使得子系统更加容易使用</li>
<li>通过定义一个一致的接口可以屏蔽内部子系统的细节，调用端只需要调用这个接口，无需关心这个子系统的内部细节</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>​    从用户角度出发，通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需要调用这个接口，而无需关心子系统的内部细节。</p>
<h4 id="类图-8"><a href="#类图-8" class="headerlink" title="类图"></a>类图</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode06.jpg" alt></p>
<h4 id="MyBatis源码中得应用"><a href="#MyBatis源码中得应用" class="headerlink" title="MyBatis源码中得应用"></a>MyBatis源码中得应用</h4><p>​    Configuration 创建MetaObject对象使用到了外观模式</p>
<h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><ul>
<li>屏蔽了子系统得细节，降低了客户端对子系统使用得复杂度</li>
<li>通过合理得使用外观模式，可以更好得划分访问层次</li>
<li>当系统需要进行分层设计时，考虑使用Facade模式</li>
<li>在维护一个遗留的大型系统时，可以考虑为新系统开发一个Facade，让新的系统与Facade交互</li>
<li><strong>不要过多的或者不合理的使用外观模式，要让系统有层次，利于维护。</strong> 子系统的组合使用很复杂时才使用。</li>
</ul>
<h3 id="10-享元模式"><a href="#10-享元模式" class="headerlink" title="10. 享元模式"></a>10. 享元模式</h3><p>​    享元的意思就是共享对象</p>
<h4 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a>简介</h4><ul>
<li>享元模式（Flyweight Pattern）也叫蝇量模式，运用共享技术有效的支持大量细粒度的对象</li>
<li><strong>常用于系统底层开发，解决性能问题</strong> ，如数据库连接池，里面有创建好的连接对象，在这些连接对象中，我们需要就可以直接拿来用。</li>
<li>享元模式可以解决重复对象的内存浪费问题，当系统有大量相似对象时，不需要总是创建对象，可以直接从缓冲池里拿。</li>
<li><strong>内部状态：</strong> 对象共享出来的信息，存储在享元对象的内部，不随环境的改变而改变</li>
<li><strong>外部状态：</strong> 对象得以依赖的一个标记，随环境而改变，不可共享的状态</li>
</ul>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>​    经典的应用场景就是池技术，String 常量池，数据库连接池、缓冲池等。</p>
<h4 id="类图-9"><a href="#类图-9" class="headerlink" title="类图"></a>类图</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode07.jpg" alt></p>
<h4 id="JDK源码使用-4"><a href="#JDK源码使用-4" class="headerlink" title="JDK源码使用"></a>JDK源码使用</h4><p>​    Integer使用到了享元模式，在用valueOf创建Integer对象时，相同的值实际上只创建了一个对象。-128~127之间的话使用的是享元模式创建的。否则就直接new一个对象。</p>
<h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><ul>
<li>当系统有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，使用享元模式</li>
<li>使用唯一标识码判断，如果内存中有，则返回唯一标识码标识的对象，用HashMap或HashTable存储（加快了查询速度）</li>
<li>享元模式可大大降低程序的内存占用</li>
<li>需要分离外部状态和内部状态，外部状态具有固化性，不随内部状态的改变而改变。</li>
</ul>
<h3 id="11-代理模式"><a href="#11-代理模式" class="headerlink" title="11. 代理模式"></a>11. 代理模式</h3><h4 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h4><ul>
<li>为对象提供一个替身，以控制对象的访问，通过代理对象访问目标对象，可在目标对象实现的基础上增加额外的功能</li>
<li>被代理的对象可以是远程对象、创建开销大的对象或需要<strong>安全控制</strong>的对象</li>
<li>代理模式不同的形式<ul>
<li>静态代理</li>
<li>动态代理：JDK代理、接口代理</li>
<li>Cglib代理：可以在内存中动态创建对象，不需要实现接口</li>
</ul>
</li>
</ul>
<h4 id="①-静态代理"><a href="#①-静态代理" class="headerlink" title="① 静态代理"></a>① 静态代理</h4><p>​    需要定义接口或者父类，被代理对象和代理对象一起实现相同的接口或者继承相同的父类</p>
<h6 id="类图-10"><a href="#类图-10" class="headerlink" title="类图"></a>类图</h6><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode08.jpg" alt></p>
<h5 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h5><p>​    比如想<strong>对所有的接口进行统一的jwt验证</strong>，这时候就需要使用到代理模式。</p>
<h5 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h5><ul>
<li>先执行代理对象的方法 ，代理对象再调用目标对象，可实现在目标对象执行之前和之后加一些内容。</li>
<li>不修改目标对象的前提下，通过代理对象对目标对象进行扩展</li>
<li>代理对象和目标对象都要实现一样的接口，导致会有很多代理类，且更改时都需要维护</li>
</ul>
<h4 id="②-动态代理"><a href="#②-动态代理" class="headerlink" title="② 动态代理"></a>② 动态代理</h4><h5 id="简介-14"><a href="#简介-14" class="headerlink" title="简介"></a>简介</h5><ul>
<li>代理对象不需要实现接口，但目标对象要实现接口</li>
<li>代理对象的生成使用JDK的API，动态的在内存中构建代理对象</li>
<li>动态代理也叫JDK代理、接口代理</li>
<li>代理类所在的包：<strong>java,lang.reflect.Proxy</strong>，只需使用 <strong>newProxyInstance</strong> 方法</li>
</ul>
<h5 id="类图-11"><a href="#类图-11" class="headerlink" title="类图"></a>类图</h5><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode09.jpg" alt></p>
<h5 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h5><p>​    代理的对象可以动态获取，是通过JDK内置的方法来实现这个过程，最终为了实现的目的都相同。</p>
<h4 id="③-Cglib代理"><a href="#③-Cglib代理" class="headerlink" title="③ Cglib代理"></a>③ Cglib代理</h4><ul>
<li>Cglib代理又叫<strong>子类代理</strong>，他是在内存中构建一个子类对象，从而实现对目标对象功能的扩展，（<strong>代理的类不能为final</strong>）</li>
<li>当目标对象没有实现任何接口时，可使用目标对象的子类实现代理</li>
<li>Cglib是一个强大的高性能的代码生成包，可以在运行期扩展java类与实现java接口，广泛被应用于AOP框架</li>
<li>Cglib的底层通过使用字节码处理框架ASM来转换字节码并生成新的类</li>
</ul>
<h5 id="代理模式选择"><a href="#代理模式选择" class="headerlink" title="代理模式选择"></a>代理模式选择</h5><ul>
<li>目标对象需要实现接口：JDK代理</li>
<li>姆博埃对象不需要实现接口：Cglib代理</li>
</ul>
<h5 id="类图-12"><a href="#类图-12" class="headerlink" title="类图"></a>类图</h5><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode10.jpg" alt></p>
<h5 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h5><ul>
<li>需要引入Cglib的包</li>
<li>相当于拦截器的作用，重写intercept方法，当该方法执行时会调用目标对象的方法。</li>
</ul>
<h3 id="12-模板方法模式"><a href="#12-模板方法模式" class="headerlink" title="12. 模板方法模式"></a>12. 模板方法模式</h3><h4 id="简介-15"><a href="#简介-15" class="headerlink" title="简介"></a>简介</h4><ul>
<li>又叫模板模式，在一个抽象类直接定义了执行它的方法模板，子类可以按需重写方法，<strong>但是调用将以抽象类中定义的方式进行</strong></li>
<li>模板方法定义了一个操作中的算法骨架，将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构就可以重定义该算法的某些特定步骤</li>
<li>客户端子类对象直接调用父类中的template方法，从而实现不同的调用</li>
</ul>
<h4 id="类图-13"><a href="#类图-13" class="headerlink" title="类图"></a>类图</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode11.jpg" alt></p>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>带有大部分相同流程，小部分流程不同的任务，如制作不同口味的豆浆</li>
<li>计算代码的执行时间</li>
</ul>
<h4 id="模板方法中的钩子方法"><a href="#模板方法中的钩子方法" class="headerlink" title="模板方法中的钩子方法"></a>模板方法中的钩子方法</h4><h5 id="简介-16"><a href="#简介-16" class="headerlink" title="简介"></a>简介</h5><ul>
<li>模板方法中的父类中可以定义这样一个方法，它不做任何事情，子类可以视情况决定要不要覆盖，即钩子</li>
<li>比如要实现的是制作纯豆浆，不需要添加任何配料。这时就需要对<strong>是否执行制作中的某个流程</strong>加上判断语句，判断语句的结果为钩子方法的返回值，这样，纯豆浆可以通过<strong>重写这个钩子方法对某个流程是否执行进行控制</strong>。</li>
<li>上述过程，钩子方法可以是空方法，也可以让子类来重写方法，子类重写了就做，没有重写就什么也不做。</li>
</ul>
<h4 id="Spring源码使用-1"><a href="#Spring源码使用-1" class="headerlink" title="Spring源码使用"></a>Spring源码使用</h4><p>​    Spring IOC容器初始化时运用了模板方法模式，具体参考。</p>
<h3 id="13-命令模式"><a href="#13-命令模式" class="headerlink" title="13. 命令模式"></a>13. 命令模式</h3><h4 id="简介-17"><a href="#简介-17" class="headerlink" title="简介"></a>简介</h4><ul>
<li>使得请求的发送者和接受者之间解耦，让对象之间调用关系更加灵活。</li>
<li>在命令模式中，将一个请求封装成一个对象，使用不同的参数来表示不同的请求，命令模式<strong>支持撤销</strong>的操作，。</li>
</ul>
<h4 id="类图-14"><a href="#类图-14" class="headerlink" title="类图"></a>类图</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode12.jpg" alt></p>
<ul>
<li>Invoker：调用者</li>
<li>command：命令角色，需要执行的命令都在这里，可以是接口或者抽象类</li>
<li>Receiver：接受者的角色，知道如何实施和执行一个请求的相关操作</li>
<li>ConcreteCommand：将一个<strong>接收者对象</strong>与一个<strong>动作绑定</strong>，调用接收者相应的操作，实现execute。</li>
<li>实际<strong>需要看课程的代码去理解。</strong></li>
</ul>
<h4 id="Spring-JDBC源码使用"><a href="#Spring-JDBC源码使用" class="headerlink" title="Spring JDBC源码使用"></a>Spring JDBC源码使用</h4><p>​    在JDBC的Template使用到了命令模式，jdbcTemplate就是Invoker</p>
<h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><ul>
<li>使得请求的发送者和接受者之间解耦，发起请求的是调用者，只需要调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的。命令对象起到了纽带桥梁的作用。</li>
<li>容易实现请求的撤销</li>
<li>会导致系统有很多具体的命令类，增加了系统的复杂度。</li>
<li><strong>空命令也算一种设计模式</strong>，省去了对空的判断。</li>
<li>经典的应用场景：界面的一个按钮都是一条命令、模拟CMD、订单的撤销恢复、触发和反馈机制。</li>
</ul>
<h3 id="14-访问者模式"><a href="#14-访问者模式" class="headerlink" title="14. 访问者模式"></a>14. 访问者模式</h3><h4 id="简介-18"><a href="#简介-18" class="headerlink" title="简介"></a>简介</h4><ul>
<li>封装一些作用于某些数据结构的各元素的操作，可以在不改变数据结构的前提下定义作用于这些元素的新操作</li>
<li>将数据结构和数据操作分离，解决<strong>数据结构和操作耦合</strong>的问题。</li>
<li>在被访问的类中添加一个对外提供接待访问者的接口</li>
</ul>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><p>  需要对一个对象结构中的对象进行很多不同的操作（操作之间没有关联），同时需要避免让这些操作“污染”这些对象的类</p>
<h4 id="类图-15"><a href="#类图-15" class="headerlink" title="类图"></a>类图</h4><p> <img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode13.jpg" alt></p>
<ul>
<li>Visitor：抽象的访问者，为每一个ConcreteElement类声明一个visit操作。</li>
<li>ConcreteVisitor：是一个具体的访问者，实现Visitor声明的操作</li>
<li>ObjectStructure：能枚举他的元素，提供一个高层的接口，允许访问者访问元素</li>
<li>Element：定义一个accept方法，接收一个访问者对象</li>
<li>ConcreteElement：具体的元素，实现了accept方法</li>
</ul>
<h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><ul>
<li>访问者模式符合单一原则，扩展性很好</li>
<li>对功能进行统一，可以做报表、UI、拦截器、过滤器，适用于数据结构相对稳定的系统</li>
<li>访问者关注了其他类的内部细节，对具体的元素变更造成了困难，违反了迪米特法则</li>
<li>访问者依赖的是具体元素而不是抽象元素，违反了依赖倒置</li>
<li>适用于系统有稳定的数据结构，又有经常变化的功能需求。</li>
</ul>
<h3 id="15-迭代器模式-Iterrator"><a href="#15-迭代器模式-Iterrator" class="headerlink" title="15 迭代器模式(Iterrator)"></a>15 迭代器模式(Iterrator)</h3><h4 id="简介-19"><a href="#简介-19" class="headerlink" title="简介"></a>简介</h4><ul>
<li>如果我们的集合元素是用不同方式存储的，如数组、集合等，当客户端要遍历这些集合元素时，就需要多种遍历方式，还会暴露元素的内部结构。</li>
<li><strong>迭代器模式为遍历集合提供统一的接口，用一致的方法遍历集合元素</strong>，不需要知道集合对象的底层表示。</li>
</ul>
<h4 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h4><p>​    当不同学院存储各个专业采取不同方式时（如数组、集合），为了对学院的专业进行遍历，需要采取迭代器模式。</p>
<h4 id="类图-16"><a href="#类图-16" class="headerlink" title="类图"></a>类图</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode14.jpg" alt></p>
<ul>
<li>Iterator：迭代器接口，系统提供的</li>
<li>ConcreteIterator：具体的迭代器，管理迭代</li>
<li>Aggregate：一个统一的聚合接口，将客户端和具体的聚合解耦</li>
<li>ConcreteAggregate：具体的聚合持有对象的集合，并提供一个方法，返回一个迭代器，迭代器可以正确的遍历集合</li>
<li>Client：客户端，通过Iterator和Aggregate依赖到子类。</li>
</ul>
<h4 id="JDK-List源码"><a href="#JDK-List源码" class="headerlink" title="JDK-List源码"></a>JDK-List源码</h4><p>​    在JDK-ArrayList中使用到了迭代器模式。因为List 里面会存储不同类型的集合，因此需要通过迭代器来实现。ArrayList、LinkedList、HashList等都实现了List。</p>
<p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode15.jpg" alt></p>
<h4 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h4><ul>
<li>提供了统一的方法遍历对象，如我们使用List的时候，不需要考虑聚合的类型，用统一的方法就可以实现遍历。</li>
<li>隐藏了内部结构，用户只能取到迭代器</li>
<li>把管理对象集合和遍历对象集合的责任分开（单一职责原则）。</li>
</ul>
<h3 id="16-观察者模式（observer）"><a href="#16-观察者模式（observer）" class="headerlink" title="16 观察者模式（observer）"></a>16 观察者模式（observer）</h3><h4 id="简介-20"><a href="#简介-20" class="headerlink" title="简介"></a>简介</h4><ul>
<li><p>用于设计开放式的API，便于第三方接入获取数据，并具有通知功能。</p>
</li>
<li><p>相当于消息的订阅，被订阅方为主题，订阅方为观察者。</p>
</li>
<li><p>观察者模式用集合方式管理用户（Observer)，包括注册、移除和通知</p>
</li>
<li>我们增加观察者（即公告板），不需要修改核心类，满足OCP原则。</li>
</ul>
<h4 id="类图-17"><a href="#类图-17" class="headerlink" title="类图"></a>类图</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode16.jpg" alt></p>
<h4 id="JDK源码使用-5"><a href="#JDK源码使用-5" class="headerlink" title="JDK源码使用"></a>JDK源码使用</h4><p>​    JDK的Observable使用了观察者模式。</p>
<h3 id="17-中介者模式（mediator）"><a href="#17-中介者模式（mediator）" class="headerlink" title="17 中介者模式（mediator）"></a>17 中介者模式（mediator）</h3><h4 id="简介-21"><a href="#简介-21" class="headerlink" title="简介"></a>简介</h4><ul>
<li>用一个中介对象来封装一系列的对象交互，中介者使得各个对象之间不需要显示的相互交互，从而实现松耦合，可以独立的改变他们之间的交互。</li>
</ul>
<h4 id="类图-18"><a href="#类图-18" class="headerlink" title="类图"></a>类图</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode17.jpg" alt></p>
<h4 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h4><ul>
<li>多个类相互耦合会形成网状结构，中介者模式使网状结构分离为星型结构</li>
<li>减少类间的依赖，降低了耦合，符合迪米特法则</li>
<li>中介者承担了主要责任，一旦中介者出问题，整个系统就会受到影响</li>
<li>设计不当会造成中介者过于复杂。</li>
</ul>
<h3 id="18-备忘录模式"><a href="#18-备忘录模式" class="headerlink" title="18 备忘录模式"></a>18 备忘录模式</h3><h4 id="简介-22"><a href="#简介-22" class="headerlink" title="简介"></a>简介</h4><ul>
<li>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到原先保存的状态</li>
<li>用来记录一个对象的某种状态或者某些数据，当要做回退时，可以从备忘录对象中获取原来的数据进行恢复操作。</li>
</ul>
<h4 id="类图-19"><a href="#类图-19" class="headerlink" title="类图"></a>类图</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode18.jpg" alt></p>
<ul>
<li>originator：需要保存状态的对象</li>
<li>Memento：备忘录对象，负责保存好记录，即originator内部的状态</li>
<li>Caretaker：守护者对象，负责保存多个备忘录对象，使用集合管理，提高效率</li>
<li>当需要保存多个originator对象的不同时间的状态时，是需要用HashMap<String, 集合> </String,></li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>​    游戏存档、浏览器后退、数据库事务。</p>
<h4 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h4><ul>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便的回到某个历史版本</li>
<li>实现了信息的封装，是用户不需要关心状态的保存细节</li>
<li>类的成员变量过多时，会占用比较大的资源，每一次保存都会消耗一定的内存</li>
<li><strong>可以和原型模式配合适用，节省资源</strong></li>
</ul>
<h3 id="19-解释器模式-Interpreter"><a href="#19-解释器模式-Interpreter" class="headerlink" title="19 解释器模式(Interpreter)"></a>19 解释器模式(Interpreter)</h3><p><strong>慎用，比较复杂。</strong></p>
<h4 id="简介-23"><a href="#简介-23" class="headerlink" title="简介"></a>简介</h4><ul>
<li>指定一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子（表达式），通常会有一组解释器。</li>
</ul>
<h4 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>将需要解释执行的语言中的句子表示为一个抽象的语法树</li>
<li>一些重复出现的问题可以用一种简单的语言来描述</li>
<li>一个简单语法需要解释的场景</li>
<li>如：编译器、正则表达式、python解释器等</li>
</ul>
<h4 id="类图-20"><a href="#类图-20" class="headerlink" title="类图"></a>类图</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode19.jpg" alt></p>
<ul>
<li>Context：环境角色，含有解释器之外的全部信息</li>
<li>AbstractExpression：抽象表达式，声明一个抽象的解释操作，这个方法被语法树种所有方法共享</li>
<li>TerminalExpression：终结符表达式，实现与文法中的终结符相关的解释操作</li>
<li>NoneTerminalExpression：非终结符表达式，为文法中非终结符实现解释操作</li>
<li>说明：Context和TerminalExpression消息通过Client输入</li>
</ul>
<h4 id="Spring-源码应用"><a href="#Spring-源码应用" class="headerlink" title="Spring 源码应用"></a>Spring 源码应用</h4><p>​    在SpelExpressionParser使用到了解释器模式</p>
<h3 id="20-状态模式（state）重要"><a href="#20-状态模式（state）重要" class="headerlink" title="20 状态模式（state）重要"></a>20 状态模式（state）重要</h3><h4 id="简介-24"><a href="#简介-24" class="headerlink" title="简介"></a>简介</h4><ul>
<li>主要解决对象在向外输出多种状态时，需要对外输出不同的行为的问题，状态和行为是 一 一 对应的，状态之间可以相互转换。</li>
<li>当一个对象的内在状态改变时，允许改变其行为，这个对象看起开像是改变了其类。</li>
</ul>
<h4 id="类图-21"><a href="#类图-21" class="headerlink" title="类图"></a>类图</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode20.jpg" alt></p>
<ul>
<li>Context：环境角色（比如活动），用于维护ConcreteState实例，这个实例定义当前的状态。</li>
<li>State：抽象的状态角色，定义一个接口，封装与Context相关的行为</li>
<li>ConcreteState：具体的状态角色，每个子类实现与Context的一个状态相关的行为。</li>
</ul>
<h4 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h4><p>​    当一个事件有多种状态时，状态之间会相互转换，对不同的状态要求有不同的行为的时候，考虑使用状态模式。</p>
<h4 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h4><ul>
<li>使代码具有可读性，避免了使用了大量的fi else判断，方便维护</li>
<li>符合开闭原则</li>
<li>状态比较多时会产生很多的类，需要维护好</li>
</ul>
<h3 id="21-策略模式-strategy"><a href="#21-策略模式-strategy" class="headerlink" title="21 策略模式(strategy)"></a>21 策略模式(strategy)</h3><h4 id="简介-25"><a href="#简介-25" class="headerlink" title="简介"></a>简介</h4><ul>
<li>策略模式用来定义算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的用户</li>
<li>把变换的代码从不变的代码中分离出来</li>
<li>针对接口编程而不是具体的类，将不同的行为接口聚合到父类中，用户可自行定义其行为。</li>
<li>多用聚合/组合的方式，少用继承（客户通过组合方式使用策略）</li>
</ul>
<h4 id="原理类图"><a href="#原理类图" class="headerlink" title="原理类图"></a>原理类图</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode21.jpg" alt></p>
<p>​    用户context聚合或组合strategy或其他策略接口的成员变量，至于需要使用到哪个策略，可以在构造器中指定。</p>
<h4 id="JDK源码-1"><a href="#JDK源码-1" class="headerlink" title="JDK源码"></a>JDK源码</h4><p>​    JDK的Array的Comparator使用了策略模式，用户可自行排序的策略。</p>
<h4 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h4><ul>
<li>分析项目中变化的部分和不变的部分，多用组合聚合，少用继承，用行为类组合而不是行为的继承</li>
<li>满足OPC原则，<strong>增加行为不用修改原代码，只需要添加一种策略（行为）即可。</strong></li>
<li><strong>提供了可以替换继承的方法</strong>，将算法封装在独立的Strategy类，使得你可以独立其Context改变它。易于切换、理解、扩展。</li>
<li>每一个策略（行为）都是一个类，导致类数目过多。</li>
</ul>
<h3 id="22-职责链模式-Chain-of-Responsibility"><a href="#22-职责链模式-Chain-of-Responsibility" class="headerlink" title="22 职责链模式(Chain of Responsibility)"></a>22 职责链模式(Chain of Responsibility)</h3><h4 id="简介-26"><a href="#简介-26" class="headerlink" title="简介"></a>简介</h4><ul>
<li>为请求创建了一个接收者对象的链，这种模式对请求的发送者和接受者进行解耦</li>
<li>通常每个接收者都包含另一个接收者的引用，如果一个对象不能处理该请求，那么他会把这个请求传递给下一个接收者，以此类推。</li>
</ul>
<h4 id="原理类图-1"><a href="#原理类图-1" class="headerlink" title="原理类图"></a>原理类图</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/designMode/designMode22.jpg" alt></p>
<ul>
<li>Handler：抽象的处理者，定义了一个处理请求的接口，同时定义另外的Handler</li>
<li>ConcreteHandler：具体的处理者，处理他自己负责的请求，可以访问他的后继者（即下一个处理者），如果可以处理当前请求则处理，如果不能则交给后继者处理，从而形成一条链。</li>
<li>Request：含有很多属性，表示一个请求。</li>
<li><strong>可以形成一个环状也可以是一条处理链</strong></li>
</ul>
<h4 id="SpringMVC源码"><a href="#SpringMVC源码" class="headerlink" title="SpringMVC源码"></a>SpringMVC源码</h4><p>​    SpringMVC的 HandlerExecutionChain用到了职责链模式</p>
<h4 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h4><p>​    有多个对象可以处理同一个请求的时候，如多级请求、请假等审批流程，拦截器中也会用到。</p>
<h4 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h4><ul>
<li>把请求和处理分开，实现 解耦</li>
<li>简化了对象，不需要知道链的内部操作</li>
<li>当链比较长的时候，性能会受到影响，通常在Handler中设置一个最大的节点数量</li>
</ul>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul>
<li>模式模式不是100% 的跟标准设计模式一样</li>
<li>一个功能模块可能用到多个模式</li>
</ul>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2019/07/10/通过GPRS将GPS数据上传到服务器/" data-toggle="tooltip" data-placement="top" title="通过GPRS上传GPS数据到服务器">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2019/06/12/PX4开发环境搭建（Ubuntu1804-QGC-Qt-Creator-）/" data-toggle="tooltip" data-placement="top" title="PX4开发环境搭建（Ubuntu1804+QGC+Qt Creator ）">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <div class="comment_notes">
                    <p>
                        本文为作者原创文章，未经作者允许不得转载。
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                

<link rel="stylesheet" href="/css/music-player/fonts/iconfont.css">


<link rel="stylesheet" href="/css/music-player/css/reset.css">


<link rel="stylesheet" href="/css/music-player/css/player.css">



<div class="music-player">
    <audio class="music-player__audio" ></audio>
    <div class="music-player__main">
        <div class="music-player__blur"></div>
        <div class="music-player__disc">
            <div class="music-player__image">
                <img width="100%" src="" alt="">
            </div>
            <div class="music-player__pointer"><img width="100%" src="/img/cd_tou.png" alt=""></div>
        </div>
        <div class="music-player__controls">
            <div class="music__info">
                <h3 class="music__info--title">...</h3>
                <p class="music__info--singer">...</p>
            </div>
            <div class="player-control">
                <div class="player-control__content">
                    <div class="player-control__btns">
                        <div class="player-control__btn player-control__btn--prev"><i class="iconfont icon-prev"></i></div>
                        <div class="player-control__btn player-control__btn--play"><i class="iconfont icon-play"></i></div>
                        <div class="player-control__btn player-control__btn--next"><i class="iconfont icon-next"></i></div>
                        <div class="player-control__btn player-control__btn--mode"><i class="iconfont icon-loop"></i></div>
                    </div>
                    <div class="player-control__volume">
                        <div class="control__volume--icon player-control__btn"><i class="iconfont icon-volume"></i></div>
                        <div class="control__volume--progress player_progress"></div>
                    </div>
                </div>
                <div class="player-control__content">
                    <div class="player__song--progress player_progress"></div>
                    <div class="player__song--timeProgess nowTime">00:00</div>
                    <div class="player__song--timeProgess totalTime">00:00</div>
                </div>

            </div>

        </div>
    </div>
</div>


<script src="/js/music-player/utill.js"></script>


<script src="/js/music-player/jquery.min.js"></script>


<script src="/js/music-player/player.js"></script>


                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <hr>
                <div id="blog_comments"></div>

<!--
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
-->
<!--
<link rel="stylesheet" href="/css/gitment.css">
<script type="text/javascript" src="/js/gitment.js"></script>
-->

<script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/>

<!--
<link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
<script src="https://billts.site/js/gitment.js"></script>
-->

<script>
const myTheme = {
  render(state, instance) {
    const container = document.createElement('div')
    container.lang = "en-US"
    container.className = 'gitment-container gitment-root-container'
    
     // your custom component
    container.appendChild(instance.renderSomething(state, instance))
    
    container.appendChild(instance.renderHeader(state, instance))
    container.appendChild(instance.renderComments(state, instance))
    container.appendChild(instance.renderEditor(state, instance))
    //container.appendChild(instance.renderFooter(state, instance))
    return container
  },
  renderSomething(state, instance) {
    const container = document.createElement('div')
    container.lang = "en-US"
    container.className = 'hello_visitor'
    if (state.user.login) {
      container.innerText = `Hello ${state.user.login}, Welcome to comment system`
    }
    return container
  }
}


const gitment = new Gitment({
    id: 'Tue Jun 18 2019 20:15:37 GMT+0800', // optional
    owner: "beyonderwei",
    repo: "gitment",
    oauth: {
      client_id: "3154a4ba998ba4f00302",
      client_secret: "bdef21bcc8a5357adad5f7c9b0371e40034a8246",
    },
    theme: myTheme,
    // ...
    // For more available options, check out the documentation below
  })
  
  gitment.render('blog_comments')
  // or
  // gitment.render(document.getElementById('comments'))
  // or
  // document.body.appendChild(gitment.render())
</script>
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#设计模式" title="设计模式">设计模式</a>
                        
                          <a class="tag" href="/tags/#Java" title="Java">Java</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://blog.csdn.net/CSDN_X_W" target="_blank">CSDN</a></li>
                    
                        <li><a href="#" target="_blank">Web</a></li>
                    
                        <li><a href="https://github.com/Beyonderwei" target="_blank">Github</a></li>
                    
                        <li><a href="#" target="_blank">Other</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                
                    <li>
                        <a target="_blank"  href="https://github.com/Beyonderwei">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://twitter.com/beyonderwei">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://www.facebook.com/beyonderwei">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/beyonderwei">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Beyonderwei 2021 
                    <br>
					瞌睡遇上枕头：
                    <a href="http://beian.miit.gov.cn" target="_blank" rel="noopener">吉ICP备20000556</a>
                    <!--<a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=dusign&repo=hexo-theme-snail&type=star&count=true">
                    </iframe>-->
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>


<!-- Search -->

<script src="/js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://beyonderwei.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
