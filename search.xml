<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CC3200 GPIO 简单易懂实现引脚拉高、拉低</title>
      <link href="/2019/03/17/CC3200-GPIO-%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E5%AE%9E%E7%8E%B0%E5%BC%95%E8%84%9A%E6%8B%89%E9%AB%98%E3%80%81%E6%8B%89%E4%BD%8E/"/>
      <url>/2019/03/17/CC3200-GPIO-%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E5%AE%9E%E7%8E%B0%E5%BC%95%E8%84%9A%E6%8B%89%E9%AB%98%E3%80%81%E6%8B%89%E4%BD%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;前面已经可以实现从服务器获得用户想要的浇水量，下面就需要对IO口进行拉高拉低对水泵的启停进行控制。</p><h2 id="二、CC3200-GPIO-简介"><a href="#二、CC3200-GPIO-简介" class="headerlink" title="二、CC3200 GPIO 简介"></a>二、CC3200 GPIO 简介</h2><p>&#8195;&#8195;CC3200所有逻辑引脚和部分模拟引脚均可以用来作为通用输入/输出(GPIO)使用。GPIO功能可用于各种逻辑输入输出的场合。 GPIO有4组（GPIO A0~A3），每组8个。 具体如下：<br>&#8195;&#8195;①. &#8195;GPIO A0： GPIO_00~GPIO_07, 对应 GPIOA0.0~GPIOA0.7 。<br>&#8195;&#8195;②. &#8195;GPIO A1： GPIO_08~GPIO_15, 对应 GPIOA1.0~GPIOA1.7 。<br>&#8195;&#8195;③. &#8195;GPIO A2： GPIO_00~GPIO_07, 对应 GPIOA2.0~GPIOA2.7 。<br>&#8195;&#8195;④. &#8195;GPIO A3： GPIO_00~GPIO_07, 对应 GPIOA3.0~GPIOA3.7 。</p><p>&#8195;&#8195;根据功能引脚的配置不同， GPIO的数量有27个 。所有GPIO引脚具备中断能力(电平有效或者边沿有效、上升或下降沿触发、有中断屏蔽)。可用于出发DMA或作为唤醒源。</p><h2 id="三、简单易懂实现IO口拉高拉低"><a href="#三、简单易懂实现IO口拉高拉低" class="headerlink" title="三、简单易懂实现IO口拉高拉低"></a>三、简单易懂实现IO口拉高拉低</h2><p>&#8195;&#8195;CC3200 提供了一系列 API 去更方便的实现用户想要的功能。在SDK的 driverlib 和 src 下。我们导入的例程都包含了这些API。但是例程里面的实现方法显得过于复杂，不易理解，但是对我们来说是一个重要的参考。下面 过滤掉  “_if_” 层，通过直接调用 API 实现对IO的拉高拉低。==注意：==<strong>重要的说明在程序的注释中，对于每一个形参代表的意思的理解非常重要。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">BoardInit();<span class="comment">//板子初始化</span></span><br><span class="line"><span class="comment">/*--引脚配置  Start--*/</span></span><br><span class="line">        PinTypeGPIO(PIN_64, PIN_MODE_0, <span class="literal">false</span>);<span class="comment">//参数：引脚名 引脚功能模式  开漏模式或STD</span></span><br><span class="line">        GPIODirModeSet(GPIOA1_BASE, GPIO_PIN_1, GPIO_DIR_MODE_OUT);<span class="comment">//哪一组的端口地址  GPIO_A1的第1个 GPIO位权(0~7)   输入或者输出</span></span><br><span class="line">        <span class="comment">/*--引脚配置  End--*/</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        MAP_UtilsDelay(<span class="number">2000000</span>);</span><br><span class="line">        GPIOPinWrite(GPIOA1_BASE,GPIO_PIN_1,GPIO_PIN_1);<span class="comment">//拉高IO口</span></span><br><span class="line">        MAP_UtilsDelay(<span class="number">2000000</span>);</span><br><span class="line">        GPIOPinWrite(GPIOA1_BASE,GPIO_PIN_1,<span class="number">0</span>);<span class="comment">//拉低IO口</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样就实现了对于PIN_64引脚的拉高拉低操作，如果是launchpad的话就可以看到LED灯一直闪烁。<br>==注：== 在pin.h 和 gpio.h 中都对于每一个IO口的地址都进行了定义，对于每一个API只需要相对应的使用即可，但是，<strong>需要了解 T I对 CC3200 的引脚定义，知道其对应关系，具体参照下表。</strong>(引自源地的资料)<br><img src="CC3200-GPIO-简单易懂实现引脚拉高、拉低/cc3200_gpios.png" alt=""></p><h2 id="四、学习方法"><a href="#四、学习方法" class="headerlink" title="四、学习方法"></a>四、学习方法</h2><p>&#8195;&#8195;TI 对于每一种功能都提供了例程，所以如果我们需要用到相应的功能就可以直接去参考例程中是如何配置的，这对于为了快速的上手开发是一个行之有效的好方法。 比如：我们模数转换会用到ADC ，那么就可以直接去参考例程中的ADC有关引脚的配置，等等。</p><h2 id="五、视频展示"><a href="#五、视频展示" class="headerlink" title="五、视频展示"></a>五、视频展示</h2><p>&#8195;&#8195;到此为止，整个远程浇水系统就完成了，达不到商品化的稳定性，但能够在较长时间内实现该功能。<br><strong>视频地址：</strong> <a href="https://www.bilibili.com/video/av43996928" target="_blank" rel="noopener">https://www.bilibili.com/video/av43996928</a></p><h2 id="六、专栏地址"><a href="#六、专栏地址" class="headerlink" title="六、专栏地址"></a>六、专栏地址</h2><p>&#8195;&#8195;<a  href ="https://blog.csdn.net/CSDN_X_W/column/info/33567">点击查看专栏</a></p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CC3200 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CC3200 POST 数据到服务器</title>
      <link href="/2019/03/17/CC3200-POST-%E6%95%B0%E6%8D%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/03/17/CC3200-POST-%E6%95%B0%E6%8D%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;上篇文章已经完成了从服务器 get 数据，这篇将通过 post 的方式，将通过CC3200测得的花卉状态信息（如土壤湿度、光照强度）上传到服务器。其实post的方式也实现了接收服务器返回的数据，所以只发送一个post请求就可以完成数据的上传和获取，具体在下面说明。</p><h2 id="二、CC3200-连接到路由器（AP）"><a href="#二、CC3200-连接到路由器（AP）" class="headerlink" title="二、CC3200 连接到路由器（AP）"></a>二、CC3200 连接到路由器（AP）</h2><p>&#8195;&#8195;这里已经在上篇文章说过了，具体可以参照：<br>&#8195;&#8195;<a href="https://blog.csdn.net/CSDN_X_W/article/details/86756675" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_X_W/article/details/86756675</a></p><h2 id="三、CC3200-post-数据到服务器"><a href="#三、CC3200-post-数据到服务器" class="headerlink" title="三、CC3200 post 数据到服务器"></a>三、CC3200 post 数据到服务器</h2><p>&#8195;&#8195; 同样是将后台代码和CC3200的相关配置一起列出来。<br><strong>3.1 后台代码：</strong> 这里解析的数据是CC3200发送过来的花卉状态信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理CC3200 POST 给服务器的数据 -&gt;更新花卉的状态信息 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span>   <span class="comment">//用于接收CC3200 post 过来的数据</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/cc3200Post"</span>)   <span class="comment">//这个方法用来处理CC3200Post请求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">CC3200PostResponse</span><span class="params">(@RequestBody String flower_info)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">    <span class="comment">/*--更新花卉的状态信息--*/</span></span><br><span class="line">    <span class="keyword">int</span> monitorID;</span><br><span class="line">    <span class="keyword">float</span> co2;</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">    System.out.println(flower_info);</span><br><span class="line">    <span class="comment">//1.解析post过来的数据</span></span><br><span class="line">    JSONObject jsonObject = <span class="keyword">new</span> JSONObject(flower_info);</span><br><span class="line">    monitorID = jsonObject.getInt(<span class="string">"monitorID"</span>);</span><br><span class="line">    co2 = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"co2"</span>);</span><br><span class="line">    temperature = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"temperature"</span>);</span><br><span class="line">    humidity = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"humidity"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.根据花卉监测系统ID更新数据库的数据</span></span><br><span class="line">    String updateSql =</span><br><span class="line">            <span class="string">"update flowers set co2 ="</span> + <span class="string">"'"</span> + co2 + <span class="string">"'"</span> +<span class="string">","</span>+</span><br><span class="line">            <span class="string">"temperature ="</span>+<span class="string">"'"</span> + temperature + <span class="string">"'"</span> +<span class="string">","</span>+</span><br><span class="line">            <span class="string">"humidity ="</span>+<span class="string">"'"</span> + humidity + <span class="string">"'"</span> +</span><br><span class="line">            <span class="string">" WHERE monitor_id ="</span>+ <span class="string">"'"</span> + monitorID + <span class="string">"'"</span>;</span><br><span class="line">    jdbcTemplate.update(updateSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>3.2 CC3200 代码：</strong> </p><ol><li>CC3200 的相关配置，在main.c 中 , IP 和端口配置不再赘述，参考上篇文章。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POST_REQUEST_URI  <span class="meta-string">"/cc3200Post"</span>         <span class="comment">//请求方式 即发送什么样的请求</span></span></span><br><span class="line"><span class="comment">/*--Post过去的数据--*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POST_DATA       <span class="meta-string">"&#123;\n\"name\":\"xyz\",\n\"address\":\n&#123;\n\"plot#\":12,\n\"street\":\"abc\",\n\"city\":\"ijk\"\n&#125;,\n\"age\":30\n&#125;"</span></span></span><br></pre></td></tr></table></figure></li><li>在 CC3200 中post数据的具体实现通过调用 static int HTTPPostMethod(HTTPCli_Handle httpClient) 函数中调用的 TTPCli_sendRequestBody(httpClient, POST_DATA , (sizeof(POST_DATA )-1));  来实现的，这样运行后就能在后台接收到 POST_DATA 当中的数据。这样我们就已经实现了将数据 post 到服务器。<h2 id="四、疑问（重要）"><a href="#四、疑问（重要）" class="headerlink" title="四、疑问（重要）"></a>四、疑问（重要）</h2>&#8195;&#8195;1.==需要思考这样一个问题== ：我们 post 过去的数据是要有变量的，如温度（temperature），可是如何将这样一些变量拼接 JSON 形式的字符串当中去呢？早就有人帮我们写好了这样的库，即-&gt; cJSON , 需要引入 cJSON 的 .c 和 .h 文件后可参考下面这样一段代码：<br>&#8195;&#8195;2.定义 flowerStatusData 代替原来的 POST_DATA，则原来的 TTPCli_sendRequestBody函数的形参也要相应修改：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">char</span> *outData;</span><br><span class="line"><span class="keyword">char</span> flowerStatusData[<span class="number">63</span>]=&#123;<span class="number">0</span>&#125;;  <span class="comment">//数组长度应该是 strlen 得到的字符串长度加一   这个值根据上传的数据量经调试打印得到</span></span><br></pre></td></tr></table></figure>&#8195;&#8195;3.具体post数据的部分可以参考如下代码，main.c 中：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--根据测得的数据信息，post数据到服务器，从而更新花卉的状态数据--*/</span></span><br><span class="line"><span class="comment">//创建一个cJSON结构体指针并分配空间，然后赋值给root</span></span><br><span class="line">cJSON *root = cJSON_CreateObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在root结构体中创建一组健为"key",值为" value" 的键值对。</span></span><br><span class="line">cJSON_AddNumberToObject(root,<span class="string">"monitorID"</span>,monitor_id);</span><br><span class="line">cJSON_AddNumberToObject(root,<span class="string">"co2"</span>,co2);</span><br><span class="line">cJSON_AddNumberToObject(root,<span class="string">"temperature"</span>,temperature);</span><br><span class="line">cJSON_AddNumberToObject(root,<span class="string">"humidity"</span>,humidity);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--得到无格式形式的json字符串，即输出无回车和空格分离的键值对--*/</span></span><br><span class="line">        outData = cJSON_PrintUnformatted(root);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(flowerStatusData, outData, <span class="built_in">strlen</span>(outData));</span><br><span class="line">UART_PRINT(<span class="string">"\n\r"</span>);</span><br><span class="line">UART_PRINT(<span class="string">"HTTP Post Begin:\n\r"</span>);</span><br><span class="line">    lRetVal = HTTPPostMethod(&amp;httpClient);</span><br><span class="line">    <span class="keyword">if</span>(lRetVal &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    UART_PRINT(<span class="string">"HTTP Post failed.\n\r"</span>);</span><br><span class="line">&#125;</span><br><span class="line">UART_PRINT(<span class="string">"HTTP Post End:\n\r"</span>);</span><br><span class="line"><span class="built_in">free</span>(outData);<span class="comment">//释放malloc分配的空间</span></span><br><span class="line">        cJSON_Delete(root);<span class="comment">//释放cJSON结构体指针</span></span><br></pre></td></tr></table></figure></li></ol><p>==注：== 具体 cJSON 的使用可以百度到很多博客，cJSON 的下载网址为：<br>&#8195;&#8195;<a href="https://sourceforge.net/projects/cjson/" target="_blank" rel="noopener">https://sourceforge.net/projects/cjson/</a><br>&#8195;&#8195;直接将cJSON.c  和 cJOSN.h 添加到工程调用即可。</p><h2 id="五、专栏地址"><a href="#五、专栏地址" class="headerlink" title="五、专栏地址"></a>五、专栏地址</h2><p>&#8195;&#8195;<a  href ="https://blog.csdn.net/CSDN_X_W/column/info/33567">点击查看专栏</a></p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> CC3200 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CC3200 从服务器 get 数据</title>
      <link href="/2019/03/17/CC3200-%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8-get-%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/03/17/CC3200-%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8-get-%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;借助 TI 公司的 CC3200 我们可以通过 http 轻松的完成与服务器之间的数据交互，体验CC3200的开箱即用的感觉，下面借助 http_client_demo 这个历程来实现从服务器 get 数据。实现我们从服务器得到用户的浇水信息。<br>&#8195;&#8195;<strong>CC3200的SDK 里面提供了所有的关于CC3200的资料，真的非常重要。</strong> 如：API文档、例程、例程使用文档、数据手册、原理图 … 等等。<br><img src="CC3200-从服务器-get-数据/cc3200get-01.png" alt=""></p><h2 id="二、CC3200-连接到路由器（AP）"><a href="#二、CC3200-连接到路由器（AP）" class="headerlink" title="二、CC3200 连接到路由器（AP）"></a>二、CC3200 连接到路由器（AP）</h2><p>&#8195;&#8195;此时CC3200 作为站点，即工作在 Sta（station）模式。简单理解就好比我们手机连上路由器或者数据才能上网一样，所需配置的地方如下：在common.h 中</p><ol><li>SSID_NAME ：填入路由器所设置的名字。</li><li>SECURITY_TYPE ：安全方式，路由器设置为有密码时一般为  SL_SEC_TYPE_WPA_WPA2；没有密码时，定义为 SL_SEC_TYPE_OPEN。</li><li>SECURITY_KEY ：有密码时这里填入密码。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Values for below macros shall be modified as per access-point(AP) properties// Values for below macros shall be modified as per access-point(AP) properties</span></span><br><span class="line"><span class="comment">// SimpleLink device will connect to following AP when application is executed</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*--下面的设置为CC3200作为客户端时需要连接的路由器的相关信息 所以要根据所连接的路由器进行修改--*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SSID_NAME           <span class="meta-string">" "</span>    <span class="comment">/* AP SSID */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECURITY_TYPE       SL_SEC_TYPE_WPA_WPA2    <span class="comment">/* Security type (OPEN or WEP or WPA*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECURITY_KEY        <span class="meta-string">" "</span>              <span class="comment">/* Password of the secured AP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SSID_LEN_MAX        32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSSID_LEN_MAX       6</span></span><br></pre></td></tr></table></figure>&#8195;&#8195;运行程序仿真运行，可以登录路由器网关查看连接状态。或者直接用串口打印出来看连接是否成功，如下图：<br><img src="CC3200-从服务器-get-数据/cc3200get-02.png" alt=""><br>width=80% height=80%&gt;<br>&#8195;&#8195;仿真报错时可以参考下面这篇博客：<br>&#8195;&#8195;<a href="https://blog.csdn.net/CSDN_X_W/article/details/86676351" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_X_W/article/details/86676351</a><h2 id="三、从服务器-get-数据"><a href="#三、从服务器-get-数据" class="headerlink" title="三、从服务器 get 数据"></a>三、从服务器 get 数据</h2>&#8195;&#8195;首先需要将上一节的服务器端运行起来，根据服务器去更改CC3200这边的相应请求，再贴上上一节后台服务器的代码一起参考：<br>&#8195;&#8195;<strong>3.1、后台代码：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 处理CC3200 发送过来的 GET 请求 -&gt;查询花卉的浇水量返回给CC3200  <span class="doctag">@TODO</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ResponseBody</span>   <span class="comment">//用于将数据写出去</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/cc3200Query"</span>)   <span class="comment">//这个方法用来处理query请求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt;  <span class="title">cc3200GetResponse</span><span class="params">(@RequestParam <span class="keyword">int</span> monitor_id)</span> </span>&#123;    <span class="comment">//这个字符串拼接的方法来实现sql语句中嵌套变量好嘛？</span></span><br><span class="line">    String querySql = <span class="string">"select * From flowers where monitor_id ="</span> + <span class="string">"'"</span> + monitor_id + <span class="string">"'"</span>;</span><br><span class="line">    <span class="comment">//这样返回的是一个map 而不是 list 的形式更方便CC3200那边去解析</span></span><br><span class="line">    Map&lt;String, Object&gt; map =jdbcTemplate.queryForMap(querySql);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&#8195;&#8195;<strong>3.2、CC3200 相关配置：</strong> </li><li>更改 main.c 中如下配置：&#8195;&#8195;&#8195;&#8195;ip根据自己的实际更改<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_REQUEST_URI  <span class="meta-string">"/cc3200Query?monitor_id=1"</span><span class="comment">//请求方式 即发送什么样的请求  请求参数为monitor_id</span></span></span><br><span class="line"><span class="comment">/*--HOST_NAME HTTP服务器的IP地址或者域名  如我的服务器的IP地址为......--*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST_NAME        <span class="meta-string">"192.168.43.148"</span> <span class="comment">//"&lt;host name&gt;"</span></span></span><br><span class="line"><span class="comment">/*--HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如tomcat的默认端口是8080 http://localhost:8080/--*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST_PORT           8080</span></span><br></pre></td></tr></table></figure><ol><li>==重点：更改所 get 的数据的长度== （没找到相关博客和TI教程我看代码研究了好久，可能C基础较差吧。）<br>&#8195;&#8195;①. len的长度决定了最终放到 g_buff 中数据的个数，否则g_buf中存放的是当前时间。<br>&#8195;&#8195;②. 最终get到的数据就存放再 g_buff 这个静态变量中，可以直接打印到控制台。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readResponse</span><span class="params">(HTTPCli_Handle httpClient)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">long</span> lRetVal = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> len = <span class="number">114</span>;  <span class="comment">//@TODO 重要：这里决定了收到的数据的长度  数值靠数   包括外面的大括号</span></span><br><span class="line"> <span class="keyword">int</span> json = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">char</span> *dataBuffer=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">bool</span> moreFlags = <span class="number">1</span>;</span><br><span class="line"> <span class="comment">//.......</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>再程序的最后把 get 到的数据打印到控制台。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">UART_PRINT(<span class="string">"\n\r"</span>);</span><br><span class="line">UART_PRINT(<span class="string">"HTTP Get Begin:\n\r"</span>);</span><br><span class="line">lRetVal = HTTPGetMethod(&amp;httpClient);</span><br><span class="line"><span class="keyword">if</span>(lRetVal &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    UART_PRINT(<span class="string">"HTTP Post Get failed.\n\r"</span>);</span><br><span class="line">&#125;</span><br><span class="line">UART_PRINT(<span class="string">"HTTP Get End:\n\r"</span>);</span><br><span class="line">UART_PRINT(<span class="string">"\n\r"</span>);</span><br><span class="line"><span class="comment">/*--根据得到的json数据进行解析 Start--*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"g_buff:%s\n"</span>,g_buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"size:%d\n"</span>,<span class="built_in">strlen</span>(g_buff));</span><br></pre></td></tr></table></figure>&#8195;&#8195;这样就可以在控制台打印出如下数据：<br><img src="https://img-blog.csdnimg.cn/2019020311590237.png"weight=70% height=70%><br>&#8195;&#8195;<strong>注意：</strong><br>&#8195;&#8195;&#8195;&#8195;①. ==在用printf(“”); 打印时一定要加上换行“\n” ;不然数据是打印不出来的。==<br>&#8195;&#8195;&#8195;&#8195;②. 现在得到的数据为 JSON 格式，如果想得到某一项数据，需要对得到的 JSON 数据进行解析，最好的办法是使用 cJSON 库，具体可参照下面一段代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cJSON *root;</span><br><span class="line">       cJSON *ret;</span><br><span class="line">       root = cJSON_Parse(g_buff);    <span class="comment">//将cJSON字符串转换为cJSON结构体指针</span></span><br><span class="line">       ret = cJSON_GetObjectItem(root, <span class="string">"bulk"</span>);    <span class="comment">//在root结构体中查找"key"这个键(一个字符串),成功返回一个cJSON结构体，失败返回NULL。</span></span><br><span class="line">       bulk=ret-&gt;valueint;<span class="comment">//获取到浇水量</span></span><br><span class="line">       cJSON_Delete(ret);    <span class="comment">//释放cJSON结构体指针</span></span><br><span class="line">       cJSON_Delete(root);    <span class="comment">//释放cJSON结构体指针</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,bulk);<span class="comment">//打印到控制台查看</span></span><br></pre></td></tr></table></figure>==注：== cJSON 的下载地址如下，直接复制 cJSON.c 和 cJSON.h 到工程中使用即可。<br>&#8195;&#8195;<a href="https://sourceforge.net/projects/cjson/" target="_blank" rel="noopener">https://sourceforge.net/projects/cjson/</a></li></ol></li></ol><h2 id="四、学习方法"><a href="#四、学习方法" class="headerlink" title="四、学习方法"></a>四、学习方法</h2><p>&#8195;&#8195;1.TI SDK 中提供了大量的例程，而直接导入例程稍作修改就能够实现我们想要的目的，是一个很好的参考，在看例程的过程中也可以加强编写程序的规范性。</p><p>&#8195;&#8195;2.如果项目中应用到了更多的功能，也可以将相关的例程融合到一起，对于 CC3200 主要的用到的是 driverlib 这个库，各个功能都封装成了API供我们快速开发，很方便。</p><h2 id="五、专栏地址"><a href="#五、专栏地址" class="headerlink" title="五、专栏地址"></a>五、专栏地址</h2><p>&#8195;&#8195;<a  href ="https://blog.csdn.net/CSDN_X_W/column/info/33567">点击查看专栏</a></p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> CC3200 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 SpringBoot 写一个简单的后台服务</title>
      <link href="/2019/03/17/%E7%94%A8-SpringBoot-%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/03/17/%E7%94%A8-SpringBoot-%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>&#8195;&#8195;可以说站在Spring Boot的肩膀上，相对于我之前用最古老的servlet，完成一个简单的后台服务实在变得太容易太容易。但是对于一个完全不了解的人可以参考目录中的<strong>学习方法</strong>。对于实现远程浇花的功能，只需要处理APP 和 CC3200 发送过来的 get 、post 请求即可。</p><h2 id="二、说明"><a href="#二、说明" class="headerlink" title="二、说明"></a>二、说明</h2><p>&#8195;&#8195;①．Spring Boot 只是一个框架，通过联网帮助我们完成了各种配置，简化开发。<br>&#8195;&#8195;②．具体详细的步骤可以在学习SpringBoot的过程中不断实践。<br><strong>注意：IDEA一定要用专业版，社区版的是不能构建SpringBoot项目的，如下图社区版根本没有红色圈中的那项：</strong><br><img src="用-SpringBoot-写一个简单的后台服务/iotSpringBoot-01.png" alt=""></p><h2 id="三、数据库"><a href="#三、数据库" class="headerlink" title="三、数据库"></a>三、数据库</h2><p>&#8195;&#8195;当然后台要负责与数据库进行交互，花卉的信息也全都存放在数据库上。后台的代码就是要对数据库进行增、删、改、查等操作。我用的是MySQL。直接装，或者用Docker。</p><h2 id="四、后台服务代码"><a href="#四、后台服务代码" class="headerlink" title="四、后台服务代码"></a>四、后台服务代码</h2><ol><li>Cotroller部分：这里即包含了APP的后台服务，也包含了CC3200的后台服务，后面不再赘述。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowerManagerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-------------------处理 APP 与后台的交互-----------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 APP 发送过来的 GET 请求 -&gt; 查询花卉的所有信息返回给 APP</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flower_name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>   <span class="comment">//用于将数据写出去</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/appQuery"</span>)   <span class="comment">//这个方法用来处理query请求</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; appGetResponse(<span class="meta">@RequestParam</span> String flower_name) &#123;</span><br><span class="line">        <span class="comment">//字符串拼接的方法来实现sql语句中嵌套变量</span></span><br><span class="line">        String querySql = <span class="string">"select * From flowers where name ="</span> + <span class="string">"'"</span> + flower_name + <span class="string">"'"</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(querySql);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 APP POST 给服务器的数据 -&gt;更新数据库中的浇水量 bulk  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>   <span class="comment">//用于接收APP post 过来的数据</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/appPost"</span>)   <span class="comment">//这个方法用来处理App的post请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appPostResponse</span><span class="params">(@RequestBody String flower_info)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">        <span class="comment">/*--更改花卉的浇水量--*/</span></span><br><span class="line">        String flower_name;</span><br><span class="line">    <span class="keyword">int</span> bulk;</span><br><span class="line">        <span class="comment">//1.解析post过来的数据</span></span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject(flower_info);</span><br><span class="line">        mFlower_name = jsonObject.getString(<span class="string">"name"</span>);</span><br><span class="line">        mBulk = jsonObject.getInt(<span class="string">"bulk"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.根据花卉名称和浇水量更新DB的数据</span></span><br><span class="line">        String updateSql = <span class="string">"update flowers set bulk ="</span> + <span class="string">"'"</span> + bulk + <span class="string">"'"</span> + <span class="string">" WHERE name ="</span> + <span class="string">"'"</span> + flower_name + <span class="string">"'"</span>;    </span><br><span class="line">        jdbcTemplate.update(updateSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-----------------------处理 CC3200 与后台的交互-------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理CC3200 发送过来的 GET 请求 -&gt;查询花卉的浇水量返回给CC3200  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>   <span class="comment">//用于将数据写出去</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/cc3200Query"</span>)   <span class="comment">//这个方法用来处理query请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt;  <span class="title">cc3200GetResponse</span><span class="params">(@RequestParam <span class="keyword">int</span> monitor_id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串拼接的方法来实现sql语句中嵌套变量</span></span><br><span class="line">        String querySql = <span class="string">"select * From flowers where monitor_id ="</span> + <span class="string">"'"</span> + monitor_id + <span class="string">"'"</span>;</span><br><span class="line">        <span class="comment">//这样返回的是一个map 而不是 list 的形式更方便CC3200那边去解析</span></span><br><span class="line">        Map&lt;String, Object&gt; map =jdbcTemplate.queryForMap(querySql);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理CC3200 POST 给服务器的数据 -&gt;更新花卉的状态信息 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>   <span class="comment">//用于接收CC3200 post 过来的数据</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/cc3200Post"</span>)   <span class="comment">//这个方法用来处理CC3200Post请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">CC3200PostResponse</span><span class="params">(@RequestBody String flower_info)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">        <span class="comment">/*--更新花卉的状态信息--*/</span></span><br><span class="line">        <span class="keyword">int</span> monitorID;</span><br><span class="line">    <span class="keyword">float</span> co2;</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//1.解析post过来的数据</span></span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject(flower_info);</span><br><span class="line">        monitorID = jsonObject.getInt(<span class="string">"monitorID"</span>);</span><br><span class="line">        co2 = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"co2"</span>);</span><br><span class="line">        temperature = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"temperature"</span>);</span><br><span class="line">        humidity = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"humidity"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.根据花卉监测系统ID更新数据库的数据</span></span><br><span class="line">        String updateSql =</span><br><span class="line">                <span class="string">"update flowers set co2 ="</span> + <span class="string">"'"</span> + co2 + <span class="string">"'"</span> +<span class="string">","</span>+</span><br><span class="line">                <span class="string">"temperature ="</span>+<span class="string">"'"</span> + temperature + <span class="string">"'"</span> +<span class="string">","</span>+</span><br><span class="line">                <span class="string">"humidity ="</span>+<span class="string">"'"</span> + humidity + <span class="string">"'"</span> +</span><br><span class="line">                <span class="string">" WHERE monitor_id ="</span>+ <span class="string">"'"</span> + monitorID + <span class="string">"'"</span>;</span><br><span class="line">        jdbcTemplate.update(updateSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>application.yaml 部分：这里根据实际的情况配置即可<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://公网IP或域名:3306/数据库名</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="五、学习路线（仅供参考）"><a href="#五、学习路线（仅供参考）" class="headerlink" title="五、学习路线（仅供参考）"></a>五、学习路线（仅供参考）</h2><p>&#8195;&#8195;1. pringBoot 我是通过学习观看 尚硅谷 的Springboot视频学习的，下载地址可以搜哦，有人上传到网盘了，或者哔哩哔哩上也有，而IDEA的使用关注他的微信公众号就可以免费下载，个人感觉还是不错的。反正免费嘛。<br>&#8195;&#8195;2. 在Ubuntu 上使用 Docker 可以参考下面的链接（安装MySQL也是很方便的）。<br>&#8195;&#8195;&#8195;<a href="https://cloud.tencent.com/developer/article/1350956" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1350956</a></p><h2 id="六、专栏地址"><a href="#六、专栏地址" class="headerlink" title="六、专栏地址"></a>六、专栏地址</h2><p>&#8195;&#8195;<a href="https://blog.csdn.net/CSDN_X_W/column/info/33567" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_X_W/column/info/33567</a></p>]]></content>
      
      
      <categories>
          
          <category> 后台 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP与服务器之间通过 http(POST、GET)进行数据交互</title>
      <link href="/2019/03/17/APP%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E9%80%9A%E8%BF%87HTTP%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/"/>
      <url>/2019/03/17/APP%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E9%80%9A%E8%BF%87HTTP%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<h2 id="一、APP-POST-数据到服务器"><a href="#一、APP-POST-数据到服务器" class="headerlink" title="一、APP POST 数据到服务器"></a>一、APP POST 数据到服务器</h2><p>&#8195;&#8195;首先 post 的数据应该包括识别这个花卉的信息和我们想要浇水的量，这里我们识别花卉采用花卉的名字，这样后台程序通过花卉名来对应更新数据库中该花的浇水量。</p><ol><li>mFlower_name：花卉名  </li><li>mBulk : 浇水量 </li></ol><p>实现代码如下：<br><strong>注意：</strong></p><ol><li>String urlPath 中的 IP 地址是我局域网的地址，如果你的后台程序是在云服务器上运行的那么应改成云服务器的公网IP。不过可以先在局域网内实现嘛。</li><li>http 的默认端口号为80，但由于我用的是springboot框架打包成的jar包，自带了嵌入的tomcat，而tomcat容器默认的端口号为8080（可以在配置文件（.yml）中更改）。</li><li>服务端的代码可参照专栏中的下一篇文章。<br>&#8195;&#8195;<strong>Code:</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-- 将浇水量等信息上传到服务器    安卓4.0以后必须在子线程中执行 --*/</span></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String urlPath = <span class="string">"http://192.168.43.148:8080/appPost"</span>;  <span class="comment">//URL</span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(urlPath);</span><br><span class="line">            HttpURLConnection coon = (HttpURLConnection) url.openConnection();</span><br><span class="line">            coon.setRequestMethod(<span class="string">"POST"</span>);<span class="comment">//请求方式为POST</span></span><br><span class="line">            coon.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line">            coon.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>);     <span class="comment">//设置发送的数据为 json 类型，会被添加到http body当中</span></span><br><span class="line">            String json = <span class="string">"&#123;\"name\":\""</span>+ mFlower_name+<span class="string">"\","</span> + <span class="string">"\"bulk\":"</span> + <span class="string">"\""</span> +mBulk+ <span class="string">"\"&#125;"</span>;    <span class="comment">//将要发送的花卉数据字符串连接成json格式</span></span><br><span class="line">            coon.setRequestProperty(<span class="string">"Content-Length"</span>, String.valueOf(json.length()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//post请求把数据以流的方式写给服务器，指定请求的输出模式</span></span><br><span class="line">            coon.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">            coon.getOutputStream().write(json.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> code = coon.getResponseCode();</span><br><span class="line">            <span class="keyword">if</span> (code == <span class="number">200</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"请求成功"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"请求失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"请求失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></li></ol><h2 id="二、APP-从服务器-GET-数据"><a href="#二、APP-从服务器-GET-数据" class="headerlink" title="二、APP 从服务器 GET 数据"></a>二、APP 从服务器 GET 数据</h2><p>&#8195;&#8195;APP 同样需要从服务器获得花卉的状态信息来更新显示界面，如更新到最新的土壤湿度、光照强度等显示给用户。<br>实现代码如下：<br><strong>注意：</strong></p><ol><li>从服务器得到的数据为 list 形式，所以解析较复杂一些，这取决于你服务器返回什么样的数据，在下一篇文章会有说明。服务器直接返回 map 形式APP这边会更好解析。具体百度啦！<br><strong>Code:</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查询服务器 得到花卉的信息  更新显示的数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String urlPath = <span class="string">"http://192.168.43.148:8080/appQuery?flower_name="</span> + mFlower_name;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(urlPath);</span><br><span class="line">            HttpURLConnection coon = (HttpURLConnection) url.openConnection();</span><br><span class="line">            coon.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">            coon.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> code = coon.getResponseCode();</span><br><span class="line">            <span class="keyword">if</span> (code == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">//1.得到输入流</span></span><br><span class="line">                InputStream is = coon.getInputStream();</span><br><span class="line">                <span class="comment">//2.将流用自己写的StreamUtils转化为字符串  改字符串为json格式</span></span><br><span class="line">                String flowerInfo = StreamUtils.readStream(is);</span><br><span class="line">                <span class="comment">//3.解析json数据（这里是list形式）  并显示数据</span></span><br><span class="line">                JSONArray flowerJsonArray = <span class="keyword">new</span> JSONArray(flowerInfo);</span><br><span class="line">                <span class="comment">// 这里的数组长度其实是1</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerJsonArray.length(); i++) &#123;</span><br><span class="line">                    JSONObject flowerJsonObject = flowerJsonArray.getJSONObject(i);</span><br><span class="line">                    mTv_temperature.setText(flowerJsonObject.getString(<span class="string">"temperature"</span>));<span class="comment">//温度</span></span><br><span class="line">                    mTv_humidity.setText(flowerJsonObject.getString(<span class="string">"humidity"</span>));<span class="comment">//湿度</span></span><br><span class="line">                    mTv_co2.setText(flowerJsonObject.getString(<span class="string">"co2"</span>));<span class="comment">//CO2 浓度</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Message msg = Message.obtain();</span><br><span class="line">                msg.what = STATUS_ERROR;</span><br><span class="line">                mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><h2 id="三、APP-界面部分"><a href="#三、APP-界面部分" class="headerlink" title="三、APP 界面部分"></a>三、APP 界面部分</h2>&#8195;&#8195;这部分就主要看自己如何去设计了，主要还是要多学习一些，才能做出更好看、功能更加丰富的APP。下面展示一下我做的APP（由于技术原因以及没有艺术细胞，做的着实有些丑）。</li></ol><p><figure class="half">    <img src="./APP与服务器之间通过HTTP进行数据交互/app-01.png">    <img src="./APP与服务器之间通过HTTP进行数据交互/app-02.png"></figure></p><h2 id="四、相关疑问"><a href="#四、相关疑问" class="headerlink" title="四、相关疑问"></a>四、相关疑问</h2><ol><li>后台相关的代码呢？<br> 在下一节贴上我的服务端的代码，其实站在SpringBoot的肩膀上，我们后台的搭建显得异常的容易。</li><li>APP 的其他代码和功能呢？<br> 这里我之列出了POST 和 GET 过程相关的代码，如果真的要实现众多功能，还是要花好长一段时间去学习安卓。<h2 id="五、学习方法"><a href="#五、学习方法" class="headerlink" title="五、学习方法"></a>五、学习方法</h2></li><li>我个人是通过学习完Java以后，在某宝花了几十块钱买的教学视频，还有哔哩哔哩上的天哥在奔跑的视频也还不错，等等。这里仅仅只是个人的学习过程，仅供参考。<h2 id="六、专栏地址"><a href="#六、专栏地址" class="headerlink" title="六、专栏地址"></a>六、专栏地址</h2>&#8195;&#8195;<a  href ="https://blog.csdn.net/CSDN_X_W/column/info/33567">点击查看专栏</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 移动开发 </category>
          
          <category> 后台 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TI CC3200 Launchpad 用UniFlash下载程序到Flash</title>
      <link href="/2019/03/17/TI-CC3200-Launchpad-%E7%94%A8UniFlash%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%E5%88%B0Flash/"/>
      <url>/2019/03/17/TI-CC3200-Launchpad-%E7%94%A8UniFlash%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%E5%88%B0Flash/</url>
      
        <content type="html"><![CDATA[<h2 id="开发环境要求："><a href="#开发环境要求：" class="headerlink" title="开发环境要求："></a>开发环境要求：</h2><ol><li>CCS UniFlash ：到TI官网注册账号后直接在搜索栏搜索即可 （注意：要选择下载第一个 ：UNIFLASH_PREVIOUS   另外一个是用来给CC2650 C2000等烧录程序而用的）<br><img src="TI-CC3200-Launchpad-用UniFlash下载程序到Flash/cc3200Flash-01.png" alt=""></li><li>CCS 3X00 Servicepack : 由于没有在TI官网找到 安装包我上传到了百度网盘 永久有效  下载后安装即可<br>  链接：<a href="https://pan.baidu.com/s/1g9Lz_tPr8YiunH7h3tgtRw" target="_blank" rel="noopener">https://pan.baidu.com/s/1g9Lz_tPr8YiunH7h3tgtRw</a><br>  提取码：9kpr  <h2 id="下载程序到Flash："><a href="#下载程序到Flash：" class="headerlink" title="下载程序到Flash："></a>下载程序到Flash：</h2></li><li>注意： 我们是下载程序到Flash   所以SOP2 SOP1 SOP0  应该是100  如下图将SOP2用短路帽接成高电平<img src="TI-CC3200-Launchpad-用UniFlash下载程序到Flash/cc3200Flash-02.png" alt=""></li><li>打开应用程序选择File/New Configritions<br><img src="TI-CC3200-Launchpad-用UniFlash下载程序到Flash/cc3200Flash-03.png" alt=""></li><li>在Conection下拉菜单中选择 CC3x Serial（UART） Interface   选择后下面会自动为你选择 Simplink Wifi CC3100/CC3200<br>点击OK。<br><img src="TI-CC3200-Launchpad-用UniFlash下载程序到Flash/cc3200Flash-04.png" alt=""></li><li>USB线连接上我们的Launchpad，由于程序是通过串口下载的 所以这里要选择串口的端口号  我们可以在设备管理器查看  或者其他串口软件助手 然后将串口号填入到 COM Port中，例如我的是7<br><img src="TI-CC3200-Launchpad-用UniFlash下载程序到Flash/cc3200Flash-05.png" alt=""><img src="TI-CC3200-Launchpad-用UniFlash下载程序到Flash/cc3200Flash-06.png" alt=""></li><li>点击Format 进行格式化，其中Capacity 选择8M  点击OK  等待格式化完成<br><img src="TI-CC3200-Launchpad-用UniFlash下载程序到Flash/cc3200Flash-07.png" alt=""></li><li>烧写网络底层程序<br><img src="TI-CC3200-Launchpad-用UniFlash下载程序到Flash/cc3200Flash-08.png" alt=""><br>选择之前安装的Service Pack 安装目录下的servicepack_1.0.11-2.10.0.0.bin 文件，点击打开，等待烧写完成<br><img src="TI-CC3200-Launchpad-用UniFlash下载程序到Flash/cc3200Flash-09.png" alt=""></li><li>选择需要烧写的文件，具体操作如下所示。选择想要烧写的工程下的 .bin 二进制文件<br> 例如：E:\WorkSpace\CC3200launchPad\LED\Release\LED.bin  (这里因为我更改了默认的工作空间路径和工程名 所以我的路径与工程名有所不同)<br><img src="TI-CC3200-Launchpad-用UniFlash下载程序到Flash/cc3200Flash-10.png" alt=""><br>选择　LED.bin 文件 ：<br><img src="TI-CC3200-Launchpad-用UniFlash下载程序到Flash/cc3200Flash-11.png" alt=""></li><li>将程序烧写到 Flash 中：<pre><code> 勾选 Erase 、Update 、Verify  ![](TI-CC3200-Launchpad-用UniFlash下载程序到Flash/cc3200Flash-12.png) 然后点击Program 将程序下载</code></pre><img src="TI-CC3200-Launchpad-用UniFlash下载程序到Flash/cc3200Flash-13.png" alt=""></li><li>等待烧写完成，这样我们的程序就下载好了，将SOP2处的跳线帽拔掉，然后重新上电，我们的程序就运行啦！以后程序都是上电直接运行的，不需要按复位键。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CC3200 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TI CC3200 launchpad 使用 CCS 下载</title>
      <link href="/2019/03/17/TI-CC3200-launchpad-%E4%BD%BF%E7%94%A8-CCS-%E4%B8%8B%E8%BD%BD/"/>
      <url>/2019/03/17/TI-CC3200-launchpad-%E4%BD%BF%E7%94%A8-CCS-%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="开发环境要求"><a href="#开发环境要求" class="headerlink" title="开发环境要求"></a>开发环境要求</h2><ol><li>CCS ：6.0版本及以上（免费软件）  去TI官网下载新一点的安装即可 （安装时安装包的路径及安装路径均不能有中文）</li><li>IAR ：6.7版本及以上  （这里以CCS为例IAR不做介绍）<br><img src="TI-CC3200-launchpad-使用-CCS-下载/CCSDownload-01.png" alt=""></li><li>SDK ： 去TI官网下载安装CC3200的SDK 里面有历程和文档资料等 适合仔细阅读 包括API .c .h文件等 下载安装即可<br><img src="TI-CC3200-launchpad-使用-CCS-下载/CCSDownload-02.png" alt=""><h2 id="跳线帽的连接"><a href="#跳线帽的连接" class="headerlink" title="跳线帽的连接"></a>跳线帽的连接</h2>&#8195;&#8195;由于是JTAG的下载方式，所以SOP的三个引脚均为0（低电平）  悬空状态，不需要用跳线帽连接，如下图：<br> （注：PWR ：（下图黄圈中右边的那个）是供电引脚 ，一定要接 ，不然板子插上后是没有电的，指示灯也不会亮）<br> <img src="TI-CC3200-launchpad-使用-CCS-下载/CCSDownload-03.png" alt=""><h2 id="工程导入下载"><a href="#工程导入下载" class="headerlink" title="工程导入下载"></a>工程导入下载</h2><ol><li>Project/import ccs project<br><img src="TI-CC3200-launchpad-使用-CCS-下载/CCSDownload-04.png" alt=""></li><li>点击Browse-&gt;找到安装ADK的目录  例如 ：C:\ti\CC3200SDK_1.3.0\cc3200-sdk\example\blinky\ccs  选择ccs文件夹 如下图  ： 然后点击finish，这样工程就导入成功了。是直接copy过来的。 除了link过来的文件 你去更改其他文件是不会对下次导入带来影响的。<img src="TI-CC3200-launchpad-使用-CCS-下载/CCSDownload-05.png" alt=""><ol><li>工程出现的问题<br>①. 工程有警告 :  在工程上右键 选择属性配置<br><img src="TI-CC3200-launchpad-使用-CCS-下载/CCSDownload-06.png" alt=""><br>选择编译器版本和下载器类型，不然会在下载时提示找不到相应的 .ccxml 文件  如下<br><img src="TI-CC3200-launchpad-使用-CCS-下载/CCSDownload-07.png" alt=""><br>选择编译器  ：<br><img src="TI-CC3200-launchpad-使用-CCS-下载/CCSDownload-08.png" alt=""></li></ol></li></ol></li><li>链接好板子，点击编译下载即可：（编译：小锤子图标     下载：绿色的小虫子）<br><img src="TI-CC3200-launchpad-使用-CCS-下载/CCSDownload-09.png" alt=""></li><li>点击运行即可  绿色的类似播放的小按钮 （这种方式只是把程序下载到了RAM掉电会丢失  之后会介绍如何用Uniflash 下载程序到Flash中）。运行后就可以看到板载的三个LED灯循环闪烁了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CC3200 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TI CC3200 launchpad 简介</title>
      <link href="/2019/03/17/TI-CC3200-launchpad-%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/03/17/TI-CC3200-launchpad-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&#8195;&#8195;基于 TI 最新推出的 CC3200 平台。 CC3200 使得客户能够轻松地为众多的家用、工业和消费类电子产品增添嵌入式 Wi-Fi 和互联网功能，所凭借的特性包括：业界最低的功耗（适用于电池供电式设备），以及低功耗射频和高级低功耗模式； 高度的灵活性，利用 CC3200 的集成型可编程 ARM® Cortex®-M4 MCU，从而允许客户添加其特有的代码。可利用快速连接、云支持和片上 Wi-Fi、互联网和稳健的安全协议实现针对 IoT 的简易型开发，无需具备开发连接型产品的先前经验。能够采用某种手机或平板电脑应用程序或者一种具有多种配置选项（包括SmartConfig™ 技术、针对 WPS 和 AP 模式的网络浏览器简单且安全地将其设备连接至Wi-Fi。</p><h2 id="器件概述"><a href="#器件概述" class="headerlink" title="器件概述"></a>器件概述</h2><p><img src="TI-CC3200-launchpad-简介/概述.png" alt="图片"></p><h2 id="官方launchpad硬件介绍"><a href="#官方launchpad硬件介绍" class="headerlink" title="官方launchpad硬件介绍"></a>官方launchpad硬件介绍</h2><p><img src="TI-CC3200-launchpad-简介/launchpad.png" alt=""></p><ol><li>UART Singles  ：launchpad的USB口既支持下载仿真又支持串口（不能同时使用），下载程序后可将串口打开用于调试。<br>注： PIN_55： UART0_TX          PIN_57：UART0_RX      </li><li>FTDI JTAG emu ： JTAG芯片  launchpad的下载方式是四线JTAG （重要：这与后面下载程序时SOP的接线有关）  </li><li>nReset : 复位键  </li><li>Sensor area : 板载的传感器-&gt;红外温度传感器TMP006  </li><li>JTAG headers : JTAG 的四根线 （保证程序可以下载  这四根线一定要用短路帽连接） </li><li>Sense on power (SOP) pins : 决定下载方式  JTAG下载时三根线都不接  具体如下图（板子上也有标注）：<br><img src="TI-CC3200-launchpad-简介/sop.png" alt=""><ol><li>7.U.FL conn : 板载天线  如果使用AP模式  也可以自己买一个2.4G的天线接在 J18 上。</li><li>SW2 SW3 ： 两个按键  </li><li>LEDS：三个LED　分别对应引脚　P11  P10  P9    (板子上有标注）</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CC3200 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TI C2000 TMS320F28379D SCID SCIB 的配置与使用</title>
      <link href="/2019/03/17/TI-C2000-TMS320F28379D-SCID-SCIB-%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/03/17/TI-C2000-TMS320F28379D-SCID-SCIB-%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#8195;&#8195;TI的官方例程里面只给了SCIA的配置而没有给其他的SCI的配置方法 其实这些的配置都是一样的，下面以SCIB和SCID的配置为例并结合数据手册说明一下配置过程：至于一些参数为什么要向程序中那样配置可参考F28379的技术手册和博客最后面的截图（当然了也都是在技术手册中截的）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************系统配置*****************/</span></span><br><span class="line">    InitSysCtrl();        <span class="comment">// 初始化系统</span></span><br><span class="line">    InitGpio();            <span class="comment">// 初始化GPIO   SciIOCfg();            // 初始化SCI   引脚的初始化</span></span><br><span class="line">    <span class="comment">/*中断配置*/</span> </span><br><span class="line">    DINT; <span class="comment">//关闭所有中断</span></span><br><span class="line">    InitPieCtrl();  <span class="comment">//初始化PIE 控置寄存器到它们的默认状态。默认所有 PIE 被清除</span></span><br><span class="line">    <span class="comment">//失能所有的CPU中断 并清除所有的CPU中断标志：</span></span><br><span class="line">    IER = <span class="number">0x0000</span>;</span><br><span class="line">    IFR = <span class="number">0x0000</span>;</span><br><span class="line">    InitPieVectTable();<span class="comment">//用指向shell中断服务例程（ISR）的指针来初始化PIE 向量表。</span></span><br><span class="line">    <span class="comment">/*中断向量配置*/</span></span><br><span class="line">    EALLOW;</span><br><span class="line">    PieVectTable.SCIB_RX_INT = &amp;scibRxFifoIsr;        <span class="comment">//串口B接收中断</span></span><br><span class="line">    PieVectTable.SCID_RX_INT = &amp;scidRxFifoIsr;      <span class="comment">//串口D接收中断    EDIS;</span></span><br><span class="line">    <span class="comment">/*SCI带FIFO接收中断*/</span></span><br><span class="line">    scib_fifo_init();                     <span class="comment">//初始化SCI_B 的FIFO</span></span><br><span class="line">    scid_fifo_init();                    <span class="comment">//初始化SCI_D 的FIFO    PieCtrlRegs.PIECTRL.bit.ENPIE = 1;   // Enable the PIE block    PieCtrlRegs.PIEIER9.bit.INTx3 = 1;   // PIE Group 9, INT3,配置sciB 接收中断使能*/</span></span><br><span class="line">    PieCtrlRegs.PIEIER8.<span class="built_in">bit</span>.INTx7 = <span class="number">1</span>;   <span class="comment">// PIE Group 8, INT7,配置sciD 接收中断使能*/    IER |= M_INT9|M_INT8;                // Enable CPU INT</span></span><br><span class="line">    EINT;   <span class="comment">//启用全局中断INTM</span></span><br></pre></td></tr></table></figure><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><ol><li><p>首先是其中SCI初始化函数的配置程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SciIOCfg（）；</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SciIOCfg</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*SCIB：配置GPIO为上拉和复用功能*/</span> <span class="comment">//注意这里端口引脚的复用需要找数据表中 GPIO Muxed Pins端口复用引脚的第几种复用方式 SCIB为2</span></span><br><span class="line">    <span class="comment">//RX--P19</span></span><br><span class="line">    GPIO_SetupPinMux(<span class="number">19</span>, GPIO_MUX_CPU1, <span class="number">2</span>);</span><br><span class="line">    GPIO_SetupPinOptions(<span class="number">19</span>, GPIO_INPUT, GPIO_PULLUP);  <span class="comment">//这里应该是GPIO_PULLUP -&gt;1  例程错误 原本例程为GPIO_PUSHPULL -&gt;0  正确应该是GPIO_PULLUP 启用上拉</span></span><br><span class="line">    <span class="comment">//TX--18</span></span><br><span class="line">    GPIO_SetupPinMux(<span class="number">18</span>, GPIO_MUX_CPU1, <span class="number">2</span>);</span><br><span class="line">    GPIO_SetupPinOptions(<span class="number">18</span>, GPIO_OUTPUT, GPIO_ASYNC);    <span class="comment">/*SCID：配置GPIO为上拉和复用功能*/</span> <span class="comment">//注意这里端口引脚的复用需要找数据表中 GPIO Muxed Pins端口复用引脚的第几种复用方式 SCID为6</span></span><br><span class="line">    <span class="comment">//RX--P105</span></span><br><span class="line">    GPIO_SetupPinMux(<span class="number">105</span>, GPIO_MUX_CPU1, <span class="number">6</span>);</span><br><span class="line">    GPIO_SetupPinOptions(<span class="number">105</span>, GPIO_INPUT, GPIO_PULLUP);</span><br><span class="line">    <span class="comment">//TX--104</span></span><br><span class="line">    GPIO_SetupPinMux(<span class="number">104</span>, GPIO_MUX_CPU1, <span class="number">6</span>);</span><br><span class="line">    GPIO_SetupPinOptions(<span class="number">104</span>, GPIO_OUTPUT, GPIO_ASYNC);&#125;</span><br></pre></td></tr></table></figure></li><li><p>FIFO初始化函数：scib_fifo_init();      （当然SCID只需把程序中的scib改成scid即可 这里不赘述SCID）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scib_fifo_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ScibRegs.SCICCR.all = <span class="number">0x0007</span>;              <span class="comment">// 一个停止位 无回环</span></span><br><span class="line">                                            <span class="comment">// 无奇偶校验位 ,8个字符位 ,</span></span><br><span class="line">                                                  <span class="comment">// async （空闲线）模式, 空闲线协议</span></span><br><span class="line">    ScibRegs.SCICTL1.all = <span class="number">0x0003</span>;             <span class="comment">// 使能 TX, RX, 内部 SCICLK（SCI时钟）,</span></span><br><span class="line">                                                  <span class="comment">// Disable RX ERR, SLEEP, TXWAKE</span></span><br><span class="line">    <span class="comment">//波特率高低位</span></span><br><span class="line">    ScibRegs.SCIHBAUD.all = <span class="number">0x0000</span>;</span><br><span class="line">    ScibRegs.SCILBAUD.all = SCI_PRD;        <span class="comment">// 配置波特率为SCI_PRD</span></span><br><span class="line">    ScibRegs.SCIFFTX.all = <span class="number">0xE040</span>;        <span class="comment">// 使能SCI的FIFO功能，重置SCI,发送重置    ScibRegs.SCIFFRX.bit.RXFFIENA = 1;        // 使能SCI FIFO发送功能</span></span><br><span class="line">    ScibRegs.SCIFFRX.<span class="built_in">bit</span>.RXFFIL = RXNUM;    <span class="comment">// 设定接受位数为RXNUM 0h-10h</span></span><br><span class="line">    ScibRegs.SCIFFRX.<span class="built_in">bit</span>.RXFFINTCLR =<span class="number">1</span>;        <span class="comment">// FIFO计数中断标志位清零    ScibRegs.SCIFFCT.all = 0x00;    ScibRegs.SCICTL1.all = 0x0023;             // 重启sci</span></span><br><span class="line">    ScibRegs.SCIFFRX.<span class="built_in">bit</span>.RXFIFORESET = <span class="number">1</span>;    <span class="comment">// 重启sci接收fifo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>至于波特率的配置就需要对照官方例程了，注意：时钟为200兆时才正确 如何计算可以在技术手册中找到哦！SCI的官方例程中也是这样计算的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//波特率计算方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_FREQ           200E6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSPCLK_FREQ     CPU_FREQ/4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCI_FREQ        115200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCI_PRD         (LSPCLK_FREQ/(SCI_FREQ*8))-1</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="附图"><a href="#附图" class="headerlink" title="附图"></a>附图</h2><ol><li>引脚复用<br><img src="TI-C2000-TMS320F28379D-SCID-SCIB-的配置与使用/c200sci-01.png" alt=""></li><li>中断通道映射：<br><img src="TI-C2000-TMS320F28379D-SCID-SCIB-的配置与使用/c200sci-01.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> DSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C2000 </tag>
            
            <tag> SCI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCS安装多版本编译器 Compiler version</title>
      <link href="/2019/03/17/CCS%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8-Compiler-version/"/>
      <url>/2019/03/17/CCS%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8-Compiler-version/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>&#8195;&#8195;当我们向CCS中导入工程时常因为编译器的版本不对或者不兼容造成工程报错或者是有警告。如下图：<br><img src="CCS安装多版本编译器-Compiler-version/compiler01.png" alt=""></p><p>&#8195;&#8195;但是当我们打开properties（属性）/General/目录下选择Compiler version（编译器版本）时，发现没有与工程对应的编译器。<br><img src="CCS安装多版本编译器-Compiler-version/compiler02.png" alt=""><br>&#8195;&#8195;所以这就需要我们自己去安装需要版本的编译器，安装步骤如下：（这里以CC3200为例）</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>打开help/Insatll New Software/出现如下界面：<br><img src="CCS安装多版本编译器-Compiler-version/compiler03.png" alt=""></li><li>在下拉三角号中选择<br>Code Generation Tools Updates - <a href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_ccstudio/codegen/Updates/p2win32" target="_blank" rel="noopener">http://software-dl.ti.com/dsps/dsps_public_sw/sdo_ccstudio/codegen/Updates/p2win32</a><br><img src="CCS安装多版本编译器-Compiler-version/compiler04.png" alt=""></li><li>展开TI Compiler Update 即可找到所有我们当前CCS未安装的编译器   点击What is already install？可以查看当前所安装的编译器<br><img src="CCS安装多版本编译器-Compiler-version/compiler05.png" alt=""><br><img src="CCS安装多版本编译器-Compiler-version/compiler06.png" alt=""></li><li>最后选择我们想要安装的编译器安装即可   一路next  next 重启CCS等待安装  Over<br><img src="CCS安装多版本编译器-Compiler-version/compiler07.png" alt=""></li><li>当我们再次展开下拉菜单选择编译器版本时就可以发现自己已经安装的了<br><img src="CCS安装多版本编译器-Compiler-version/compiler08.png" alt=""><br>注：如果还没有的话，可以点击右面的 More按钮  然后Refresh（刷新）一下。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编译器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCS中新建TMS320F28379D工程的方法</title>
      <link href="/2019/03/17/CCS%E4%B8%AD%E6%96%B0%E5%BB%BATMS320F28379D%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2019/03/17/CCS%E4%B8%AD%E6%96%B0%E5%BB%BATMS320F28379D%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、准备资料"><a href="#一、准备资料" class="headerlink" title="一、准备资料"></a>一、准备资料</h1><p>&#8195;&#8195;CCS （要支持C2000，我使用的7.3.0版本） ；controlSUITE或者C2000Ware  （推荐C2000Ware，因为他的例程多）。<br>&#8195;&#8195;注：以上三个安装包都可以在TI官网找到，如下图。TI提供的TMS320F28379D的一部分资料。<br><img src="CCS中新建TMS320F28379D工程的方法/28379d-01.png" alt="图片"><br>&#8195;&#8195;新建工程记得在TI的宣讲会上TI工程师推荐的最快最好用的方式也就是导入例程然后去改例程。每一个类型的例程都添加了这个功能所需要的文件。所以在自己的工程中相应的添加即可。</p><h1 id="二、新建方法"><a href="#二、新建方法" class="headerlink" title="二、新建方法"></a>二、新建方法</h1><ol><li>下载安装了以上两个软件库之后在CCS中打开View\Reasourse Explorer Classic 会出现以下界面<br><img src="CCS中新建TMS320F28379D工程的方法/28379d-02.png" alt="图片"></li><li>在下面这里选择你要导入的例程<br><img src="CCS中新建TMS320F28379D工程的方法/28379d-03.png" alt="图片"><br>&#8195;&#8195;比如选定上面的“blinky_cpu01”后 右面会出现导入步骤  点击Step1：后的Import the exsample project into CCS 即可将工程导入到当前的工作空间。如下图：<br><img src="CCS中新建TMS320F28379D工程的方法/28379d-04.png" alt="图片"><br>注意：USER是我自己添加的 直接在工程文件目录中添加即可 这里就会显示 并在User下新建了一个main.c文件 并将原本的blinky_cpu01.c中的内容复制到main.c中再将原本包含main.c的blinky_cpu01.c文件删掉。这样做的目的是因为USer以外的文件并不实际存在工程中，而是在C2000ware中 link过来的 ，如果你直接更改blinky_cpu01.c,下一次导入时工程就变成了你更改过的了。所以为了保存原有例程的程序不变就需要采用以上方法。</li><li>这样工程就建立就好了，还需要以下配置 选中工程 AIT+Enter 打开属性界面（或在工程上右键选择）；将User的路径加入。如下图<br><img src="CCS中新建TMS320F28379D工程的方法/28379d-05.png" alt="图片"></li><li>除此之外还需要配置以下内容：注意 link command file  选择none (我使用的是TI的lanchpad 下载器为XDS 100V2)<br><img src="CCS中新建TMS320F28379D工程的方法/28379d-06.png" alt="图片"><br>&#8195;&#8195;这样整个工程就创建完成了。将程序下载到RAM 即可看到板子上的的蓝灯闪烁了。因为例程配置的就是P31引脚。lanchpad的硬件原理图如下 ：<br><img src="CCS中新建TMS320F28379D工程的方法/28379d-07.png" alt="图片"></li></ol>]]></content>
      
      
      <categories>
          
          <category> DSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C2000 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CC3200SDK例程导入到CCS编译出错解决办法</title>
      <link href="/2019/03/17/CC3200SDK%E4%BE%8B%E7%A8%8B%E5%AF%BC%E5%85%A5%E5%88%B0CCS%E7%BC%96%E8%AF%91%E5%87%BA%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2019/03/17/CC3200SDK%E4%BE%8B%E7%A8%8B%E5%AF%BC%E5%85%A5%E5%88%B0CCS%E7%BC%96%E8%AF%91%E5%87%BA%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、所报错误"><a href="#一、所报错误" class="headerlink" title="一、所报错误"></a>一、所报错误</h2><ol><li>Description Resource Path Location Type—float_support=fpalib is deprecated. To compile without hardware —float_support=fpalib is deprecated. To compile without hardware gpio_if.c /blinky   C/C++ Problem</li><li>编译时报错如下图所示：<br><img src="CC3200SDK例程导入到CCS编译出错解决办法/cc3200sdk03.png" alt="图片"></li></ol><h2 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h2><ol><li>在工程上右键/properties/Build/ARM Compiler 会发现报错 如下图：<br><img src="CC3200SDK例程导入到CCS编译出错解决办法/cc3200sdk04.png" alt="图片"></li><li>这时将fpalib改成vfplib 即可解决问题。修改方法为：点击上图右下角Edit Flags ,将最上面一行的fpalib改成vfplib保存；</li><li>这时再重新编译，之前的错误就没有了。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ccs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于云服务器、CC3200完整搭建物联网系统</title>
      <link href="/2019/03/17/%E5%9F%BA%E4%BA%8E%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81CC3200%E5%AE%8C%E6%95%B4%E6%90%AD%E5%BB%BA%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/03/17/%E5%9F%BA%E4%BA%8E%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81CC3200%E5%AE%8C%E6%95%B4%E6%90%AD%E5%BB%BA%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;本系列文章主要讲解如何通过 CC3200（简单理解为单片机和WIFI模块的结合体）、云服务器、APP 来实现远程控制。所有的程序全部自己编写，我们可以真正意义上的实现：<br>①. 远程控制家中的热水器烧水<br>②. 远程控制监测环境数据<br>… … 等等。（==可以尽情的发挥想象，想象好了就可以开始了！==）<br>比如：<strong>我想实现远程浇花这个功能</strong>（因为室友养的花寒暑假没有人照看，实现这样一个功能就很不错）</p><h2 id="二、知识基础"><a href="#二、知识基础" class="headerlink" title="二、知识基础"></a>二、知识基础</h2><p>&#8195;&#8195;要想实现以上功能需要具备以下一些知识技能：<br>&#8195;&#8195;这些知识或许还有好多都不会，甚至有一部分都没有听说过（如果你会很多，那就再好不过了），但是所有的内容都可以去学习呀！我也是从大二下学期开始学习的，大三下学期实现的，而且是机械设计制造及其自动化专业。</p><ol><li>主要编程语言：C、Java。</li><li>主要IDE：CCS、IDEA、AndroidStudio。</li><li>框架：SpringBoot。</li><li>系统：Windows、Linux（Ubuntu）。<br><strong>注：</strong><br>&#8195;&#8195;其实在这个过程中所涉及到的知识还远不止上面这些，如果想学习的更多，理解的更彻底，每一部分都值得深入的去研究、学习。<h2 id="三、主要目标"><a href="#三、主要目标" class="headerlink" title="三、主要目标"></a>三、主要目标</h2></li><li><p>APP与服务器之间进行双向通讯：    要能够通过APP获得花卉的状态数据，比如土壤的湿度，光照强度等等；同时 APP 还要能够将用户浇水的命令上传到服务器。</p></li><li><p>CC3200 与服务器进行双向通讯：    CC3200 将土壤湿度、光照强度等信息上传到服务器，同时CC3200还要能从服务器获取数据。</p></li><li><p>CC3200 控制水泵的浇水实现：    这里主要是控制部分的实现，CC3200要根据从服务器获取的数据，进行浇水的控制。</p><h2 id="四、视频展示"><a href="#四、视频展示" class="headerlink" title="四、视频展示"></a>四、视频展示</h2><p>简单的实现远程的浇水功能：    <a  href ="https://www.bilibili.com/video/av43996928">点击观看</a></p><h2 id="五、相关疑问"><a href="#五、相关疑问" class="headerlink" title="五、相关疑问"></a>五、相关疑问</h2></li><li>真的有这么容易实现吗？<br>&#8195;&#8195;答案：当然可以，我是用课余时间学习了一年就实现了，不过最好有一部分基础。（比如我之前有单片机的基础，但对于java、安卓、后台一点都不会，就更别说什么框架、Linux了）。</li><li>我该如何学习？<br>①. C语言、Java语言肯定要先学会。<br>②. 单片机开发的基础：用C语言开发。CC3200是一款 TI 公司集MCU和WIFI功能为一体的芯片，或者先学一款单片机，比如STM32（这个教程多），MSP430（TI公司，教程少）等。一通百通。<br>③. 安卓基础：这个是用Java语言开发的。<br>④. 服务和后台：后台代码也是用Java开发，学习Linux的基本操作。<h2 id="六、学习方法"><a href="#六、学习方法" class="headerlink" title="六、学习方法"></a>六、学习方法</h2></li><li>视频资料：如果对某一项技术没有任何了解，通过视频来学习最好不过了，可以选择可以倍速播放视频的软件。</li><li>文档资料：当你有了一定基础之后，看相关文档才是最快，最好用的资料。</li><li>资料推荐：哔哩哔哩、尚硅谷、w3cschool等等。<h2 id="七、专栏地址"><a href="#七、专栏地址" class="headerlink" title="七、专栏地址"></a>七、专栏地址</h2>&#8195;&#8195;<a  href ="https://blog.csdn.net/CSDN_X_W/column/info/33567">点击查看专栏</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cc3200 </tag>
            
            <tag> 云服务器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
