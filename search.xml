<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>npm基础必备</title>
      <link href="/2020/10/12/npm%E5%9F%BA%E7%A1%80%E5%BF%85%E5%A4%87/"/>
      <url>/2020/10/12/npm%E5%9F%BA%E7%A1%80%E5%BF%85%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p>Node Package Manage</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>是node.js的包管理工具，类似maven，负责管理js依赖。在安装node.js时就自动安装了npm</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>package.json    依赖包的配置信息以及工程的信息，可根据该文件下载依赖。</li><li>package-lock.json    锁定了包的版本。</li><li>node_modules    该文件夹下为下载的所有的包</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h5 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h5><ul><li>npm init    初始化一个npm应用（生成package.json）</li><li>npm init -y    初始化时全部采用默认配置</li></ul><h5 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h5><ul><li>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>     修改为淘宝镜像</li><li>npm config list    查看npm的配置信息</li></ul><h5 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h5><ul><li>npm install 包名@2.1.0     安装某个包(指定版本)</li><li>npm install    通过该路径下的package.json 配置文件下载依赖。</li><li>npm install —save-dev 包名    在当前项目中安装这个包</li><li>npm install -D 包名    上面命令的简写</li><li>npm install -g 包名    全局安装，所有项目可用</li></ul><h5 id="更新与卸载"><a href="#更新与卸载" class="headerlink" title="更新与卸载"></a>更新与卸载</h5><ul><li>npm update 包名    更新包（更新到最新版本）</li><li>npm update -g 包名    全局更新</li><li>npm uninstall 包名    卸载包</li><li>npm uninstall -g 包名    全局卸载</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack基础必备</title>
      <link href="/2020/10/08/webpack%E5%9F%BA%E7%A1%80%E5%BF%85%E5%A4%87/"/>
      <url>/2020/10/08/webpack%E5%9F%BA%E7%A1%80%E5%BF%85%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>前端静态文件的打包工具：</p><ol><li>功能：将多个静态文件（js,css）打包成一个文件。</li><li>使用场景：在部署前将项目打包</li><li>优点：防止用户多次请求静态资源界面。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>npm install -g webpack webpack-cli    安装webpack 和 webpack-cli</li><li>webpack -v     查看版本</li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul><li><p>在要打包的文件夹同级目录下创建webpack.config.js 文件，文件内容如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>); <span class="comment">//Node.js内置模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/main.js'</span>, <span class="comment">//配置入口文件</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'./dist'</span>), <span class="comment">//输出路径，__dirname：当前文件所在路径</span></span><br><span class="line">        filename: <span class="string">'bundle.js'</span> <span class="comment">//输出文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h2><ul><li>webpack    直接在配置文件所在目录执行该命令进行打包</li><li>webpack —mode=development    开发模式打包（打包后带有缩进）</li><li>webpack —mode=production    生产环境打包（打包后没有缩进）</li><li>注意事项：打包时.js后缀可以省略，.css后缀不能省略</li></ul><h2 id="安装loader插件"><a href="#安装loader插件" class="headerlink" title="安装loader插件"></a>安装loader插件</h2><ul><li><p>npm install —save-dev style-loader css-loader    安装 style-loader 和 css-loader</p><p>注：</p><ul><li>style-loader：让 javascript 认识css    </li><li>css-loader：   将 css 装载到 javascript</li></ul></li></ul><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&quot;path&quot;); &#x2F;&#x2F;Node.js内置模块</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#39;.&#x2F;src&#x2F;main.js&#39;, &#x2F;&#x2F;配置入口文件</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;), &#x2F;&#x2F;输出路径，__dirname：当前文件所在路径</span><br><span class="line">        filename: &#39;bundle.js&#39; &#x2F;&#x2F;输出文件</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [  </span><br><span class="line">            &#123;  </span><br><span class="line">                test: &#x2F;\.css$&#x2F;,    &#x2F;&#x2F;打包规则应用到以css结尾的文件上</span><br><span class="line">                use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</span><br><span class="line">            &#125;  </span><br><span class="line">        ]  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发编程</title>
      <link href="/2020/07/28/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/07/28/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h2><ol><li>高内聚低耦合，线程操作资源类</li><li>生产者、消费者：判断，干活，通知</li><li>多线程交互（wait notify时）中要防止多线程的<strong>虚假唤醒</strong> 。<strong>条件的判断不能用if，只能用while。</strong>while循环体在线程被终止的时候会被重新判断而if不会被重新判断，<strong>即wait必须在while的循环体内。</strong> </li><li>标志位</li></ol><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li><strong>synchronized</strong> 锁的不是某个方法，而是整个资源类，即当前的这个对象。</li><li>当 <strong>synchronized</strong>  标识的方法为static时，那么先执行的线程会锁住这个对象的类。该类的其他对象依然不能调用被synchronized标识的static方法。</li></ul><h2 id="一、JUC介绍"><a href="#一、JUC介绍" class="headerlink" title="一、JUC介绍"></a>一、JUC介绍</h2><p><strong>Java util concurrent</strong> ：Java的并发工具包，主要包含下面三部分。</p><ul><li>java.util.concurrent</li><li>java.util.concurrent.atomic</li><li>java.util.concurrent.locks</li></ul><p><strong>进程：</strong></p><p>是具有一定独立功能的程序，分配资源的基本单位，是操作系统动态执行的基本单元。</p><p><strong>线程：</strong></p><p>是独立运行和独立调度的基本单位，可以利用进程所拥有的资源。</p><h2 id="二、Lock接口"><a href="#二、Lock接口" class="headerlink" title="二、Lock接口"></a>二、Lock接口</h2><p><strong>高内聚低耦合，线程操作资源类</strong>。</p><p>​    由java.util.concurrent.locks提供，相较于 synchronized 可以只锁一部分资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketCount = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 可重用锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 下面抽成代码块 trylock</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                        <span class="string">"\t卖出第："</span> + (ticketCount--) +</span><br><span class="line">                        <span class="string">"\t还剩下："</span> + ticketCount); <span class="comment">// 打出当前进程的名字</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、线程间通信"><a href="#三、线程间通信" class="headerlink" title="三、线程间通信"></a>三、线程间通信</h2><p>​    生产者、消费者：<strong>判断，干活，通知</strong>。</p><p>​    多线程交互（wait notify时）中要防止多线程的<strong>虚假唤醒（）</strong> 。<strong>条件的判断不能用if，只能用while。while循环体在线程被终止的时候会被重新判断而if不会被重新判断。</strong> </p><ul><li><p>wait() 会交出资源的控制权</p></li><li><p>sleep()  不会交出资源的控制权，死死的等。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirConditioner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 判断</span></span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 干活</span></span><br><span class="line">        number ++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + number);</span><br><span class="line">        <span class="comment">// 3. 通知</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 判断</span></span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 干活</span></span><br><span class="line">        number --;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + number);</span><br><span class="line">        <span class="comment">// 3. 通知</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、生产者与消费者"><a href="#四、生产者与消费者" class="headerlink" title="四、生产者与消费者"></a>四、生产者与消费者</h2><p>​    采用新的写法，使用新版本的await 和 signalAll 来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirConditione</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number ++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(number == <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number --;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCustom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AirConditione airConditione = <span class="keyword">new</span> AirConditione();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                airConditione.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                airConditione.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                airConditione.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                airConditione.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、精准通知和顺序访问"><a href="#五、精准通知和顺序访问" class="headerlink" title="五、精准通知和顺序访问"></a>五、精准通知和顺序访问</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 精准通知和顺序访问</span></span><br><span class="line"><span class="comment"> * 多线程之间按照顺序调度，实现 A -&gt; B -&gt;C</span></span><br><span class="line"><span class="comment"> * A 打印5次后 B打印10次 C再打印15次</span></span><br><span class="line"><span class="comment"> * 上述过程打印10轮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">// 1 代表A  2 代表B   3代表C</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionA = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionB = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionC = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>)&#123;</span><br><span class="line">                conditionA.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 改标志</span></span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            conditionB.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>)&#123;</span><br><span class="line">                conditionB.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 改标志</span></span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            conditionC.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>)&#123;</span><br><span class="line">                conditionC.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 改标志</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            conditionA.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccurateNotification</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resource.print5();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resource.print10();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resource.print15();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、-八种锁的情况"><a href="#六、-八种锁的情况" class="headerlink" title="六、 八种锁的情况"></a>六、 八种锁的情况</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 标准访问，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">2 停4秒在短信方法内，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">3 普通的hello方法，是先打短信还是hello</span></span><br><span class="line"><span class="comment">4 现在有两部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">5 两个静态同步方法，1部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">6 两个静态同步方法，2部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">7 1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">8 1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>); <span class="comment">// 相当于 Thread.sleep(4000);</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"------发送Email----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------发送SMS----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------hello----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lock8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone1.sendEmail();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// phone1.sendSMS();</span></span><br><span class="line">                <span class="comment">// phone1.hello();</span></span><br><span class="line">                <span class="comment">// phone2.hello();</span></span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</p></li><li><p>加个普通方法后发现和同步锁无关换成两个对象后，不是同一把锁了，情况立刻变化。</p></li><li><p>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。</p><ul><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象</li></ul></li><li><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，<br>所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</p></li><li><p>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁（对象和类）是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p></li></ul><h2 id="七、-集合类不安全（ArrayList）"><a href="#七、-集合类不安全（ArrayList）" class="headerlink" title="七、 集合类不安全（ArrayList）"></a>七、 集合类不安全（ArrayList）</h2><ul><li><p>ArrayList  HashSet  HashMap    都是线程不安全的</p></li><li><p>会出现并发修改异常</p></li><li><p><strong>CopyOnWriteArrayList   同时满足写和读，做到线程安全、且性能好。写时复制，相当于读写分离的思想。</strong></p></li><li><p>CopyOnWriteArrayList 的 add 方法 底层源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>知识点：ArrayList扩容为原来的一半。</p></li></ul><h2 id="八、HashSet不安全"><a href="#八、HashSet不安全" class="headerlink" title="八、HashSet不安全"></a>八、HashSet不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetNotSecurity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;(); <span class="comment">// Collections.synchronizedMap(new HashSet&lt;&gt;()); // new HashSet&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>知识点：</strong></p><ul><li>HashSet的底层就是HashMap，new一个HashSet实际上就是new 了一个HashMap，HashSet的add方法调用的就是HashMap的put方法，此时键是add进去的值，value是一个固定不变的Object对象。</li></ul><h2 id="九、-HashMap不安全"><a href="#九、-HashMap不安全" class="headerlink" title="九、 HashMap不安全"></a>九、 HashMap不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapNotSecurity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(); <span class="comment">// Collections.synchronizedMap(new HashMap&lt;&gt;()); // new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>知识点：Map的底层是Node类型的数组+Node类型的链表（单向链表，hash冲突时出现（key不同但是hash相同，key相同时会进行值的替换），当单向链表大于8时，就变成了红黑树，为了快速查找）+红黑树。<ul><li>默认的初始大小为16，负载因子为0.75，一般只会改初始值（优化，避免频繁扩容）。（到12以后自动扩容，扩容一倍到32）</li><li>数组中存放的是一个Nod节点。将KV存放到Node中再放到数组里。</li></ul></li></ul><h2 id="十、Callable"><a href="#十、Callable" class="headerlink" title="十、Callable"></a>十、Callable</h2><h3 id="1-Java中实现多线程的几种方法"><a href="#1-Java中实现多线程的几种方法" class="headerlink" title="1. Java中实现多线程的几种方法"></a>1. Java中实现多线程的几种方法</h3><ul><li>继承Thread类，实现run方法</li><li>实现Runnable 接口，实现run方法</li><li>实现Callable \<T>接口，实现call方法 （有返回值、有异常、call方法）</T></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hahahaha"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get 方法一般放在最后一行来执行，等待主线程任务完成再去看其他线程的结果</span></span><br><span class="line"><span class="comment"> * 不然会出现，一直等待其他线程的情况</span></span><br><span class="line"><span class="comment"> * 不论多少个线程调用futureTask  该任务只会执行一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyThread());</span><br><span class="line">        <span class="comment">// 下面两个线程只会执行一次</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">"B"</span>).start();</span><br><span class="line">        System.out.println(futureTask.get()); <span class="comment">// 可以获得线程的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、-CountDownLatch"><a href="#十、-CountDownLatch" class="headerlink" title="十、 CountDownLatch"></a>十、 CountDownLatch</h2><p>等待所有的线程执行完，再执行主线程最后的部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"执行结束。"</span>);</span><br><span class="line">                countDownLatch.countDown(); <span class="comment">// 每次执行完，计数器减一</span></span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待countDownLatch 减到0的时候才能执行</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"主线程执行结束。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十一、CyclicBarrier-循环屏障"><a href="#十一、CyclicBarrier-循环屏障" class="headerlink" title="十一、CyclicBarrier(循环屏障)"></a>十一、CyclicBarrier(循环屏障)</h2><p>等到某些任务都执行完之后去执行另一个任务。（所有人到场了才开会的场景）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"开始开会"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"第"</span> + finalI + <span class="string">"个人来了"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二、Semaphore（信号量）"><a href="#十二、Semaphore（信号量）" class="headerlink" title="十二、Semaphore（信号量）"></a>十二、Semaphore（信号量）</h2><p>信号量主要用于多个共享资源的互斥使用（n个线程抢m个资源  n&gt;m） 或 控制多线程的并发数。</p><ul><li>acquire  当前线程调用acquire 操作时，它要么成功获取信号量，此时信号量会减一，要么一直等下去，直到有线程释放信号量，或超时。</li><li>release 实际上是将信号量的值加一，然后唤醒等待的线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>); <span class="comment">// 模拟资源类，有3个资源</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 占有一个资源  相当于 permits减一</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"抢到资源"</span>);</span><br><span class="line">                    <span class="keyword">try</span>&#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"释放了资源"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release(); <span class="comment">// 释放资源</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十三、ReadWriteLock"><a href="#十三、ReadWriteLock" class="headerlink" title="十三、ReadWriteLock"></a>十三、ReadWriteLock</h2><p>读-读可共享，写-读、写-写要独占。</p><ul><li><p>多个线程同时读一个资源类没有问题，所以为了满足并发量，读取共享资源应该可以同时进行。</p></li><li><p>但如果有一个线程想去写共享资源时，就不应该再有其他线程可以对资源进行读或写。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span></span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"写入数据"</span>);</span><br><span class="line">            <span class="comment">// 模拟网络延时</span></span><br><span class="line">            <span class="keyword">try</span>&#123; TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"写入完成"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"读取数据"</span>);</span><br><span class="line">            <span class="comment">// 模拟网络延时</span></span><br><span class="line">            <span class="keyword">try</span>&#123; TimeUnit.MILLISECONDS.sleep(<span class="number">150</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"读取完成"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(finalI + <span class="string">""</span>, finalI + <span class="string">""</span>); <span class="comment">// 5个线程同时写入数据</span></span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(finalI + <span class="string">""</span>); <span class="comment">// 5个线程同时写入数据</span></span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十四、BlockingQueue-阻塞队列"><a href="#十四、BlockingQueue-阻塞队列" class="headerlink" title="十四、BlockingQueue(阻塞队列)"></a>十四、BlockingQueue(阻塞队列)</h2><p>必须要阻塞和不得不阻塞的时候使用。</p><p>在多线程中，就是在有些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会被自动唤起。BlockingQueue帮我们完成了什么时候需要阻塞线程、什么时候需要唤醒线程。concurrent发布之前，这些需要自己实现。</p><ul><li>当队列是空的时候，从队列中获取元素的操作就会被阻塞，直到其他线程往空的队列中加入新的元素。</li><li>当队列是满的，向队列中添加元素的操作就会被阻塞，直到其他线程从队列中移除一个或多个元素。</li></ul><p><strong>ArrayBlockingQueue</strong>：由数组结构组成的有界阻塞队列</p><p><strong>LinkedBlockingQueue</strong>：由链表组成的有界（但大小默认为integer.MAX_VALUE）阻塞队列</p><p><strong>SynchronousQueue</strong>：不存储运输的阻塞队列，即单个元素的队列。</p><p><strong>LinkedBlockingdeque</strong>：由链表组成的双向阻塞队列。</p><p>四组方法：</p><div class="table-container"><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>查看</td><td>element()</td><td>peek()</td><td>—</td><td>—</td></tr></tbody></table></div><p>说明：</p><div class="table-container"><table><thead><tr><th>情况</th><th>情况说明</th></tr></thead><tbody><tr><td>抛出异常</td><td>当阻塞队列满时，再往队列里add插入元素会抛IllegalStateException:Queue full<br>当阻塞队列空时，再往队列里remove移除元素会抛NoSuchElementException</td></tr><tr><td>特殊值</td><td>插入方法，成功ture失败false移除方法，<br>成功返回出队列的元素，队列里没有就返回null</td></tr><tr><td>一直阻塞</td><td>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据or响应中断退出<br>当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用</td></tr><tr><td>超时退出</td><td>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>); <span class="comment">// 大小为3的队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*--第一组 add remove element--*/</span></span><br><span class="line">        <span class="comment">/*// 因为是数组，因此可以add相同的值</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.add("a"));</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.add("b"));</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.add("c"));</span></span><br><span class="line"><span class="comment">        // System.out.println(blockingQueue.add("d")); // 异常</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">        System.out.println("当前队列的头：" + blockingQueue.element());</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">        // System.out.println(blockingQueue.remove()); // 异常*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*--第二组 offer poll peek--*/</span></span><br><span class="line">        <span class="comment">/*System.out.println(blockingQueue.offer("a"));</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.offer("b"));</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.offer("c"));</span></span><br><span class="line"><span class="comment">        // System.out.println(blockingQueue.offer("d")); // false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">        System.out.println("当前队列的头：" + blockingQueue.peek());</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">        // System.out.println(blockingQueue.poll()); // null*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*--第三组 put take--*/</span></span><br><span class="line">        <span class="comment">/*blockingQueue.put("a");</span></span><br><span class="line"><span class="comment">        blockingQueue.put("b");</span></span><br><span class="line"><span class="comment">        blockingQueue.put("c");</span></span><br><span class="line"><span class="comment">        // blockingQueue.put("d"); // 阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">        // System.out.println(blockingQueue.take()); // 阻塞*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*--第四组 put take--*/</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"b"</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"c"</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// 超时不候</span></span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll(<span class="number">3</span>,TimeUnit.SECONDS)); <span class="comment">// 超时不候</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十五、ThreadPool（线程池）"><a href="#十五、ThreadPool（线程池）" class="headerlink" title="十五、ThreadPool（线程池）"></a>十五、ThreadPool（线程池）</h2><p>线程池控制线程的数量，处理过程中将任务放入队列，然后在线程创建之后启这些任务，如果线程数量超出了最大数量，超出数量的线程排队等候，等待其他线程执行完毕，再从队列中取出任务来执行。线程是稀缺资源，如果无限制的创建，不仅仅会消耗系统资源，还会降低系统稳定性，用线程池可以进行统一的分配、调优和监控。</p><p>主要特点：线程复用、控制最大并发量、管理线程。</p><p>Executors：线程池工具类</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/juc/ThreadPool.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newFixedThreadPool(5); // 一个线程池中有5线程</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newSingleThreadPool(); // 一个线程池中有一个线程</span></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool(); <span class="comment">// 一个线程池有N个线程  自动根据任务增加或者减少线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 创建执行任务</span></span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">"办理业务"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown(); <span class="comment">// 销毁线程池</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-底层源码"><a href="#1-底层源码" class="headerlink" title="1. 底层源码"></a>1. 底层源码</h3><p>实际上上述三种方法调用的是同一个方法，返回了一个ThreadPoolExecutor对象。</p><ul><li><p>Executors.newFixedThreadPool(nThreads)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Executors.newSingleThreadExecutor()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Executors.newCachedThreadPool()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-线程池的7个参数"><a href="#2-线程池的7个参数" class="headerlink" title="2. 线程池的7个参数"></a>2. 线程池的7个参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize：线程池的常驻线程数</li><li>maximumPoolSize：线程池能够容纳同时执行的最大线程数，&gt;=1</li><li>keepAliveTime：多余空闲线程的存活时间，当数量超过corePoolSize时，空闲时间超过改值，那么超过corePoolSize数量的线程会被销毁。</li><li>unit：keepAliveTime的单位</li><li>workQueue：阻塞任务队列BlockingQueue，被提交但没有执行的任务</li><li>threadFactory：用于创建线程的线程工厂，默认</li><li>handler：拒绝策略，当队列中的任务满了并且工作线程大于等于线程池的最大线程数时，如何拒绝请求执行的runnable的策略。</li></ul><h3 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3. 执行流程"></a>3. 执行流程</h3><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/juc/ThreadPoolExecutor.png" alt></p><h3 id="4-实际使用（重要）"><a href="#4-实际使用（重要）" class="headerlink" title="4. 实际使用（重要）"></a>4. 实际使用（重要）</h3><p><strong>实际中不使用Executors去创建</strong>，而是通过ThreadPoolExcutor去创建，避免资源被耗尽。</p><ul><li>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会造成堆积大量请求，导致OOM（out of memory）。</li><li>CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，导致OOM。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该线程池能够承受的最大任务数为 ：5 + 3 = 8</span></span><br><span class="line">ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">       <span class="number">2</span>, <span class="comment">// 线程池的常驻线程数</span></span><br><span class="line">                <span class="number">5</span>, <span class="comment">// 线程池能够容纳同时执行的最大线程数</span></span><br><span class="line">                <span class="number">3L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>), <span class="comment">// 阻塞队列的大小，默认为int.MAX_VALUE</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 使用默认的工厂</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()); <span class="comment">// AbortPolicy拒绝策略（默认）——超出报拒绝执行异常，总共四种</span></span><br></pre></td></tr></table></figure><h3 id="5-四种拒绝策略"><a href="#5-四种拒绝策略" class="headerlink" title="5. 四种拒绝策略"></a>5. 四种拒绝策略</h3><ul><li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</li><li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不<br>会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中<br>尝试再次提交当前任务。</li><li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。<br>如果允许任务丢失，这是最好的一种策略。</li></ul><h3 id="6-最大线程数配置方式（重要）"><a href="#6-最大线程数配置方式（重要）" class="headerlink" title="6.  最大线程数配置方式（重要）"></a>6.  最大线程数配置方式（重要）</h3><ul><li>CPU密集型任务<ul><li>maximumPoolSize 大小为 电脑的CPU核数加一（<strong>不允许写死</strong>），<strong>通过 <code>Runtime.getRuntime().availableProcessors();</code>来获得核数。</strong> </li></ul></li><li>IO 密集型任务：<ul><li>maximumPoolSize = CPU的核数 / CPU的阻塞系数。</li></ul></li></ul><h2 id="十六、链式编程-流式计算"><a href="#十六、链式编程-流式计算" class="headerlink" title="十六、链式编程 + 流式计算"></a>十六、链式编程 + 流式计算</h2><p>java中的@Accessors(chain = true) 标识允许以链式的方式书写代码。</p><p>JDK中常用的函数式接口：(只要是函数式接口就可以写成 lambda 表达式的形式。)</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/juc/functionInterface.png" alt></p><h3 id="1-Stream-流"><a href="#1-Stream-流" class="headerlink" title="1. Stream 流"></a>1. Stream 流</h3><p>有了 Stream 基础后，数据库的相应排序、筛选等操作即可通过流的方式直接在后台处理数据，只需要通过数据库获得原始数据即可，提高数据库性能。</p><h4 id="①-简介："><a href="#①-简介：" class="headerlink" title="① 简介："></a>① 简介：</h4><p>Stream 是数据渠道，用于操作数据源（集合和数组等）所生成的元素序列，<strong>集合讲的是数据，流讲的是计算</strong>。</p><h4 id="②-特点"><a href="#②-特点" class="headerlink" title="② 特点"></a>② 特点</h4><ul><li>Stream 不会存储元素</li><li>Stream 不会改变源对象，会返回一个持有结果的新的Stream</li><li>Stream 操作是延迟进行的，这意味着他们会等到需要结果的时候才执行。</li></ul><h4 id="③-使用"><a href="#③-使用" class="headerlink" title="③ 使用"></a>③ 使用</h4><ul><li>创建：创建一个Stream：一个数据源（数组、集合）</li><li>中间操作：一个中间操作，处理数据源数据</li><li>终止操作：一个终止操作，执行中间操作链，产生结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String  userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>     age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-02-26 22:24</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目：请按照给出数据，找出同时满足</span></span><br><span class="line"><span class="comment"> *      偶数ID且年龄大于24</span></span><br><span class="line"><span class="comment"> *    用户名转为大写且用户名字母倒排序</span></span><br><span class="line"><span class="comment"> *      最后只输出一个用户名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">11</span>,<span class="string">"a"</span>,<span class="number">23</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">12</span>,<span class="string">"b"</span>,<span class="number">24</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">13</span>,<span class="string">"c"</span>,<span class="number">22</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">14</span>,<span class="string">"d"</span>,<span class="number">28</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">16</span>,<span class="string">"e"</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1,u2,u3,u4,u5);</span><br><span class="line"></span><br><span class="line">        list.stream().filter(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getId() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;).filter(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getAge() &gt; <span class="number">24</span>;</span><br><span class="line">        &#125;).map(f -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> f.getUserName().toUpperCase();</span><br><span class="line">        &#125;).sorted((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        &#125;).limit(<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//    R apply(T t);</span></span><br><span class="line">        Function&lt;String,Integer&gt; function = t -&gt; &#123;<span class="keyword">return</span> t.length();&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">"abc"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// boolean test(T t);</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = t -&gt; &#123;<span class="keyword">return</span> t.startsWith(<span class="string">"a"</span>);&#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void accept(T t);</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = t -&gt; &#123;System.out.println(t);&#125;;</span><br><span class="line">        consumer.accept(<span class="string">"java1018"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//    T get();</span></span><br><span class="line">        Supplier&lt;String&gt; supplier =  () -&gt; &#123;<span class="keyword">return</span> UUID.randomUUID().toString();&#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十七、ForkJoin（分支合并）"><a href="#十七、ForkJoin（分支合并）" class="headerlink" title="十七、ForkJoin（分支合并）"></a>十七、ForkJoin（分支合并）</h2><p>将多个复杂任务拆解为多个任务，即fork的过程，多个线程同时计算，计算完以后再将结果合并，即jion的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拆分计算0-100</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer ADJUST_VALUE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((end - begin)&lt;=ADJUST_VALUE)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =begin;i &lt;= end;i++)&#123;</span><br><span class="line">                result = result + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (begin + end)/<span class="number">2</span>;</span><br><span class="line">            MyTask task01 = <span class="keyword">new</span> MyTask(begin,middle);</span><br><span class="line">            MyTask task02 = <span class="keyword">new</span> MyTask(middle+<span class="number">1</span>,end);</span><br><span class="line">            task01.fork();</span><br><span class="line">            task02.fork();</span><br><span class="line">            result =  task01.join() + task02.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分支合并例子</span></span><br><span class="line"><span class="comment"> * ForkJoinPool</span></span><br><span class="line"><span class="comment"> * ForkJoinTask</span></span><br><span class="line"><span class="comment"> * RecursiveTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);</span><br><span class="line"></span><br><span class="line">        System.out.println(forkJoinTask.get());</span><br><span class="line"></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十八、异步回调"><a href="#十八、异步回调" class="headerlink" title="十八、异步回调"></a>十八、异步回调</h2><p>像Axios的异步访问一样，启用异步任务后，执行完会进入异步回调函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//同步，异步，异步回调</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步</span></span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Void&gt; completableFuture1 = CompletableFuture.runAsync(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(Thread.currentThread().getName()+"\t completableFuture1");</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"><span class="comment">//        completableFuture1.get();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步回调</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t completableFuture2"</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        completableFuture2.whenComplete((t,u)-&gt;&#123;</span><br><span class="line">            <span class="comment">// 当任务完成时进入</span></span><br><span class="line">            System.out.println(<span class="string">"-------t="</span>+t);</span><br><span class="line">            System.out.println(<span class="string">"-------u="</span>+u);</span><br><span class="line">        &#125;).exceptionally(f-&gt;&#123;</span><br><span class="line">            <span class="comment">// 当任务出现异常时进入</span></span><br><span class="line">            System.out.println(<span class="string">"-----exception:"</span>+f.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">444</span>;</span><br><span class="line">        &#125;).get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI 基础（ML与DL）</title>
      <link href="/2020/06/13/AI%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/06/13/AI%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><strong>实际上处于弱人工智能范畴</strong> </p><p>数据结构：</p><ol><li>树形的深度优先搜索</li><li>广度优先搜索</li><li>排序</li><li>动态规划<ul><li>最长公共子序列</li><li><strong>字符串的最长公共子串</strong> </li></ul></li><li>递归：<ul><li>二叉树的翻转</li></ul></li></ol><p>书籍推荐：模式识别与机器学习、统计学习方法。</p><h2 id="一、机器学习基础"><a href="#一、机器学习基础" class="headerlink" title="一、机器学习基础"></a>一、机器学习基础</h2><h3 id="1-按学习方式分类"><a href="#1-按学习方式分类" class="headerlink" title="1. 按学习方式分类"></a>1. 按学习方式分类</h3><ul><li>监督学习：带着标签去学习，告诉它这个是什么，那个是什么。</li><li>无监督学习（以聚类为代表）</li><li>半监督学习</li><li>强化学习</li></ul><h3 id="2-学习结构分类"><a href="#2-学习结构分类" class="headerlink" title="2. 学习结构分类"></a>2. 学习结构分类</h3><ul><li>回归</li><li>分类</li></ul><p>​    注：主流的学习技术是监督学习，半监督学习和强化学习在通用场景下效果不是太好。</p><h3 id="3-基本概念"><a href="#3-基本概念" class="headerlink" title="3. 基本概念"></a>3. 基本概念</h3><ul><li>训练集：用来训练模型，得到模型的数据集</li><li>测试集：用来测试所得到的模型的效果的数据集，从训练数据中取出（自助法和交叉验证法）</li><li>目标函数：用来评价是否能达到某种要求的函数，如线性回归中，要求到直线距离的平方和的函数。</li><li>损失函数：对函数模型的复杂程度的惩罚函数，越简单越好</li><li>优化方法：一阶、二阶优化，梯度下降等</li><li>拟合、欠拟合与过拟合：没有学到大部分东西和学到了过多噪声部分的东西，所以需要人来调参，使之到达一定效果</li><li>准确率：在测试集中的准确率</li><li>泛化性能：实际应用时的预测性能</li></ul><h2 id="二、机器学习的模型"><a href="#二、机器学习的模型" class="headerlink" title="二、机器学习的模型"></a>二、机器学习的模型</h2><h3 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1. 线性回归"></a>1. 线性回归</h3><ol><li><p>简介：</p><p>线性回归是最基础的回归算法。</p></li><li><p>数学模型：</p><p>y=a*x + b</p></li><li><p>目标函数：</p><p>到直线距离的平方和的函数，对该函数求极值，达到一定的要求。目标函数的极值求解方法-&gt;随机梯度下降：每次对一小批数据进行梯度更新,采用不同的步长。</p></li><li><p>准确度评估：连续数据通过方差评估，离散数据通过accuracy、precision、recall等几种评估。</p></li><li><p>用途：</p><p><strong>可以用来做回归和分类。</strong></p></li><li><p>特点：</p><p>模型简单，计算量小，对误差敏感，对数据的预处理要求较高。</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/AIbase/tensorflowAI01.jpg" alt></p></li></ol><h4 id="Logistic回归模型"><a href="#Logistic回归模型" class="headerlink" title="Logistic回归模型"></a>Logistic回归模型</h4><ol><li><p>简介：</p><p>与线性回归类似，在线性回归的基础上根据与分界线的距离给每个点加了权重，把区分的重点转移到分界线的附近，越远点，权重越小。</p></li><li><p>ont-hot编码：</p><p>需要对所有的区间段进行编码，只有0和1，即是和否，即大于分界线我就干什么，小于分界线就干什么。</p></li><li><p>用途：</p><p><strong>可以用来做回归和分类。</strong></p></li></ol><h3 id="2-决策树"><a href="#2-决策树" class="headerlink" title="2. 决策树"></a>2. 决策树</h3><p>简介：</p><p>决策树能用来做回归，也能用来做分类，是一类算法的总称。是对数据进行分类的树形模型，可以是二叉树和非二叉树，内部结点（绿色）表示一个特征或者属性，叶子（黄色）表示一个结果类，在回归任务中，以叶子结点的值代表输出值。</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/AIbase/tensorflowAI02.jpg" alt></p><p>信息熵：</p><p>表征了信息不确定的程度，分类属性应当以最高熵减为标准进行。</p><p>信息熵：$S=-p(x)lnp(x)$ </p><h4 id="常用决策树算法"><a href="#常用决策树算法" class="headerlink" title="常用决策树算法"></a>常用决策树算法</h4><ol><li><p>ID3：</p><ul><li><p>选择属性</p></li><li><p>分裂出三个结点，选择其他属性继续划分</p></li><li><p>直到新节点的类别均一致或特征全部用尽为止。<strong>但这样并不好，会学进来噪音，因此往往会限制树高。</strong></p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/AIbase/tensorflowAI03.jpg" alt></p></li></ul></li><li><p>C4.5：采用信息增益率，解决了ID３中当以物品ID为首选属性时，泛化性能差的缺陷。</p></li></ol><h5 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林:"></a>随机森林:</h5><p>随机树属于弱分类器的bagging策略，随机森林是<strong>强分类器</strong>，通过</p><ul><li>bootstrap采样</li><li>随机选择特征，选择最佳属性建立决策树</li><li>形成随机森林，通过投票获得结果</li></ul><p>考虑利用已有信息，每棵树都在之前的结果上拟合残差，使用一阶导得到GBDT，使用二阶导得到xgboost</p><ol><li>GBDT（）</li><li>XGboost（）</li></ol><p><strong>总结</strong></p><ul><li>决策树是一类具有可解释性，泛化性能较好的模型。</li><li>精度高，无需特征归一化，能处理缺失值共线性特征</li><li>适合低维度稠密数据，不适合高纬度稀疏数据</li><li>决策树类算法兼具特征选择能力</li><li>常用于金融、推荐</li></ul><h3 id="3-朴素贝叶斯"><a href="#3-朴素贝叶斯" class="headerlink" title="3. 朴素贝叶斯"></a>3. 朴素贝叶斯</h3><p>简介：是<strong>最基本的文本分类模型</strong>。马尔科夫假设约束较强，该模型能力有限。是基于<strong>词袋</strong>的方式，因此没有词之间顺序的信息，但很简单。</p><p><strong>自然语言处理</strong></p><p>切词是自然语言处理中最基础最重要的工作，切词是否准确直接影响文本处理的精度。解决切词的办法：<strong>语言模型、深度学习。</strong></p><h4 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h4><p>以垃圾邮件和非垃圾邮件为例：但由于有些词的概率为1或者0，因此需要拉普拉斯平滑。</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/AIbase/tensorflowAI04.jpg" alt></p><h2 id="三、深度学习"><a href="#三、深度学习" class="headerlink" title="三、深度学习"></a>三、深度学习</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><h3 id="2-框架"><a href="#2-框架" class="headerlink" title="2. 框架"></a>2. 框架</h3><h4 id="TensorFlow（张量流）"><a href="#TensorFlow（张量流）" class="headerlink" title="TensorFlow（张量流）"></a>TensorFlow（张量流）</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/AIbase/tensorflowAI05.png" alt></p><h3 id="3-前馈神经网络（BP网络）"><a href="#3-前馈神经网络（BP网络）" class="headerlink" title="3. 前馈神经网络（BP网络）"></a>3. 前馈神经网络（BP网络）</h3><p>每一个⚪是一个神经元，每一个神经元都有一个输出权重，相当于本层与线上的权重矩阵相乘，得到下一层结果，</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/AIbase/tensorflowAI06.jpg" alt></p><p>BP：反向传播，用来求解神经网络中权重矩阵W的参数，通过测试数据得到结果与预期结果的损失来更新矩阵的参数。</p><ol><li>数据量要够，不能欠拟合</li><li>只能学习到与学习内容相关的知识</li><li>梯度下降的方法求极值。</li></ol><h3 id="4-卷积神经网络（CNN）"><a href="#4-卷积神经网络（CNN）" class="headerlink" title="4. 卷积神经网络（CNN）"></a>4. 卷积神经网络（CNN）</h3><h4 id="词向量："><a href="#词向量：" class="headerlink" title="词向量："></a>词向量：</h4><p>具有相同或类似上下文信息的词，应该具有相同的语义，语义相近的词的之间欧式距离小</p><h4 id="语义插入（word-embedding）"><a href="#语义插入（word-embedding）" class="headerlink" title="语义插入（word embedding）"></a>语义插入（word embedding）</h4><p>将one-hot编码的词量压缩到256维或者更小，每一维都认为表达了<strong>某一方面的语义</strong>，这样就解决了语义相似和维度灾难的问题，本质上是<strong>无监督学习</strong>。</p><h4 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/AIbase/tensorflowAI07.jpg" alt></p><h4 id="词向量应用"><a href="#词向量应用" class="headerlink" title="词向量应用"></a>词向量应用</h4><ol><li>语言学：类比任务(syn、sem)，相似度计算(ws)、同义词(tfl)</li><li>作为任务特征：情感分析(avg)、命名实体识别(NER)</li><li>作为某个任务神经网络模型的初始值：情感分析(cnn)、词性标注(pos)</li></ol><h3 id="5-循环神经网络（RNN-重要）"><a href="#5-循环神经网络（RNN-重要）" class="headerlink" title="5. 循环神经网络（RNN-重要）"></a>5. 循环神经网络（RNN-重要）</h3><p>CNN没有记忆功能，而RNN具有记忆功能</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/AIbase/tensorflowAI08.jpg" alt></p><h4 id="lstm-long-short-time-memory"><a href="#lstm-long-short-time-memory" class="headerlink" title="lstm(long short-time memory)"></a>lstm(long short-time memory)</h4><h5 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h5><p>lstm是一种特殊的RNN，如下图，单层的lstm只有一个lstm单元，<strong>展开是虚拟的，每一个时间步参数是共享的</strong>。不像RNN，lstm有两个隐状态。</p><p>lstm内部有三个门，输入们、输出门、遗忘门，不断更新优化参数，在上下文语义中，决定了什么样的词要忘记，什么样的词要记住。</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/AIbase/tensorflowAI09.jpg" alt></p><h5 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h5><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/AIbase/tensorflowAI10.jpg" alt></p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul><li>encoder-decoder结构：<ul><li>文本：机器翻译、<strong>文档总结</strong>、对话系统</li><li>图像：图像描述、视觉回答、视觉对话</li></ul></li></ul><h5 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h5><p>一般对结果抽取top3  top100等，根据自己所需的数据量。</p><ol><li>为文章配图</li><li>对已有歌曲及评论进行情感分析，分析后，为新的歌曲刷评论。新的电影也如此</li><li>对商品的评论进行过滤</li></ol><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity权限框架（OAuth2）</title>
      <link href="/2020/05/03/Spring-Security%E6%9D%83%E9%99%90%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/05/03/Spring-Security%E6%9D%83%E9%99%90%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>​    Spring的安全框架，主要包含两个部分，包括用户认证和用户授权。<strong>本质</strong>上就是<strong>Filter</strong>（过滤器），对请求进行过滤，</p><ul><li>基于session：则通过对cookie里的sessionid进行解析，然后在服务器中查询确认，</li><li>基于token：解析token，然后加到Spring-security中管理</li></ul><h3 id="1-用户认证"><a href="#1-用户认证" class="headerlink" title="1. 用户认证"></a>1. 用户认证</h3><p>用户的登录认证，用来判断用户是否能访问这个系统。</p><h3 id="2-用户授权"><a href="#2-用户授权" class="headerlink" title="2. 用户授权"></a>2. 用户授权</h3><p>对不同的用户角色，分配不同的权限</p><h2 id="二、-认证与授权的流程"><a href="#二、-认证与授权的流程" class="headerlink" title="二、 认证与授权的流程"></a>二、 认证与授权的流程</h2><p>用户通过用户名和密码登录以后，就拥有该用户的权限，系统以用户名为key，权限为value存入到Redis中，根据用户名等信息生成token（生成协议采用JWT），返回给前端，前端将该token存储在cookie中，每次调用接口时都会将该token放到Header（请求头）中，用于认证，SpringSecurity对Header中的token进行解析，获取用户信息，通过查询Redis获取用户权限，从而<strong>决定</strong>该用户是否有访问某些请求（接口）的权限，所有的接口权限交给了SpringSecurity来管理了。</p><h2 id="三、-RBAC"><a href="#三、-RBAC" class="headerlink" title="三、 RBAC"></a>三、 RBAC</h2><ul><li><p>基于角色的访问控制</p><p>RBAC（Role-Based Access Control），是按照角色进行授权。</p></li><li><p>基于资源的访问控制（更灵活）</p><p>RBAC（Resource-Based Access Control）,是按照资源进行授权。</p></li></ul><h2 id="四、工作原理"><a href="#四、工作原理" class="headerlink" title="四、工作原理"></a>四、工作原理</h2><p>​    Spring Security底层同样采用Filter过滤器，不过是多个Filter过滤器，通过FilterChainProxy代理来产生多个Filter，从而实现认证和授权。</p><p>​    而需要我们干预的就是通过实现UserDetailsService接口来通过数据库查询信息，比对密码</p><h3 id="1-密编码器"><a href="#1-密编码器" class="headerlink" title="1. 密编码器"></a>1. 密编码器</h3><ul><li><p>NoOpPasswordEncoder：表示不加密，直接比对（不用）</p></li><li><p>BCryptPasswordEncoder：常用的密码加密方式，通过随机加盐存储。</p><p>在配置文件中注入了以后，会自动的通过用户输入的与加密后的进行比较。</p></li></ul><h3 id="2-授权流程"><a href="#2-授权流程" class="headerlink" title="2. 授权流程"></a>2. 授权流程</h3><p>​    参考文档的图的流程，一般不需要改写，只需要根据认证过程中从数据库获取权限信息，在配置中，通过方法授权。</p><h3 id="3-授权码模式"><a href="#3-授权码模式" class="headerlink" title="3. 授权码模式"></a>3. 授权码模式</h3><p>​    安全级别最高的模式，也是微信第三方登录的模式。先认证，然后颁发授权码，拿授权码获取令牌，再通过令牌去访问资源。</p><h3 id="4-密码模式"><a href="#4-密码模式" class="headerlink" title="4. 密码模式"></a>4. 密码模式</h3><p>​    很简单的模式，会泄露密码给客户端，因此要求这个客户端是我们自己开发的APP或单页应用。流程如下：</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/SpringSecurity/SpringSecurity01.png" alt></p><h3 id="5-客户端模式"><a href="#5-客户端模式" class="headerlink" title="5. 客户端模式"></a>5. 客户端模式</h3><p>​    只使用用户名和密码就可以获取令牌了。内部系统使用。</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/SpringSecurity/SpringSecurity02.png" alt></p><h2 id="五、深入理解"><a href="#五、深入理解" class="headerlink" title="五、深入理解"></a>五、深入理解</h2><ul><li>前后端分离，采用密码模式</li><li>Oauth2包含了授权服务和资源服务</li><li>用户登录时前端携带用户名、密码、app_id，app_security</li><li>app_id，app_security是用来区分APP的，每个APP发一个，我自己的网站也是这个认证系统的一个APP（应用）</li><li>不使用授权码模式是因为前后端分离对于授权码模式不友好，需要跳转页面。</li></ul><h2 id="六、注册中心"><a href="#六、注册中心" class="headerlink" title="六、注册中心"></a>六、注册中心</h2><p>​    注册中心保存服务的地址，微服务把各自的地址上报上去。</p><h2 id="七、-网关"><a href="#七、-网关" class="headerlink" title="七、 网关"></a>七、 网关</h2><p>认证服务生成JWT令牌，所有的请求在网关层进行验证，判断权限，将API网关作为Oauth2的资源服务角色，实现接入客户端权限拦截，对令牌解析获得用户信息并转发到微服务，这样下游微服务就不需要关心令牌格式和Oauth2的相关机制了。</p><ul><li><strong>注意：</strong> 网关对资源访问服务进行了配置，所以资源那里就不需要配置了，待确认。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth2</title>
      <link href="/2020/04/28/OAuth2/"/>
      <url>/2020/04/28/OAuth2/</url>
      
        <content type="html"><![CDATA[<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>官方网站：<a href="https://oauth.net/" target="_blank" rel="noopener">https://oauth.net/</a></p><p>中文文档：</p><ul><li><a href="https://vertxchina.github.io/vertx-translation-chinese/auth/Oauth2.html" target="_blank" rel="noopener">https://vertxchina.github.io/vertx-translation-chinese/auth/Oauth2.html</a></li><li><a href="https://colobu.com/2017/04/28/oauth2-rfc6749/" target="_blank" rel="noopener">https://colobu.com/2017/04/28/oauth2-rfc6749/</a></li></ul><p>腾讯开放平台：<a href="https://wiki.open.qq.com/wiki/mobile/OAuth2.0开发文档" target="_blank" rel="noopener">https://wiki.open.qq.com/wiki/mobile/OAuth2.0开发文档</a></p><h2 id="一、解决的问题"><a href="#一、解决的问题" class="headerlink" title="一、解决的问题"></a>一、解决的问题</h2><h3 id="1-开放系统间授权"><a href="#1-开放系统间授权" class="headerlink" title="1. 开放系统间授权"></a>1. 开放系统间授权</h3><p><strong>原理：</strong>用户给其他系统授权来访问另外一个系统。</p><p><strong>举例：</strong>我有一个云盘，存储着我的照片，我给一个打印服务系统授权访问我的云盘来打印照片。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>给第三方系统颁发令牌，可对令牌的权限、有效期、等进行管理，而这个令牌所使用的框架就是OAuth2。</p><h3 id="2-分布式访问（单点登录）"><a href="#2-分布式访问（单点登录）" class="headerlink" title="2. 分布式访问（单点登录）"></a>2. 分布式访问（单点登录）</h3><p>按照一定规则生成一个字符串（令牌），但是OAuth2只是解决方案，没有指定生成字符串的规则，而之前使用的 JWT 就是一种生成这个字符串的规则。</p><h2 id="二、注意"><a href="#二、注意" class="headerlink" title="二、注意"></a>二、注意</h2><ul><li>OAuth2不支持HTTP以外的协议</li><li>OAuth2不是一个认证协议</li><li>没有定义授权处理机制</li><li>没有定义token格式</li><li>没有定义加密方法</li><li>不是一个单个的协议</li><li><strong>OAuth2是一个授权框架，仅提供授权代理，只是一种解决方案。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> OAuth2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2020/04/02/Redis/"/>
      <url>/2020/04/02/Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="主要学的三个数据库"><a href="#主要学的三个数据库" class="headerlink" title="主要学的三个数据库"></a>主要学的三个数据库</h2><ul><li><strong>MySQL</strong>(关系型) 多用于冷数据</li><li>MongoDB(介于关系型与非关系型之间)  基于分布式文件存储的数据库</li><li><strong>Redis</strong>(非关系型数据库)  多用于常改变，类型多样的数据。分布式 <strong>内存</strong> 数据库</li></ul><h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><h3 id="NoSQL简介："><a href="#NoSQL简介：" class="headerlink" title="NoSQL简介："></a>NoSQL简介：</h3><p>泛指 <strong>非关系型数据库</strong> ，为了解决大规模数据集合多重数据种类，包括大规模数据存储。<strong>这些类型的数据存储不需要固定的模式，无需多余的操作就可以横向扩展。</strong> </p><h3 id="NoSQL特点："><a href="#NoSQL特点：" class="headerlink" title="NoSQL特点："></a>NoSQL特点：</h3><ol><li>易扩展：去掉关系型数据库的关系型特性，数据之间无关系，因此非常容易扩展。</li><li>大数据量高性能：</li><li>多样灵活的数据类型：键值对形式存储。</li></ol><h3 id="关系型与非关系型数据库对比："><a href="#关系型与非关系型数据库对比：" class="headerlink" title="关系型与非关系型数据库对比："></a>关系型与非关系型数据库对比：</h3><ol><li>RDBMS（Relational Database Management System）：<ul><li>高度组织化结构化数据</li><li>结构化查询语句</li><li>数据和关系都存储在单独的表中</li><li>数据操纵语言，数据定义语言</li><li>严格一致性</li></ul></li><li>NoSQL<ul><li>不仅仅是SQL</li><li>没有声名性查询语言</li><li>没有预定义模式</li><li><strong>键值对的存储，列存储、文档存储、图形数据库</strong> </li><li>最终一致性，非ACID属性</li><li>非结构化和不可预知的数据</li><li>CAP定理</li><li>高性能、高可用性和可伸缩性</li></ul></li></ol><h3 id="NoSQL实质："><a href="#NoSQL实质：" class="headerlink" title="NoSQL实质："></a>NoSQL实质：</h3><p>KV(键值对) + Cache(缓存) + Persistence(持久性)</p><h3 id="3V-3高："><a href="#3V-3高：" class="headerlink" title="3V 3高："></a>3V 3高：</h3><ol><li><strong>3V :</strong> <ul><li>Volume(海量)</li><li>Variety(多样)</li><li>Velocity(实时)</li></ul></li><li><strong>3高：</strong><ul><li>高并发</li><li><strong>高可扩</strong>（横向扩展）</li><li>高性能</li></ul></li></ol><h3 id="NoSQL的数据模型（聚合模型）："><a href="#NoSQL的数据模型（聚合模型）：" class="headerlink" title="NoSQL的数据模型（聚合模型）："></a>NoSQL的数据模型（聚合模型）：</h3><ul><li>KV键值 ：Redis</li><li>Bson（Binary Json）：MongoDB</li><li>列族：Hbase</li><li>图形：不是去放图形的，是存放关系，如社交网络，广告推荐，用于构建关系图谱。暂时用的少。</li></ul><h3 id="数据库的CAP-BASE"><a href="#数据库的CAP-BASE" class="headerlink" title="数据库的CAP+BASE"></a>数据库的CAP+BASE</h3><ol><li><p>传统：ACID（分别查一下什么意思）</p></li><li><p>NoSQL：CAP （Consistency Availability Partition tolerance）强一致性+可用性+分区容错性</p><p><strong>注意：</strong> <strong>CAP只能三选二，最多只能较好的满足两个，但是P又是必须满足的，如今网站多为AP</strong> </p></li><li><p>BASE：（Basically Available  Soft state  Eventually consistent）基本可用+ 软状态 + 最终一致。</p></li><li><p>分布式+集群：</p><ul><li>分布式：多态服务器上部署不同的服务模块，它们之间进行Rcp/Rmi之间通讯和调用，对外提供服务和组内协作。</li><li>集群：多台服务器上部署相同的服务模块，通过分布式软件调度对外提供服务和访问，即实现负载均衡。</li></ul></li></ol><h2 id="二、Redis"><a href="#二、Redis" class="headerlink" title="二、Redis"></a>二、Redis</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>​    <strong>REmote DIctionary Server（远程字典服务）</strong> </p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>​    <strong>开源、免费</strong>、C编写、遵守BSD协议。<strong>高性能KV分布式存储数据库</strong>，支持<strong>数据持久化、还支持list、set、hash等，支持数据备份，单线程工作 。分布式的内存数据库。</strong> </p><h3 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h3><p>​    数据<strong>持久化</strong>、获取最新<strong>N个数据</strong>、<strong>模拟HttpSession</strong>这种需要设置过期时间的功能、发布订阅消息系统、<strong>定时器、计数器</strong>。</p><h2 id="三、基础知识"><a href="#三、基础知识" class="headerlink" title="三、基础知识"></a>三、基础知识</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><ol><li>测试redis在本机上的性能：<ul><li>docker exec -it 容器ID bash       进入到redis容器实例</li><li>cd /usr/local/bin/    ls -l    查看安装的redis</li><li>redis-benchmark       执行redis-benchmark 对redis进行测试</li></ul></li><li>默认redis创建16个数据库（0~15）通过 </li><li>select n   来选择数据库</li><li>client list    查看当前连接的客户端</li><li>dbsize    查看数据的key-value对的个数</li><li>set key xxx      在当前库添加一个数据（<strong>会对已有数据进行覆盖</strong>）</li><li>setnx key xxx      当key不存在时才添加数据（<strong>避免覆盖</strong>）set if not exist</li><li>mset k1 v1 k2 v2     一次添加多个数据</li><li>get key     查询key</li><li>mget k1 k2 k3    一次get多个值</li><li>keys *     查看所有的key   可以通过keys k?  来筛选数据  符合k?的会被查出来</li><li>flushdb    清除当前库</li><li>flushall     清除所有库</li><li>exists key名字    判断key是否存在</li><li>move key db    将当前键值对移到新的库（db为0~15）当前库就没有了</li><li>expire key 秒钟    为当前数据设置有效期</li><li>ttl key    查看数据还有多久过期 -1 表示永不过期   -2 表示已经过期（就会从中删除）</li><li>type key    查看key的类型</li><li>del key      删除key</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><a href="http://www.redis.cn/topics/data-types.html" target="_blank" rel="noopener">官方文档</a></p><h4 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1. 字符串"></a>1. 字符串</h4><ul><li>append k1 xxx      在k1对应的value字符串后追加xxx</li><li>strlen key       得到key的长度</li><li>incr key      key的值加一（数字才能加减）</li><li>incrby key 3   key的值加3（其他同理）</li><li>decr key    减少key的值</li><li>setrang key 3 xxx    从第三个值开始设置为xxx 后面不变</li><li>getrang key 0 3      获取key的第0到第3位置的字符</li><li>setex key 秒数 value    设置key的有效时间 （set with expire）</li></ul><h4 id="2-List"><a href="#2-List" class="headerlink" title="2.List"></a>2.List</h4><ul><li>lpush list a b c d e      添加list列表，left push   在原有的基础上的左面开始添加 （先进后出）</li><li>rpush list 1 2 3 4 5     添加list列表，right push   在原有的基础上的右面面开始添加（先进先出）</li><li>lrang list 0 -1      从左到右遍历列表到结束</li><li>lpop list    从左面删除y一个</li><li>rpop list      从右面删除一个</li><li>lindex list n      获取下标为n的那个数据</li><li>lrem list n m      在list列表中删除n 个 value为m的数据</li><li>ltrim key 开始的index 结束的index      截取key的指定范围值后再付给key</li><li>rpoplpush 源列表  目标列表       将源列表的右边那个移除一个再将其从左边加到目标列表</li><li>lset key index value    设置指定下标元素的值</li><li>linsert key before/after 值1 值2     再值1 前面或者后面添加一个元素</li></ul><h4 id="3-set"><a href="#3-set" class="headerlink" title="3.set"></a>3.set</h4><ul><li><h4 id="4-Hash"><a href="#4-Hash" class="headerlink" title="4.Hash"></a>4.Hash</h4></li><li></li></ul><h4 id="5-Zset"><a href="#5-Zset" class="headerlink" title="5. Zset"></a>5. Zset</h4><ul><li><h2 id="四、配置文件-重要"><a href="#四、配置文件-重要" class="headerlink" title="四、配置文件(重要)"></a>四、配置文件(重要)</h2></li></ul><h4 id="文件位置"><a href="#文件位置" class="headerlink" title="文件位置"></a>文件位置</h4><ol><li>初始的配置文件要备份一份</li><li>文件位置：/usr/local/etc/redis/redis.conf  参考docker安装redis中内容</li></ol><h4 id="Units单位"><a href="#Units单位" class="headerlink" title="Units单位"></a>Units单位</h4><ol><li>1k   -&gt;   1000</li><li>1kb  -&gt;  1024</li></ol><p>m mb g gb 以此类推（不支持bit,大小写不敏感）</p><h4 id="INCLUDE"><a href="#INCLUDE" class="headerlink" title="INCLUDE"></a>INCLUDE</h4><p>​    redis.conf  作为总的配置文件，里面可以包含其他的配置文件</p><h4 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h4><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><ol><li><strong>默认是不开密码的</strong></li><li>设置密码（在进入到redis-cli之后才可以）<ul><li>config get requirepass       查询获取当前密码</li><li>config set requirepass “123456”     将redis的密码设置为123456</li></ul></li><li>auth 123456     进入redis之后，在执行命令之前需要通过此方式输入密码来验证</li></ol><p>注“：通过config get dir 命令也可以获取到运行redis的目录，因此日志相关内容也在这个目录下</p><h4 id="LIMIT限制"><a href="#LIMIT限制" class="headerlink" title="LIMIT限制"></a>LIMIT限制</h4><ol><li>Maxclients    最大的可连接客户端数量（默认10000）</li><li>Maxmemory    最大内存</li><li><p>Maxmemory-policy     缓存的过期策略  六种过期策略。</p><ul><li>Volatile-lru  使用LRU（最近最少使用）算法移除key,只对设置了过期时间的key</li><li>Allkeys-lru  使用LRU（最近最少使用）算法移除key</li><li>Volatile-random   在过期集合中移除随机的key,只对设置了过期时间的键</li><li>Allkeys-random    移除随机的key</li><li>Volatile-ttl    移除ttl最小的key，即那些快过期的key</li><li>Noeviction     不进行移除，针对写操作会返回错误信息，永不过期（<strong>默认永不过期 基本不用该方式</strong>）</li></ul></li><li>Maxmemory-samples    LRU算法和TTL算法的样本数量   默认5个</li></ol><h4 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h4><p>参考Redis常用配置文件</p><h2 id="五、持久化"><a href="#五、持久化" class="headerlink" title="五、持久化"></a>五、持久化</h2><h4 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1. RDB"></a>1. RDB</h4><ol><li><p><strong>RDB</strong>：（Redis DataBase ）在指定的时间间隔内将内存中的数据集快照写入磁盘（Snapshot快照），恢复时是将快照文件读到内存里。Redis会单独创建（fork）一个子进程来进行持久化，将数据写入到一个临时的文件中，待持久化结束以后，在将这个临时文件替换上一次持久化好的文件。过程中主进程不进行IO操作，来确保极高的性能（<strong>最大化redis性能</strong>）。<strong>试用于需要进行大规模数据恢复，且对数据完整性不是很敏感的情况（最后一次持久化后的数据可能丢失）。</strong> </p></li><li><p><strong>Fork：</strong> 用来复制一个与当前进程一样的进程，新进程的所有数据都和当前的进程一致，是一个全新的进程，并作为原进程的子进程。</p></li><li><p>save m n：bgsave自动触发的条件；如果没有save m n配置，相当于自动的RDB持久化关闭，不过此时仍可以通过其他方式(命令方式)触发</p></li><li><p>默认备份方式</p><p>​    备份文件默认保存为dump.rdb</p><ul><li>一分钟改了一万次</li><li>五分钟改了十次</li><li>十五分钟改了一次</li></ul></li><li><p>save   执行后马上对数据进行备份，阻塞状态，备份时前台没办法写数据</p></li><li><p>bgsave   执行后马上对数据进行备份，后台进行，前台还可以写数据</p></li><li><p>主机和备份的机器使用两台，写个脚本将本地的保存数据更新到另一台机器上</p></li><li><p><strong>恢复数据：</strong>  将备份文件dump.rdb放到redis对应的存放备份文件的目录，<strong>通过config get dir获取路径</strong> ，当dump文件出现问题时，可以参考aof里面修复的方式来修复dump文件。</p></li><li><p>试用场景：</p><ul><li>试用于大规模数据恢复</li><li>对数据的完整性要求不高的情况</li></ul></li><li><p>缺点：</p><ul><li>由于是隔一段时间备份一次，如果宕掉，则最后一次快照的数据会丢失</li><li>Fork时内存数据会克隆一份，因此会有两倍的膨胀性需要考虑</li></ul></li></ol><h4 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2. AOF(Append Only File)"></a>2. AOF(Append Only File)</h4><ol><li>简介：<strong>以日志的形式记录每个写操作</strong>，只允许追加文件，不允许改写文件，redis启动之初会读取该文件并重新构建数据（根据日志内容，将写指令从前到后执行一遍，完成数据恢复）。</li><li><p>文件路径</p><ul><li>文件名：appendonly.aof</li><li>路径：<strong>通过config get dir获取路径</strong> </li></ul></li><li>记录所有的写文件操作，当然也包括shutdown（如果执行，则文件的最后也会保存这个命令）,虽然实际不可能使用shutdown。</li><li><strong>当rdb和aof同时存在时，先找AOF，再找dump文件。</strong></li><li><strong>redis-check-aof —fix appendonly.aof</strong>    当因为断电、延时、丢包等原因，导致aof文件的最后出现乱码，可以通过此命令<strong>修复</strong>。redis-check-aof 会把所有不符合其语法规范的命令统统删掉。</li><li><p><strong>配置策略：</strong> </p><ul><li>appendonly no       <strong>默认是不开的</strong>，但是不知道为什么我的配置文件是只开启了aof,可能是因为没有按照配置文件启动。</li><li>Appendfsync    <ul><li>Always：同步持久化，有数据变更就更新，性能很差，数据完整性很好</li><li>Everysec：<strong>默认设置</strong>，异步操作每秒设置一次，如果一秒内宕机，则数据有丢失。</li><li>No  </li></ul></li></ul></li><li><p><strong>Rewrite</strong> </p><ul><li>简介：AOF采用的是文件追加的方式，文件会越来越大，因此增加了重写机制，当AOF文件大小超过所设定的阈值，Redis 会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。</li></ul></li></ol><ul><li>指令：bgrewriteaof<ul><li>重写原理：持续增长过大时，会fork出一条新进程来将文件重写，（先写临时文件，最后再rename）<strong>类似于快照：不是重写原有的aof文件，而是将将整个内存的数据用命令方式重新写了一个新的aof文件。</strong></li><li>重写的触发机制： redis会记录上一次重写时文件大小，默认配置是当aof文件是上次rewrite后的一倍，且文件大于64M时触发。（<strong>真正的大公司这里起步是3G，可以通过这个来看公司的业务情况和技术</strong>） </li></ul></li></ul><ol><li>缺点：aof文件要远大于rdb文件，恢复速度慢于rdb。AOF每秒同步策略较好，运行效率慢于RDB。</li></ol><h4 id="3-持久化选择"><a href="#3-持久化选择" class="headerlink" title="3.持久化选择"></a>3.持久化选择</h4><ul><li>因为RDB文件只做后备用途，因此建议只在Slave上持久化RDB文件，15分钟备份一次就够了。 save 900 1</li><li>开启AOF的好处是最恶劣的情况下也只会丢失不到2秒的数据，代价是带来了持续的IO，Rewrite过程（<strong>将数据写到新文件，此时会产生系统波动</strong>）中造成的<strong>阻塞</strong>是不可避免的，因此只要硬盘许可，尽量<strong>减少AOF Rewrite的频率</strong>，所以将AOF重写的基础大小设置的大一些，比如5GB，然后超过原本100%大小时重写，可以适当更改。</li><li>不开启AOF，仅靠Master-Slave Replication 实现高可用性，可以省掉一大笔IO，也减少了rewrite时的系统波动，但是Master和Slave如果同时宕掉，会丢失十几分钟的数据，<strong>启动时需要根据Master和Slave中较新的文件来恢复数据</strong>。</li></ul><h2 id="六、Redis事务"><a href="#六、Redis事务" class="headerlink" title="六、Redis事务"></a>六、Redis事务</h2><p> 简介：可以一次执行多个命令，本质是一组命令的集合，事务中所有的命令都会序列化，不加赛。2.2版本以上支持CAS（Check And Set）。</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ol><li>MULTI      开启一个事务块  最后一个字母是大写 i</li><li>EXEX     执行事务块内的所有命令</li><li>DISACRD    取消事务（放弃事务块内的所有命令）</li><li>WATCH key [key …]       监视一个或者多个key，在事务执行之前，如果被监视的key被改动，则事务将被打断。</li><li>UNWATCH    取消对<strong>所有</strong>key的监视</li></ol><p><strong>注：</strong> </p><ul><li>执行的命令中如果有一个有问题（加入命令时就报错，相当于编译报错），则全部命令都不能执行</li><li>如果哪个命令在执行时才会报错，则其他命令不受影响的继续执行</li></ul><h3 id="WATCH监控（乐观锁）"><a href="#WATCH监控（乐观锁）" class="headerlink" title="WATCH监控（乐观锁）"></a>WATCH监控（乐观锁）</h3><h4 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1.相关概念"></a>1.相关概念</h4><ul><li>乐观锁：相当于锁一行数据，更新时会判断在此期间有没有人更新这个数据（比如版本号机制：加一个version字段，改完version加一）</li><li>悲观锁：相当于锁表（基本不用）</li></ul><h4 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h4><ul><li>一旦执行了unwatch,则exec之前加的监控锁都会被取消。</li></ul><h2 id="七、消息订阅发布"><a href="#七、消息订阅发布" class="headerlink" title="七、消息订阅发布"></a>七、消息订阅发布</h2><p>很少用，消息订阅功能。</p><h2 id="八、主从复制（读写分离）"><a href="#八、主从复制（读写分离）" class="headerlink" title="八、主从复制（读写分离）"></a>八、主从复制（读写分离）</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>主机数据更新后，根据配置和策略，自动同步到备机的master/slaver机制，<strong>Master以写为主，Slaver以读为主。</strong> </p><h3 id="用途：-1"><a href="#用途：-1" class="headerlink" title="用途："></a>用途：</h3><ul><li><strong>读写分离（只有主机可以写数据，而从机是不能执行写操作的）</strong> </li><li><strong>容灾恢复</strong></li></ul><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><ol><li>配从不配主</li><li>从库的配置方式：  <strong>slaveof 主库的IP 主库的端口</strong> <ul><li>每次与master（主机）断开连接以后，都需要重新连接，除非配置到redis.conf文件中</li><li><strong>info replication</strong>    可以查看当前的redis是主机还是从机，与之对应的从机，连接状态等信息。</li></ul></li><li>不同的机器需要配置的地方<ul><li>拷贝多个配置文件到不同机器并根据需要命不同的名字</li><li>更改相应的pid文件的名字</li><li>可以全部采用默认端口（或者在配置文件中将端口也改掉）</li><li>log文件名也可进行对应的修改</li><li>dump.rdb  和 appendonly.aof文件也可进行对应的修改</li></ul></li><li>常用方式：<strong>一台主机两台备用机</strong>  </li><li>通过上述的方式将某一个redis配置成从机后，<strong>所有的数据（包括在配置成从机之前主机的数据）都会备份到从机</strong>。</li></ol><h3 id="一主二从："><a href="#一主二从：" class="headerlink" title="一主二从："></a>一主二从：</h3><p>简介：一个默认为主机，其他的两个配置为从机</p><h4 id="1-主机停掉（故障）"><a href="#1-主机停掉（故障）" class="headerlink" title="1. 主机停掉（故障）"></a>1. 主机停掉（故障）</h4><ul><li><p>从机处于原地待命的状态，并不会变为主机，数据也不会丢失。</p></li><li><p>当主机重新启动后原有关系依然维持。</p></li></ul><h4 id="2-从机故障"><a href="#2-从机故障" class="headerlink" title="2. 从机故障"></a>2. 从机故障</h4><ul><li>原有的其他从机不受影响</li><li>重新启动挂掉的从机后，它就会变成主机模式（配置文件没有配置的情况下），需要重新将其设置为从机。</li></ul><h3 id="去中心化："><a href="#去中心化：" class="headerlink" title="去中心化："></a>去中心化：</h3><p>简介：Slave1也可以作为下一个Slave2的Master，<strong>Slave1可以接受其他Slave2的连接和同步的请求</strong>，那么这个Slave1作为链条中的下一个Master可以有效减轻Master的写压力（往从机写数据的压力）。</p><h4 id="1-配置方式"><a href="#1-配置方式" class="headerlink" title="1. 配置方式"></a>1. 配置方式</h4><p>将1设为主机，将2设置为1的从机，将3设置为2的从机。</p><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul><li>后面的所有从机都对主机进行了备份，因此数据是依次向后备份传递的</li><li>第二个机器（中间那个）的角色是<strong>从机</strong> ，虽然它下面还连了一个从机。</li></ul><h3 id="从机变主机："><a href="#从机变主机：" class="headerlink" title="从机变主机："></a>从机变主机：</h3><h4 id="1-一主二从模式下"><a href="#1-一主二从模式下" class="headerlink" title="1. 一主二从模式下"></a>1. 一主二从模式下</h4><ul><li>主机挂掉以后</li><li>slaveof no one 在从机中执行该命令，将从机变主机，<strong>当前数据库停止与其他数据库的同步</strong> </li><li>而后需要将另外一个从机重新设置为当前新主机的从机（因为他还处于待命状态，等待原有主机启动）。</li></ul><h4 id="2-去中心化方式下"><a href="#2-去中心化方式下" class="headerlink" title="2. 去中心化方式下"></a>2. 去中心化方式下</h4><h3 id="从机变主机-自动版-重要"><a href="#从机变主机-自动版-重要" class="headerlink" title="从机变主机(自动版-重要)"></a>从机变主机(自动版-重要)</h3><h4 id="1-简介："><a href="#1-简介：" class="headerlink" title="1. 简介："></a>1. 简介：</h4><p>也叫哨兵模式（Sentinel Mode），从后台监控主机是否出现故障，如果出现故障，则根据投票数来自动的将从库转变为主库。</p><h4 id="2-配置使用（一主二从下）"><a href="#2-配置使用（一主二从下）" class="headerlink" title="2. 配置使用（一主二从下）"></a>2. 配置使用（一主二从下）</h4><ul><li><p>添加 sentinel.conf 文件（文件的名字固定，最后一个字母为小写L）</p></li><li><p>添加内容到文件：sentinel monitor 被监控的数据库名(自己起一个) IP 端口 1</p><p>注：数据库名和IP、端口 都是被监控的<strong>主机</strong>的    1 表示主机挂掉后通过投票方式选从机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">sentinel monitor host 118.25.50.73 6379 1</span><br></pre></td></tr></table></figure></li><li><p>redis-sentinel /xuwei/myredis/conf/sentinel.conf     启动redis哨兵对主机进行监控。</p></li><li>注：文件中可以写多行，来监控多个Master</li><li>主机挂后，两个从机会自成一套体系（一主一从），<strong>当原主机再次启动时，就会变成新主机的从机。</strong> </li></ul><h4 id="3-疑问"><a href="#3-疑问" class="headerlink" title="3. 疑问"></a>3. 疑问</h4><ul><li>哨兵程序是在主机下运行的嘛？如果主机直接强制被关机了怎么办？是否可以在另一台机器上运行。还是说这个方式仅仅是为了防止数据库出现异常而停止服务。</li><li>当主机出现问题以后，另一台机器变成了主机，那么后台如何据此来改变访问的端口？后台是否可以配置备用的端口。</li><li>通过修改端口启动多个 sentinel ，此时是</li><li>更多参考：<a href="https://www.jianshu.com/p/231afa35d937" target="_blank" rel="noopener">Redis Sentinel</a> </li></ul><h3 id="复制原理："><a href="#复制原理：" class="headerlink" title="复制原理："></a>复制原理：</h3><h4 id="1-相关概念-1"><a href="#1-相关概念-1" class="headerlink" title="1.相关概念"></a>1.相关概念</h4><ul><li>全量复制：slave收到数据文件以后，将其加载到内存  （首次或重新连接时）</li><li>增量复制：Master将新的修改命令依次发给slave，完成同步。</li></ul><ol><li>slave成功连接到master以后会发送一个sync(sychronise)命令</li><li>Master收到sync以后，会启动后台的存盘进程，收集所有收到的用于修改数据集的命令，执行完以后，将整个数据文件传送到slave,完成一次同步。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux应用开发-后端</title>
      <link href="/2020/03/03/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-%E5%90%8E%E7%AB%AF/"/>
      <url>/2020/03/03/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-%E5%90%8E%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux（林纳斯）"><a href="#Linux（林纳斯）" class="headerlink" title="Linux（林纳斯）"></a>Linux（林纳斯）</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-主要的应用领域"><a href="#1-主要的应用领域" class="headerlink" title="1. 主要的应用领域"></a>1. 主要的应用领域</h3><ul><li><p><strong>服务器</strong></p><p>Linux生来就是被设计作为服务器的，众多服务程序均部署在Linux上。</p></li><li><p><strong>嵌入式系统</strong></p><p>Linux完全开源，可对内核进行裁剪，最小可打到几百kb，常应用于嵌入式系统，如机顶盒、白家电等。安卓的内核也是Linux。</p></li></ul><h3 id="2-学习阶段"><a href="#2-学习阶段" class="headerlink" title="2. 学习阶段"></a>2. 学习阶段</h3><ul><li><strong>① 基本的操作命令</strong>：文件命令、编辑工具、linux用户管理</li><li><strong>② 各种配置</strong>：环境变量、网络配置、服务配置</li><li><strong>③ 搭建开发环境</strong>：如Java、python等的运行环境</li><li><strong>④ shell脚本：</strong> 能对Linux进行维护，编写脚本文件。</li><li><strong>⑤ 安全设置：</strong> 防止攻击、系统调优。</li><li><strong>⑥ Linux内核：</strong> 熟练掌握大型网站应用架构的组成，熟练各个环节的部署和维护方法。</li></ul><h2 id="二、-Linux基础"><a href="#二、-Linux基础" class="headerlink" title="二、 Linux基础"></a>二、 Linux基础</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><h4 id="①-特点"><a href="#①-特点" class="headerlink" title="① 特点"></a>① 特点</h4><ul><li>免费、开源</li><li>安全、高效、稳定（基本半年不用重启）</li><li>处理高并发强悍（高并发场景）</li><li>企业级项目的部署</li></ul><h4 id="②-吉祥物"><a href="#②-吉祥物" class="headerlink" title="② 吉祥物"></a>② 吉祥物</h4><p>吉祥物：Tux（企鹅）</p><h4 id="③-发行版本"><a href="#③-发行版本" class="headerlink" title="③ 发行版本"></a>③ 发行版本</h4><p>Linux只是一个内核，在内核的基础上添加应用软件得到发行版本。<strong>国内常用Ubuntu 和 CentOS</strong> （CentOS属于redhat的免费版）</p><h4 id="④-Unix"><a href="#④-Unix" class="headerlink" title="④ Unix"></a>④ Unix</h4><p>Linux由Unix演化而来。</p><p><strong>Ken tompson</strong></p><ul><li>用B语言开发了Unix</li></ul><p><strong>Dennis richres</strong> </p><ul><li>与Ken tompson 设计C语言，重写Unix</li></ul><p><strong>Linus</strong></p><ul><li>顺应GUN计划，在Unix基础上开发出Linux</li></ul><h2 id="三、目录结构"><a href="#三、目录结构" class="headerlink" title="三、目录结构"></a>三、目录结构</h2><p><strong>在linux中，一切皆文件</strong></p><p>Linux会把所有的东西映射成一个文件来处理，如外接硬盘、cpu、应用程序、内存等。</p><h2 id="四、vi-vim常用命令"><a href="#四、vi-vim常用命令" class="headerlink" title="四、vi vim常用命令"></a>四、vi vim常用命令</h2><p>参考：<a href="https://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">菜鸟教程vi vim</a></p><ul><li>yy    复制当前行</li><li>p    粘贴</li><li>(n)yy    复制n行</li><li>G    回到文件末尾</li><li>gg    回到文件开头</li><li>:set nu    设置行号</li><li>:set noun    取消行号</li><li>n shift+g    去第n行</li></ul><h2 id="五、开关机、重启与注销"><a href="#五、开关机、重启与注销" class="headerlink" title="五、开关机、重启与注销"></a>五、开关机、重启与注销</h2><ul><li>sync    同步内存数据到磁盘（<strong>关机前执行</strong>）</li><li>shutdwn<ul><li>shutdown -h now    立即关机</li><li>shutdown -h 1    一分钟后关机</li><li>shutdown -r now    立即重启</li></ul></li><li>halt    关机</li><li><p>reboot    重启系统</p></li><li><p>logout    关闭当前用户的连接</p></li></ul><h2 id="六、用户管理"><a href="#六、用户管理" class="headerlink" title="六、用户管理"></a>六、用户管理</h2><p>linux是一个多用户多任务的操作系统，想使用系统资源的用户需向管理员root申请一个账号，用来登录系统</p><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li><strong>用户</strong>：linux系统的用户，可以有多个，root为管理员用户</li><li><strong>用户组</strong>：每个用户可以被分配到一个或多个用户组（创建时指定或后期更换）</li><li><strong>家目录</strong>：/home  每创建一个用户都会在home目录下分配一个子目录作为该用户的家目录，登陆后会进入该目录。</li></ul><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><ul><li><p>pwd    查看当前所在的目录</p></li><li><p>useradd [选项] 用户名    添加一个用户</p><p>未指定用户组时会自动创建一个与用户同名的组，并将该用户添加到该用户组中。</p><p><code>user add -g 用户组名 用户名</code>    添加到</p></li><li><p>passwd 用户名    为用户指定密码</p></li><li><p>userdel 用户名    删除用户（root用户来操作，用户家目录会保留）</p></li><li><p>userde -rl 用户名    删除用户（家目录也会被删掉，<strong>不推荐</strong>）</p></li><li><p>id 用户名    查询用户信息（id和所在组）</p><p>uid-&gt;用户id    gid-&gt;用户组id    groups-&gt;用户组</p></li><li><p>su - 用户名    切换用户</p></li><li><p>exit    切换到上一个用户</p></li></ul><h3 id="3-用户组"><a href="#3-用户组" class="headerlink" title="3. 用户组"></a>3. 用户组</h3><p>​    用户组用于对相同类别的用户进行统一管理，这些用户具有一些共性（如可以访问的文件的权限相同）。</p><h4 id="①-用户组命令"><a href="#①-用户组命令" class="headerlink" title="① 用户组命令"></a>① 用户组命令</h4><ul><li>groupadd 用户组名    添加用户组</li><li>groupdel 用户组名    删除组</li><li>usermod -g 用户组 用户名    将用户修改到别的用户组</li><li>groups    查看当前登录用户组内的所有成员</li><li>cat /etc/group    查看系统的用户组</li><li>group 组名    查看该组内的所有成员</li></ul><h4 id="②-相关文件"><a href="#②-相关文件" class="headerlink" title="② 相关文件"></a>② 相关文件</h4><ul><li><p>/etc/passwd</p><p>保存用户信息的配置文件</p><p>详细内容：用户名：用户口令（加密）：用户id：组id：：家目录：shell解释器</p></li><li><p>/etc/group</p><p>保存用户组信息的配置文件</p><p>详细内容：组名：组口令（加密）：组id</p></li><li><p>/etc/shadow</p><p>口令的配置文件，包含用户的密码和登录信息。</p><p>详细内容：用户名和密码等加密内容。</p></li></ul><h2 id="七-运行级别"><a href="#七-运行级别" class="headerlink" title="七. 运行级别"></a>七. 运行级别</h2><p>​    系统运行级别德指定，包含七个运行级别，配置文件在/etc/inittab的id:5:initdefault这一行的数字，常用的运行级别是3和5。</p><p><strong>运行级别的指定命令</strong>：<code>init [0123456]</code> </p><ul><li>0：关机</li><li>1：单用户【找回丢失密码】</li><li>2：多用户状态没有网络服务</li><li><strong>3：多用户状态有网络服务（命令行界面）</strong> </li><li>4：系统未使用，保留给用户</li><li>5：图形界面</li><li>6： 系统重启</li></ul><h2 id="八、root密码找回-（实体机）"><a href="#八、root密码找回-（实体机）" class="headerlink" title="八、root密码找回 （实体机）"></a>八、root密码找回 （实体机）</h2><p>进入到单用户模式，这时会以root身份登录系统，这时就可以更改root密码。</p><ul><li>开机引导时按：回车键 进入到引导开机前的界面</li><li>输入e在booting之前编辑命令</li><li>选择kernel 再按e</li><li>输入空格1， 回车，告诉内核进入到单用户模式</li><li>再输入b,启动boot</li><li>passwd root    更改用户密码</li></ul><h2 id="九、-实用命令"><a href="#九、-实用命令" class="headerlink" title="九、 实用命令"></a>九、 实用命令</h2><h4 id="0-必知指令"><a href="#0-必知指令" class="headerlink" title="0. 必知指令"></a>0. 必知指令</h4><ul><li>ln    软连接（link）<ul><li>ln -s 源文件路径/名 软连接名    创建一个软连接，指向某个源文件或路径(之后便可直接对该软连接操作，如cd more等)</li><li>rm -rf 软连接名    直接删除该软连接（是一个目录时）</li></ul></li><li>history    查看历史执行过的指令<ul><li>history n    显示最近执行过的n个指令</li><li>!n    执行history中的第n条指令</li></ul></li></ul><h4 id="1-帮助指令"><a href="#1-帮助指令" class="headerlink" title="1. 帮助指令"></a>1. 帮助指令</h4><ul><li>man [命令或配置文件]    获取功能描述或帮助信息</li><li>help 命令    获得shell内置命令的帮助信息</li></ul><h4 id="2-文件目录类"><a href="#2-文件目录类" class="headerlink" title="2. 文件目录类"></a>2. 文件目录类</h4><ul><li><p>pwd    显示当前工作目录的绝对路径</p></li><li><p>ls 【选项】 【目录或者文件】    显示当前目录的信息</p><ul><li>-a    所有文件</li><li>-l    以列表的方式显示信息</li></ul></li><li><p>cd 【参数】    切换到指定目录</p><ul><li>cd ~    切换到自己的家目录</li></ul></li><li><p>mkdir    创建一个目录</p><p>make -p   /xxx/yyy    创建多级目录</p></li><li><p>rm [选项] 目录    删除指定文件或目录</p><ul><li>-r    递归删除整个文件夹</li><li>-f    强制删除不提示（不提示是否删除？）</li></ul><p>rm -rf 目录    删除非空的目录</p></li><li><p>touch 文件名    创建一个空文件（可以多个 空格分开）</p></li><li><p>cp 【-r】source dest    将某个文件（文件夹下的所有内容）拷贝到dest路径</p><p>-r：表示遍历</p><p>\cp :表示复制时强制覆盖同名文件。</p></li><li><p>mv 旧文件名 新文件名    重命名文件</p></li><li><p>mv 源文件名（或目录） 新目录    将文件移动到新的目录（剪切）</p></li><li><p>cat 文件名    以只读的方式查看文件内容</p><ul><li>-n    查看内容的同时显示行号</li><li>cat 文件名 | more    分页查看文件内容</li></ul></li><li><p>more 文件名    以全屏方式显示文件内容（<strong>适合查看小文件</strong>）</p><ul><li>空格：向下翻页</li><li>回车：向下翻一行</li><li>Ctrl+F：向下滚动一屏</li><li>Ctrl+B：向上滚动一屏</li><li>=：显示行号</li><li>:f ：输出文件名和当前行号</li><li>q：立即离开</li></ul></li><li><p>less 文件名   部分加载的方式，分屏查看文件（<strong>适合查看大文件</strong>）</p><ul><li>空格：向下翻页</li><li>pagedown：向下翻页</li><li>pageup：向上翻页</li><li>/字符串：向下查找字符串</li><li>?字符串：向上搜索字符串</li><li>q：退出</li></ul></li><li><p>echo：   输出内容到控制台</p><ul><li>echo $PATH    输出当前的环境变量</li></ul></li><li><p>head    用于显示文件的前n行（默认10行）</p><ul><li>head -n 20 文件名    显示该文件的前20行</li></ul></li><li><p>tail    用于查看文件的后10行</p><ul><li>tail -n 20 文件名    查看文件的后20行内容</li><li>tail -f 文件名    实时监控文件的内容变化（<strong>重要：常用日志查看</strong>）</li></ul></li><li><p>>：   输出重定向</p><ul><li>ls -l &gt; 文件名    列表内容写到文件中（覆盖写）</li><li>cat 文件1 &gt; 文件2    将文件1（可带路径）的内容写到文件2（可带路径）</li><li>echo “内容” &gt; 文件名    将内容写到文件中</li></ul></li><li><p>>> ：   追加</p><ul><li>ls -l &gt;&gt; 文件名    列表的内容追加到文件的末尾</li><li>echo “内容” &gt;&gt; 文件名    将内容追加到文件中</li></ul></li></ul><h4 id="3-时间日期类"><a href="#3-时间日期类" class="headerlink" title="3. 时间日期类"></a>3. 时间日期类</h4><ul><li><p>date     显示当前的时间日期（<strong>有格式的时候，加号必须有</strong>）</p><ul><li>date “+%Y-%m-%d”    显示年月日 用 - 连接    结果：2020-11-07</li><li>date “+%Y年%m月%d日 %H:%M:%S”    结果：2020年11月07日 12:20:23</li></ul></li><li><p>date -s “2020-11-07 12:20:20”    设置系统时间</p></li><li>cal    以日历的方式显示当前时间<ul><li>cal 2020    显示2020年的日历</li></ul></li></ul><h4 id="4-搜索查找类"><a href="#4-搜索查找类" class="headerlink" title="4. 搜索查找类"></a>4. 搜索查找类</h4><h5 id="①-find"><a href="#①-find" class="headerlink" title="① find"></a>① find</h5><ul><li>find 某目录 -name 文件名    按名称查询某个目录下是否有该文件<ul><li>find / -name *.txt    查询根目录下所有的txt文件</li></ul></li><li>find 某目录 -size +20M    查询某个目录下大于20M的文件（<strong>查找包、日志等大文件使用很方便</strong>）<ul><li>-20k    查询小于多少k的文件</li></ul></li></ul><h5 id="②-locate"><a href="#②-locate" class="headerlink" title="② locate"></a>② locate</h5><p>​    运行前要执行<code>updatedb</code>创建locate数据库</p><ul><li>locate 文件名    查询该文件所在目录</li></ul><h5 id="⑤-grep"><a href="#⑤-grep" class="headerlink" title="⑤ grep"></a>⑤ grep</h5><ul><li>“|”   管道符号，表示将前一个命令的处理结果交给后面的命令处理。</li><li>grep 【选项】 查找内容或源文件<ul><li>-n    显示匹配行和行号</li><li>-i    忽略字母的大小写</li><li>eg：cat test.txt | grep -ni aaa    不区分大小写查询test.txt中的aaa，并显示行号</li><li>eg：ls -l /home |grep “^-“ | wc -l    统计/home目录下的文件的个数</li></ul></li></ul><h4 id="5-压缩与解压"><a href="#5-压缩与解压" class="headerlink" title="5. 压缩与解压"></a>5. 压缩与解压</h4><h5 id="①-zip-unzip"><a href="#①-zip-unzip" class="headerlink" title="① zip/unzip"></a>① zip/unzip</h5><ul><li>zip -r 压缩文件名 压缩目录    对目录内的文件递归压缩<ul><li>zip -r package.zip /root/    将root目录下的所有文件打包为package.zip</li></ul></li><li>unzip -d /home/ package.zip    将文件解压到指定文件夹</li></ul><h5 id="②-tar"><a href="#②-tar" class="headerlink" title="② tar"></a>② tar</h5><ul><li>tar 【选项】 xxx.tar.gz 打包内容<ul><li>-c    产生.tar打包文件</li><li>-v    显示详细信息</li><li>-f    指定压缩后文件名</li><li>-z    打包的同时压缩文件</li><li>-x    解包.tar文件</li></ul></li><li>tar -cxvf xxx.tar.gz 要打包的文件(一个或多个)    将文件打包为xxx.tar.gz</li><li>tar -zxvf xxx.tar.gz -C 目标目录    将xxx.tar.gz 解压到指定目录（目录事先存在）</li></ul><h4 id="6-组管理"><a href="#6-组管理" class="headerlink" title="6. 组管理"></a>6. 组管理</h4><p>​    linux中每个文件都有 <strong>所有者、所在组、其他组的概念。</strong> </p><h5 id="①-所有者"><a href="#①-所有者" class="headerlink" title="① 所有者"></a>① 所有者</h5><ul><li>ls -ahl    查看文件的所有者和所在组<ul><li>a    隐藏的文件</li><li>l    列表详细显示（第三列：文件所有者；第四列：文件所在组）</li><li>h    文件大小便于查看方式（G、K、M）</li></ul></li><li>chown 用户名 文件或文件夹     改变文件的所有者（所在组不会变）</li><li>chown 【选项】 新的所有者:新的所在组 文件名    同时改变文件的所有者和所在组<ul><li>-R    递归更改某个目录下的所有文件的权限（该目录的子目录也会被更改）</li></ul></li></ul><h5 id="②-所在组"><a href="#②-所在组" class="headerlink" title="② 所在组"></a>② 所在组</h5><ul><li>chgrp 组名 文件名    将文件所在组改为其他组</li><li>usermod -g 组名 用户名    改变用户所在组</li></ul><h5 id="③-其他组"><a href="#③-其他组" class="headerlink" title="③ 其他组"></a>③ 其他组</h5><p>​    除所在组的组为该文件的其他组。</p><h4 id="7-权限管理"><a href="#7-权限管理" class="headerlink" title="7. 权限管理"></a>7. 权限管理</h4><h5 id="①-文件详情解析"><a href="#①-文件详情解析" class="headerlink" title="① 文件详情解析"></a>① 文件详情解析</h5><p><code>-rw-rw--r--. 1 sivey root 20 11月 18 19：24 hello.txt</code> </p><ul><li><p>文件类型</p><ul><li>- ：普通文件</li><li>d ：目录</li><li>l ：软连接</li><li>c ： 字符设备【鼠标键盘】</li><li>b ：块文件【硬盘、U盘】</li></ul></li><li><p>文件权限</p><ul><li>前三位    用户对该文件的权限</li><li>中间三位    所属组对该文件的权限</li><li>后三位    其他组对该文件的权限</li></ul></li></ul><ul><li><p>文件数 / 硬连接数</p><ul><li>文件：1表示硬链接数</li><li>目录：1表示目录内文件个数</li></ul></li><li><p>sivey：文件所有者</p></li><li><p>root：文件所在用户组</p></li><li><p>文件大小：20k</p></li><li><p>最后修改时间：11月 18 19：24</p></li></ul><h5 id="②-rwx文件权限"><a href="#②-rwx文件权限" class="headerlink" title="② rwx文件权限"></a>② rwx文件权限</h5><p><strong>r = 4， w = 2， x = 1，rwx=4+2+1=7</strong></p><ul><li>作用到文件<ul><li>r：可读</li><li>w：可写（但不代表可以删除，只有对该问价所在目录有写权限才能删除）</li><li>x：执行</li></ul></li><li>作用到目录<ul><li>r：可读，ls查看目录内容</li><li>w：可写，可修改目录，可创建、删除、重命名目录</li><li>x：可执行，即可以进入目录</li></ul></li></ul><h5 id="③-修改权限"><a href="#③-修改权限" class="headerlink" title="③ 修改权限"></a>③ 修改权限</h5><ul><li>通过 + - = 变更权限<ul><li>chmod u=rwx,g=rx,o=x 文件或目录名    给文件或目录的所有者，所在组，其他组对应权限</li><li>chmod o+w 文件或目录名    给文件或目录的其他组增加对应权限</li><li>chmod a-x 文件或目录名    给文件的所有者、所在组、其他组去掉执行的权限</li></ul></li><li>通过数字变更权限<ul><li>chmod 751 文件或目录名    给文件或目录的所有者，所在组，其他组对应权限</li></ul></li></ul><h2 id="十、-任务调度（crond）"><a href="#十、-任务调度（crond）" class="headerlink" title="十、 任务调度（crond）"></a>十、 任务调度（crond）</h2><p>​    定时的执行一些脚本文件，如数据库的数据备份。</p><ul><li><p>crontab 【选项】</p><ul><li>-e    编辑crontab定时任务（简单任务不用写脚本，直接编辑复杂任务要写脚本文件）</li><li>-l    查询crontab任务</li><li>-r    删除当前用户所有的crontab任务</li></ul></li><li><p>service crond restart    重启任务调度</p></li><li><p>举例：执行完crontab -e后输入下面的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * ls -l /home &gt;&gt; /tmp/to.xtx</span><br></pre></td></tr></table></figure></li><li><p>时间参数说明</p><p>| 位      | 含义               | 取值范围              |<br>| ———- | ————————— | ——————————- |<br>| 第1个 <em> | 一小时中的第几分钟 | 0-59                  |<br>| 第2个 </em> | 一天当中的第几小时 | 0-23                  |<br>| 第3个 <em> | 一个月当中的第几天 | 1-31                  |<br>| 第4个 </em> | 一年当中的第几月   | 1-12                  |<br>| 第5个 * | 一周当中的星期几   | 0-7（0和7都是星期日） |</p></li><li><p>特殊符号</p><ul><li>*  ：代表任何时间，比如第一个*就代表一个小时中每分钟都执行一次的意思</li><li>,   ：代表不连续的时间，比如”0 8,12,16 <em> </em> *命令”，就代表再每天的8点0分，12点0分，16点0分都执行一次。</li><li>-    ：代表连续的时间范围，比如“<em>/10 </em> <em> </em> * 命令”，代表在周一到周六的凌晨5点0分执行命令。</li><li><em>/n    ：代表多久执行一次，比如“\</em>/10 <em> </em> <em> </em> 命令”，代表每隔十分钟就执行一遍命令。</li></ul></li><li><p>特定时间执行的案例</p><ul><li>45 22 <em> </em> * 命令    在22点45分执行</li></ul></li><li>0 17 <em> </em> 1 命令    每周1的17点0分执行<ul><li>0 5 1，15 <em> </em> 命令    每月1号和15号的凌晨5点0分执行</li><li>40 4 <em> </em> 1-5 命令    每周一到周五的凌晨4点40分执行命令</li><li><em>/10 4 </em> <em> </em> 命令    每天的凌晨4点，每隔10分钟执行一次命令</li><li>0 0 1，15 * 1 命令    每月的1号和15号，每周1的0点0分都会执行命令。注：星期几和几号最好不要同时出现，因为他们定义的都是天，容易混乱。</li></ul></li></ul><h4 id="1-任务调度过程"><a href="#1-任务调度过程" class="headerlink" title="1. 任务调度过程"></a>1. 任务调度过程</h4><ul><li><p>编写xxx.sh脚本文件，路径  /home/xw 文件内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l &#x2F;home &gt;&gt; &#x2F;tmp&#x2F;to.txt</span><br><span class="line">date &gt;&gt; &#x2F;tmp&#x2F;to.txt</span><br></pre></td></tr></table></figure></li><li><p>给脚本文件可执行的权限</p></li><li><p>crontab -e </p></li><li><p><em>/1 </em> <em> </em> * /home/xxx.sh</p></li></ul><h2 id="十一、-磁盘分区与挂载"><a href="#十一、-磁盘分区与挂载" class="headerlink" title="十一、 磁盘分区与挂载"></a>十一、 磁盘分区与挂载</h2><h4 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1. 常用命令"></a>1. 常用命令</h4><ul><li>lsblk -f    查看系统的分区和挂载情况。带有分区类型</li><li>lsblk    查看系统的分区和挂载情况。<strong>带有分区大小信息</strong></li></ul><h4 id="2-Linux的磁盘分区"><a href="#2-Linux的磁盘分区" class="headerlink" title="2. Linux的磁盘分区"></a>2. Linux的磁盘分区</h4><h5 id="①-介绍"><a href="#①-介绍" class="headerlink" title="① 介绍"></a>① 介绍</h5><p>​    磁盘分区包括主分区和扩展分区，系统必须装到主分区中，扩展分区还可以分成多个逻辑分区。</p><p>​    对Linux来说无论有几个分区，分给哪一个目录使用，它只有一个根目录，有独立且唯一的目录结构，每个分区都用来组成整个文件系统的一部分。</p><p>​    IDE硬盘，驱动器标识为hdx~,hd表示分区所在设备的类型，x：为盘号，</p><ul><li>挂载：将一个分区和一个目录联系起来，即将某分区挂载到某个目录，这时要载入的一个分区将使用他的存储空概念在一个目录下获得。</li><li>卸载：将一个分区和一个目录取消联系。</li></ul><h5 id="②-实例分析"><a href="#②-实例分析" class="headerlink" title="② 实例分析"></a>② 实例分析</h5><p>lsblk 命令得到</p><p><img src="http://qiniu.beyonderwei.com/linux-action.png" alt></p><ul><li>分区情况：—vda1 </li><li>分区类型：ext4  </li><li>uuid：4b499d76-769a-40a0-93dc-4a31a59add28</li><li>挂载点：/</li></ul><h4 id="3-磁盘情况查询"><a href="#3-磁盘情况查询" class="headerlink" title="3. 磁盘情况查询"></a>3. 磁盘情况查询</h4><ul><li>df -lh    查询系统磁盘整体的使用情况</li><li>du -h /目录    查询指定目录的磁盘占用情况<ul><li>-s    指定目录占用大小汇总</li><li>-h    带计量单位</li><li>-a    含文件</li><li>—max-depth=1    子目录深度</li><li>-c    列出明细的同时，增加汇总值</li></ul></li><li>yum install tree    安装tree指令</li></ul><h2 id="十二、网络配置"><a href="#十二、网络配置" class="headerlink" title="十二、网络配置"></a>十二、网络配置</h2><ul><li>ifconfig    查看网络情况<ul><li>eth0  表示第一块网卡</li><li>eth1  表示第二块网卡</li></ul></li><li>ping ip或域名    查看网络的联通情况</li><li>/etc/sysconfig/network-scripts/ifcfg-eth0    网卡的配置目录<ul><li>BOOTPROTO=static    以静态的方式获取IP（每次不变）默认none</li><li>IPADDR    系统的IP地址</li><li>ONBOOT=yes    </li></ul></li><li>service network restart    重启网络服务</li></ul><h2 id="十三、进程管理"><a href="#十三、进程管理" class="headerlink" title="十三、进程管理"></a>十三、进程管理</h2><h4 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h4><ul><li>linux中每一个执行的程序都为一个进程，每一个进程都被分配一个ID（PID）来管理</li><li>每一个进程都会对应一个父进程，父进程可以复制多个子进程。linux的总父进程为init.</li><li>进程以两种方式存在，前台和后台。</li><li>一般系统服务都是以后台进程方式存在，一般都会常驻在系统中，直到关机才结束。</li></ul><h4 id="2-进程查询"><a href="#2-进程查询" class="headerlink" title="2. 进程查询"></a>2. 进程查询</h4><h5 id="①-ps-aux-查看程序"><a href="#①-ps-aux-查看程序" class="headerlink" title="①. ps -aux    查看程序"></a>①. ps -aux    查看程序</h5><ul><li><p>-a    显示当前终端的所有进程</p></li><li><p>-u    以用户格式显示进程信息</p></li><li>-x    显示后台进程运行的参数</li></ul><p><strong>注：</strong> bash或/bin/bash表示终端的进程</p><p>参数列表：</p><ul><li>USER    用户名</li><li>PID    进程ID</li><li>%CPU    CPU占用率</li><li>%MEM    内存占用率</li><li>VSZ    虚拟内存占用情况</li><li>RSS    物理内存占用情况</li><li>TTY    使用的终端</li><li>STAT    进程的状态<ul><li>s    休眠</li><li>r    运行</li><li>D    短期等待</li><li>Z    僵死进程</li><li>T    被跟踪或被停止</li></ul></li><li>START    启动时间</li><li>TIME    占用CPU的总共时间</li><li>COMMAND    进程执行时的命令行</li></ul><h5 id="②-ps-ef-查看进程的同时查看父进程"><a href="#②-ps-ef-查看进程的同时查看父进程" class="headerlink" title="②. ps -ef    查看进程的同时查看父进程"></a>②. ps -ef    查看进程的同时查看父进程</h5><ul><li>PPID    父进程ID</li></ul><p>eg：ps -ef | grep sshd    查看sshd（远程连接服务）进程的父进程</p><h5 id="③-pstree-以树状的形式查询进程"><a href="#③-pstree-以树状的形式查询进程" class="headerlink" title="③. pstree 以树状的形式查询进程"></a>③. pstree 以树状的形式查询进程</h5><ul><li>-p    显示PID</li><li>-u    显示进程 所属用户</li></ul><h4 id="3-终止进程"><a href="#3-终止进程" class="headerlink" title="3. 终止进程"></a>3. 终止进程</h4><ul><li>kill [选项] 进程号<ul><li>kill -9  进程号    强制停止某个进程（如终端进程会忽略kill，需要使用 -9 ）</li></ul></li><li>killall 进程名称    通过一个进程的名称，将一个父进程及其所有子进程全部终止</li></ul><h4 id="4-服务管理"><a href="#4-服务管理" class="headerlink" title="4. 服务管理"></a>4. 服务管理</h4><h5 id="①-简介"><a href="#①-简介" class="headerlink" title="① 简介"></a>① 简介</h5><p>​    服务本质上就是一个进程，但是是运行在后台的，通常会监听一个端口，通过这个端口等待其他请求的连接。如sshd 防火墙 mysql等，又称守护进程。</p><h5 id="②-管理指令"><a href="#②-管理指令" class="headerlink" title="② 管理指令"></a>② 管理指令</h5><ul><li><strong>centos7.0以前：</strong> service 服务名 start stop restart reload status</li><li><strong>centos7.0以后：</strong> systemctl 指令代替 service</li></ul><p>eg：service iptables status    查看防火墙（iptables）的状态</p><h5 id="③-查看端口状态"><a href="#③-查看端口状态" class="headerlink" title="③ 查看端口状态"></a>③ 查看端口状态</h5><ul><li>telnet ip 端口号    在windos上查看某个ip的端口号是否在监听状态</li></ul><h5 id="④-查看系统的服务"><a href="#④-查看系统的服务" class="headerlink" title="④ 查看系统的服务"></a>④ 查看系统的服务</h5><ul><li>setup -&gt; 系统服务    可以看到有哪些系统服务<ul><li>带有星号的表示自启动的。</li></ul></li><li>ls -l /etc/init.d/    查看有哪些服务</li></ul><h5 id="⑤-开机流程"><a href="#⑤-开机流程" class="headerlink" title="⑤ 开机流程"></a>⑤ 开机流程</h5><p>​    开机 - BIOS - /boot - init进程1 - <strong>运行级别</strong> - 运行级别对应的服务</p><p>每一个进程，针对每一个运行级别都设置了是否自启动。</p><h5 id="⑥-服务自启动（设置级别）"><a href="#⑥-服务自启动（设置级别）" class="headerlink" title="⑥. 服务自启动（设置级别）"></a>⑥. 服务自启动（设置级别）</h5><ul><li><p>chkconfig —list    查看每个服务的各个运行级别设置是否自启动/关闭</p></li><li><p>chkconfig 服务名 —list    查看某个服务的各个运行级别设置是否自启动/关闭</p></li><li>chkconfig —level 5 服务名 on/off    为某个服务设置在某个运行级别下是否自启动</li></ul><h4 id="5-监控服务"><a href="#5-监控服务" class="headerlink" title="5. 监控服务"></a>5. 监控服务</h4><h5 id="①-动态进程监控"><a href="#①-动态进程监控" class="headerlink" title="①. 动态进程监控"></a>①. 动态进程监控</h5><ul><li><p>top [选项]    显示正在执行的进程</p><ul><li>-d    指定top每隔几秒更新（默认3秒）</li><li>-i    不显示任何限制或僵死的进程</li><li>-p    查看指定PID的进程的状态</li></ul><p><strong>交互操作说明：</strong></p><ul><li>P    以cpu使用率排序（默认）</li><li>M    以内存使用率排序</li><li>N    以PID排序</li><li>u    输入u以后输入用户名回车，查看指定用户的进程</li><li>k    输入k以后输入进程号，会杀死相应的进程</li><li>Q   退出</li></ul></li></ul><h5 id="②-网络状态监控"><a href="#②-网络状态监控" class="headerlink" title="②. 网络状态监控"></a>②. 网络状态监控</h5><ul><li><p>netstat -anp    查看所有的网络服务</p><ul><li>-an    按一定顺序排列输出</li><li>-p    显示哪个进程在调用</li></ul><p>eg：</p><ul><li>netstat -anp |grep sshd    查看sshd服务的网络在那个太</li><li>netstat -anp |grep 6379    查看6379端口的网络状态</li></ul></li></ul><h2 id="十四、-RPM和YUM"><a href="#十四、-RPM和YUM" class="headerlink" title="十四、 RPM和YUM"></a>十四、 RPM和YUM</h2><h4 id="1-RPM"><a href="#1-RPM" class="headerlink" title="1.  RPM"></a>1.  RPM</h4><p>​    全称：Redhat Package Manager 类似windos的.exe安装包，RPM被redhat、centos等发行版本所使用。</p><h5 id="①-命令"><a href="#①-命令" class="headerlink" title="①. 命令"></a>①. 命令</h5><ul><li><p>rpm -qa    查询已安装的rpm软件</p><p>eg：rpm -qa | grep xxx    查询系统是否安装了xxx</p></li><li><p>rpm -qa    查询已经安装的所有安装包</p></li><li><p>rpm -qi 软件包名    查看安装的rpm软件的详细信息（版本、安装时间等）</p></li><li><p>rpm -ql 软件包名    查看安装的软件安装了哪些文件（<strong>安装位置</strong>）</p></li><li><p>rpm -qf 目录    查看某个目录是属于哪个RPM包的</p><p>eg: rpm -qf /etc/passwd</p></li><li><p>rpm -e 软件包名    删除某个软件包（当该包被其他包依赖时会提示是否强制删除）</p></li><li><p>rpm -ivh  路径/软件包名    安装某个rpm软件包（要先有安装包，才能安装）</p><ul><li>-i    install  安装</li><li>-v    verbose 提示</li><li>-h    hash  进度条</li></ul></li></ul><h4 id="2-YUM-主流"><a href="#2-YUM-主流" class="headerlink" title="2.YUM(主流)"></a>2.YUM(主流)</h4><h5 id="①-简介-1"><a href="#①-简介-1" class="headerlink" title="①. 简介"></a>①. 简介</h5><p>​    shell前端软件包管理工具，基于RPM包，可以从指定的服务器自动下载rpm包并进行安装，也可以自动处理依赖关系，并且一次性安装所有依赖的软件包。</p><h5 id="②-基本命令"><a href="#②-基本命令" class="headerlink" title="②. 基本命令"></a>②. 基本命令</h5><ul><li>yum list | grep 软件包名称    查询远程服务器是否有该安装包</li><li>yum install 软件包名称   安装某个软件（<strong>默认安装最新的，安装后自动删除安装包</strong>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx代理时在gunicorn的日志中记录真实访问IP</title>
      <link href="/2020/02/25/Nginx%E4%BB%A3%E7%90%86%E6%97%B6%E5%9C%A8gunicorn%E7%9A%84%E6%97%A5%E5%BF%97%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9C%9F%E5%AE%9E%E8%AE%BF%E9%97%AEIP/"/>
      <url>/2020/02/25/Nginx%E4%BB%A3%E7%90%86%E6%97%B6%E5%9C%A8gunicorn%E7%9A%84%E6%97%A5%E5%BF%97%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9C%9F%E5%AE%9E%E8%AE%BF%E9%97%AEIP/</url>
      
        <content type="html"><![CDATA[<h2 id="一、问题概述"><a href="#一、问题概述" class="headerlink" title="一、问题概述"></a>一、问题概述</h2><p>在通过Nginx负载均衡的情况下，gunicorn的log中记录的访问访问日志并不是用户的IP，而是Nginx主机的IP。</p><h2 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h2><h4 id="1-Nginx配置："><a href="#1-Nginx配置：" class="headerlink" title="1. Nginx配置："></a>1. Nginx配置：</h4><p>其中<code>proxy_set_header X-Real-IP $remote_addr;</code>在请求头中加入了真实的用户IP信息，并一起发送给了后端的gunicorn 服务。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /api &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://zy_ems;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-gunicorn配置"><a href="#2-gunicorn配置" class="headerlink" title="2. gunicorn配置"></a>2. gunicorn配置</h4><p>在gunicorn的启动配置文件中添加下面一段配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log_format &#x3D; &#39;%(h)s %(l)s %(u)s %(t)s &quot;%(r)s&quot; %(s)s %(b)s &quot;%(f)s&quot; &quot;%(a)s&quot; &quot;%(&#123;X-Real-IP&#125;i)s&quot;&#39;</span><br></pre></td></tr></table></figure><br>前面的内容为其他的信息，最后的<code>&quot;%({X-Real-IP}i)s&quot;</code>是在日志中加入用户真实的访问IP。<br>具体关于日志格式的定制可参考：<br><a href="http://docs.gunicorn.org/en/latest/settings.html#logging" target="_blank" rel="noopener">1. gunicorn官网(logging)</a><br><a href="https://stackoverflow.com/questions/25737589/gunicorn-doesnt-log-real-ip-from-nginx" target="_blank" rel="noopener">2.Gunicorn doesn’t log real ip from nginx</a><br><img src="https://img-blog.csdnimg.cn/20200317212951176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="官方文档"></p><h2 id="三、实现效果"><a href="#三、实现效果" class="headerlink" title="三、实现效果"></a>三、实现效果</h2><p>上面两条日志为访问配置前，日志的内容只有nginx的ip，最后一条日志为配置后，除了有nginx的ip之外，追加了用户的ip信息。<br><img src="https://img-blog.csdnimg.cn/20200317213156316.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> gunicorn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Docker部署Flask应用（gunicorn+gevent）</title>
      <link href="/2020/02/23/%E9%80%9A%E8%BF%87Docker%E9%83%A8%E7%BD%B2Flask%E5%BA%94%E7%94%A8%EF%BC%88gunicorn-gevent%EF%BC%89/"/>
      <url>/2020/02/23/%E9%80%9A%E8%BF%87Docker%E9%83%A8%E7%BD%B2Flask%E5%BA%94%E7%94%A8%EF%BC%88gunicorn-gevent%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、项目架构"><a href="#一、项目架构" class="headerlink" title="一、项目架构"></a>一、项目架构</h2><p>&ensp;&ensp;&ensp;&ensp;前后端分离项目中，为缓解服务器压力，通常我们后端代码会部署到多个服务器上，而通过Docker容器虚拟化技术可以让我们避免因开发和运维之间配置环境、运行环境、操作系统、运行依赖包等不同导致的项目部署后无法运行的问题，同时也简化了部署过程。这里后端使用的是gunicorn，相当于java开发者熟悉的tomcat。<br>&ensp;&ensp;&ensp;&ensp;当然下面的架构还可以进一步根据你的应用场景继续完善，如高可用的Nginx，一主二从的数据库等。<br><img src="https://img-blog.csdnimg.cn/202003161833256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h2 id="二、Docker安装"><a href="#二、Docker安装" class="headerlink" title="二、Docker安装"></a>二、Docker安装</h2><p>&ensp;&ensp;&ensp;&ensp;默认你已经在宿主机上安装了Docker，如果没有安装可以参考：<a href="https://blog.csdn.net/CSDN_X_W/article/details/103847762" target="_blank" rel="noopener">Ubuntu安装Docker(阿里源/官方源)</a></p><h2 id="三、获取需求文件requirements-txt"><a href="#三、获取需求文件requirements-txt" class="headerlink" title="三、获取需求文件requirements.txt"></a>三、获取需求文件requirements.txt</h2><p>&ensp;&ensp;&ensp;&ensp;在虚拟环境中运行命令：<code>pip  freeze  &gt; requirements.txt</code>，requirements.txt文件内容为项目工程所需的模块。</p><h2 id="四、gunicorn配置文件"><a href="#四、gunicorn配置文件" class="headerlink" title="四、gunicorn配置文件"></a>四、gunicorn配置文件</h2><p>&ensp;&ensp;&ensp;&ensp;配置文件内容可根据自己的服务器配置进行调整。<br>gunicorn.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进程数</span></span><br><span class="line">workers = <span class="number">2</span></span><br><span class="line"><span class="comment"># 每个进程的线程数</span></span><br><span class="line">threads = <span class="number">4</span></span><br><span class="line"><span class="comment"># 端口5000</span></span><br><span class="line">bind = <span class="string">'0.0.0.0:5000'</span></span><br><span class="line"><span class="comment"># 工作模式协程</span></span><br><span class="line">worker_class = <span class="string">'gevent'</span></span><br><span class="line"><span class="comment"># 最大并发量</span></span><br><span class="line">worker_connections = <span class="number">100</span></span><br><span class="line"><span class="comment"># 进程pid文件</span></span><br><span class="line">pidfile = <span class="string">'gunicorn.pid'</span></span><br><span class="line"><span class="comment"># 访问日志和错误信息日志的路径</span></span><br><span class="line">accesslog = <span class="string">'/logs/gunicorn_acess.log'</span></span><br><span class="line">errorlog  = <span class="string">'/logs/gunicorn_error.log'</span></span><br><span class="line"><span class="comment"># 日志记录级别</span></span><br><span class="line">loglevel = <span class="string">'info'</span></span><br><span class="line"><span class="comment"># 代码发生变化是否自动重启</span></span><br><span class="line">reload = <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><h2 id="五、编写Dockerfile"><a href="#五、编写Dockerfile" class="headerlink" title="五、编写Dockerfile"></a>五、编写Dockerfile</h2><h4 id="0-前提"><a href="#0-前提" class="headerlink" title="0. 前提"></a>0. 前提</h4><p>&ensp;&ensp;&ensp;&ensp;在Linux系统下选择一个目录作为项目的工程目录：如<code>/beyonderwei/flask</code>，Dockerfile和requirements.txt均直接放在该目录下，并新建三个文件夹 <code>mkdir ./src ./logs ./conf</code>，作为与容器映射的数据卷。将gunicorn.py 放到conf文件夹下，src下存放的是你的项目代码，logs用来以后直接在宿主机查看运行日志，里面的文件在运行容器后自动生成。<br>src文件夹(项目代码)：<br><img src="https://img-blog.csdnimg.cn/20200316194218279.png"></p><h4 id="1-选择python环境"><a href="#1-选择python环境" class="headerlink" title="1. 选择python环境"></a>1. 选择python环境</h4><p>&ensp;&ensp;&ensp;&ensp;因为我们自己的镜像是以某个版本的python作为父镜像的，因此需要根据你的应用环境进行选择，并通过docker在DockerHub中下载相应版本的镜像到本地。比如我使用的python版本为3.7.4</p><h4 id="2-Dockerfile"><a href="#2-Dockerfile" class="headerlink" title="2. Dockerfile"></a>2. Dockerfile</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FROM python:<span class="number">3.7</span><span class="number">.4</span></span><br><span class="line">MAINTAINER <span class="string">"Beyonderwei&lt;beyonderwei@gmail.com&gt;"</span></span><br><span class="line"><span class="comment"># 清华源</span></span><br><span class="line">ENV PIP_SOURCE <span class="string">"https://pypi.tuna.tsinghua.edu.cn/simple"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来存放源程序、日志和配置文件</span></span><br><span class="line">RUN mkdir /src /logs /conf</span><br><span class="line"></span><br><span class="line">WORKDIR /logs</span><br><span class="line"></span><br><span class="line">RUN pip install -i $&#123;PIP_SOURCE&#125; flask</span><br><span class="line">RUN pip install -i $&#123;PIP_SOURCE&#125; gunicorn</span><br><span class="line">RUN pip install -i $&#123;PIP_SOURCE&#125; gevent</span><br><span class="line"></span><br><span class="line">COPY ./requirements.txt ./</span><br><span class="line">RUN pip install -i $&#123;PIP_SOURCE&#125; requirements.txt</span><br><span class="line">EXPOSE <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"gunicorn"</span>, <span class="string">"-c"</span>, <span class="string">"/conf/gunicorn.py"</span>, <span class="string">"main:app"</span>]</span><br></pre></td></tr></table></figure><h2 id="六、build得到镜像"><a href="#六、build得到镜像" class="headerlink" title="六、build得到镜像"></a>六、build得到镜像</h2><ol><li>直接在上述的工程目录下执行：<code>docker build -t 镜像名:[镜像版本] .</code></li><li>查看镜像：<code>docker images</code><h2 id="七、运行镜像"><a href="#七、运行镜像" class="headerlink" title="七、运行镜像"></a>七、运行镜像</h2><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4>&ensp;&ensp;&ensp;&ensp;确保你的src目录下已经存放了项目文件，不然会在运行容器时因为找不到对应的文件，（当然也可以在启动容器后将项目文件放入，但确保通过以下命令运行，因为通过容器数据卷映射的方式，当添加了项目文件后，容器内对应目录也会有该文件）。<h4 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h4>项目目录下执行：<br><code>docker run -d -p 5000:5000 --name 容器名 -v /beyonderwei/flask/src:/src -v /beyonderwei/flask/logs:/logs -v /beyonderwei/flask/conf:/conf 镜像名:[镜像版本号]</code><br>注：如果使用的端口不是5000的话，需要在Dockerfile中也进行修改。<h4 id="将镜像上传到阿里云"><a href="#将镜像上传到阿里云" class="headerlink" title="将镜像上传到阿里云"></a>将镜像上传到阿里云</h4>&ensp;&ensp;&ensp;&ensp;将镜像上传到阿里云的镜像仓库可方便以后在需求文件相同的时候直接拉下来使用，参考该文章后面部分：<a href="https://blog.csdn.net/CSDN_X_W/article/details/103847762" target="_blank" rel="noopener">阿里云镜像存储服务</a><h2 id="八、应用测试"><a href="#八、应用测试" class="headerlink" title="八、应用测试"></a>八、应用测试</h2>&ensp;&ensp;&ensp;&ensp;<strong>如果我们的项目main.app内容如下</strong>，可以在浏览器访问 <a href="http://ip:5000" target="_blank" rel="noopener">http://ip:5000</a> 并返回 “hello world”。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def index():</span><br><span class="line">    return &#39;hello world&#39;</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run(host&#x3D;&#39;0.0.0.0&#39;, port &#x3D; 5000)</span><br></pre></td></tr></table></figure></li></ol><h2 id="九、日志查看"><a href="#九、日志查看" class="headerlink" title="九、日志查看"></a>九、日志查看</h2><p>&ensp;&ensp;&ensp;&ensp;可在宿主机logs下查看访问日志：<br><img src="https://img-blog.csdnimg.cn/20200316201722464.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Flask </tag>
            
            <tag> gunicorn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装Nginx实现反向代理</title>
      <link href="/2020/02/15/Docker%E5%AE%89%E8%A3%85Nginx%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2020/02/15/Docker%E5%AE%89%E8%A3%85Nginx%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、配置文件"><a href="#一、配置文件" class="headerlink" title="一、配置文件"></a>一、配置文件</h2><p>&ensp;&ensp;&ensp;&ensp;以前的配置文件为一个nginx.conf，新的版本将其分成了两个，default.conf 和 nginx.conf，为通过数据卷映射的方式，但没有在github上找到分开的这两个文件，因此先通过直接运行的方式得到这两个文件。</p><ol><li>先普通方式运行一个nginx容器<br><code>docker run --name my-nginx -p 80:80 -d nginx</code><br>注：阿里云的80端口被占用了，因此要把原有的kill 掉。查看端口pid：<code>netstat -tanlp</code> ，杀掉进程：<code>kill 进程pid</code>。</li><li>进入容器，将default.conf 和 nginx.conf两个文件复制到宿主机。<br>将容器中的文件拷贝到宿主机：<code>docker cp 容器ID:容器内文件路径 宿主机路径</code>，（<strong>注：</strong>命令在宿主机中执行，冒号前后没有空格）。<h2 id="二、通过宿主机的配置文件启动"><a href="#二、通过宿主机的配置文件启动" class="headerlink" title="二、通过宿主机的配置文件启动"></a>二、通过宿主机的配置文件启动</h2>命令：<br><code>docker run --name my-nginx -p 80:80 -v /xxx/mynginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /xxx/mynginx/conf/default.conf:/etc/nginx/conf.d/default.conf -d nginx</code><br>说明：</li></ol><ul><li>-v：数据卷绑定（将宿主机的配置文件，与容器内配置文件进行绑定）</li><li>注：还可以绑定log等其他文件<h2 id="三、反向代理"><a href="#三、反向代理" class="headerlink" title="三、反向代理"></a>三、反向代理</h2>打开 default.conf ，如我们部署在tomcat /webapps/xxx/下的项目，配置如下：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        root  html;</span><br><span class="line">        proxy_pass http://你的ip:8080/xxx/;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><strong>重启nginx</strong>：</li></ul><ol><li>方式一：通过Docker重启容器：修改的配置文件会生效 <code>docker stop ID</code>，<code>docker start ID</code>。</li><li>方式二：在nginx容器内(/usr/local/sbin/)通过<code>nginx -s reload</code>重新加载配置的方式容器会直接停止，然后重新 <code>docker start ID</code> 启动即可。</li></ol><p>这样，当我们直接访问nginx所在服务器的ip（由于是80端口），即可直接访问到代理服务器。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打包Vue项目部署到Nginx并访问</title>
      <link href="/2020/02/08/%E6%89%93%E5%8C%85Vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Nginx%E5%B9%B6%E8%AE%BF%E9%97%AE/"/>
      <url>/2020/02/08/%E6%89%93%E5%8C%85Vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Nginx%E5%B9%B6%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>把 Nginx 做为静态资源服务器，用来部署前端项目，本文介绍 Vue 项目打包、部署到 Nginx 的过程，并解决部署后，因 vue-router 使用 history 模式导致的在直接访问项目和点击路由链接时可以访问，而根地址刷新页面空白的问题。</p><h2 id="二、打包项目"><a href="#二、打包项目" class="headerlink" title="二、打包项目"></a>二、打包项目</h2><p><strong>Vue的有关build、config的文件均保持原本的配置即可，无需更改</strong> ，终端输入<code>npm run build</code>，成功后会在项目中看到打包好的项目在dist文件夹中。为了去掉URL中的 “ # ”，此时我们 vue-router 使用的是 history 模式，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: [...]</span><br><span class="line">  )&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三、Docker安装Nginx并部署项目"><a href="#三、Docker安装Nginx并部署项目" class="headerlink" title="三、Docker安装Nginx并部署项目"></a>三、Docker安装Nginx并部署项目</h2><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><ol><li>阿里云ECS</li><li>Ubuntu 系统</li><li>Docker容器化<br><strong>注：</strong> 默认已经通过Docker下载好 Nginx 镜像<h3 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h3></li><li>运行 Nginx 容器<br>关于在 Docker 中运行 Nginx 容器，以及其<strong>配置文件</strong>的有关问题请参考：<a href="https://blog.csdn.net/CSDN_X_W/article/details/104721804" target="_blank" rel="noopener">在Docker中运行Nginx</a> 的前两部分。</li><li>进入容器，并在 根目录下新建文件夹 xxx（比如你项目的名字）<br>进入容器命令：<code>deocekr exec -it 容器名 bash</code></li><li>将打包好的文件（/dist 文件 index.html 和static文件夹）放到Nginx容器 /xxx/  下<br><strong>涉及的命令：</strong><br>①. <code>docker cp 宿主机中文件路径及容器文件名 容器名：要拷贝到容器里面对应的路径</code><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3>修改 http server 的location部分如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">root</span> <span class="string">/xxx;</span> <span class="comment"># index.html 和 static 所在的目录</span></span><br><span class="line"><span class="string">index</span> <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line"><span class="string">try_files</span> <span class="string">$uri</span> <span class="string">$uri/</span> <span class="string">/index.html;</span> <span class="comment"># 为解决 history 模式下，刷新页面时空白的额问题。</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>相关配置参考 <a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">vue-router官方教程。</a><h2 id="四、重启容器并访问"><a href="#四、重启容器并访问" class="headerlink" title="四、重启容器并访问"></a>四、重启容器并访问</h2></li><li>重启nginx容器：<code>docker stop 容器id</code>，<code>docker start 容器id</code>。</li><li>浏览器访问（docker 映射nginx为80端口时）：<a href="http://ip。" target="_blank" rel="noopener">http://ip。</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 基础</title>
      <link href="/2020/01/20/docker%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/01/20/docker%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Docker概述"><a href="#一、Docker概述" class="headerlink" title="一、Docker概述"></a>一、Docker概述</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>基于Go语言实现的云开源项目。<strong>理念：Build，Ship and Run Any App Anywhere</strong> ，<strong>缩小版的Linux系统。</strong></p><h3 id="2-为什么使用Docker"><a href="#2-为什么使用Docker" class="headerlink" title="2.  为什么使用Docker"></a>2.  为什么使用Docker</h3><p><strong>解决了运行环境和配置问题的软件容器，方便做持续的集成并有助于整体发布的容器虚拟化技术。</strong> </p><ul><li>Docker用来解决开发和运维之间配置环境、运行环境、操作系统、运行依赖包等不同导致的项目部署后无法运行的问题，因此将工程与工程运行所需的配置等一起打包成一个镜像。</li><li>解决集群项目中，如果同一个项目需要再多台机器上部署时需要反复配置的问题。</li><li>一次构建，处处运行。（类似于Java虚拟机的概念）</li></ul><h3 id="2-与虚拟机对比"><a href="#2-与虚拟机对比" class="headerlink" title="2. 与虚拟机对比"></a>2. 与虚拟机对比</h3><ul><li>虚拟机：虚拟出一套硬件以后，在其上运行一套完整的操作系统（在宿主机OS上运行虚拟机OS），在该系统上运行所需的应用进程。（资源占用多，启动慢，冗余步骤多）</li><li>Docker：容器内的应用使用的是<strong>宿主机的内核</strong>，没有硬件虚拟，容器之间相互隔离，每个容器有自己的文件系统，容器间不会相互影响。</li></ul><h3 id="3-Docker的三大特征（重要）"><a href="#3-Docker的三大特征（重要）" class="headerlink" title="3. Docker的三大特征（重要）"></a>3. Docker的三大特征（重要）</h3><ul><li><strong>镜像：</strong> </li><li><strong>容器：</strong> </li><li><strong>仓库：</strong> 提交Docker镜像的仓库。<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> </li></ul><h3 id="4-理解Docker"><a href="#4-理解Docker" class="headerlink" title="4. 理解Docker"></a>4. 理解Docker</h3><ul><li>蓝色的海：宿主机系统</li><li>鲸鱼：Docker</li><li>集装箱：容器实例 （实例来自于镜像）</li></ul><h2 id="二、Ubuntu安装Docker"><a href="#二、Ubuntu安装Docker" class="headerlink" title="二、Ubuntu安装Docker"></a>二、Ubuntu安装Docker</h2><ol><li>安装必要的系统工具</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure><ol><li>将Docker存储库添加到APT源：</li></ol><p>①. 官方的源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</span><br></pre></td></tr></table></figure><p>②. 阿里的源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"</span><br></pre></td></tr></table></figure><ol><li>将官方Docker存储库的GPG密钥添加到系统：</li></ol><p>①. 官方的GPG证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>②. 阿里的GPG证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><ol><li>确保从Docker repo 安装docker</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache policy docker-ce</span><br></pre></td></tr></table></figure><ol><li>安装Docker(社区版)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y docker-ce</span><br></pre></td></tr></table></figure><ol><li>查看docker版本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><ol><li>启动Docker</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure><ol><li>由于从国外的网站拉镜像比较慢，因此国内如阿里云提供了容器镜像服务（如果不使用国内的镜像服务也没关系）。注册阿里云账号后，一般进入控制台/产品与服务/容器镜像服务/镜像加速器（第一次进入会让你设置一个Rigistry密码）。然后就可以看到你的专属加速器地址和配置使用方法(根据系统按照操作文档中的命令运行即可)。</li></ol><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/Docker/aliyunImage.png" alt></p><ol><li>查看Docker所使用的源## </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info|grep Mirrors -A 1</span><br></pre></td></tr></table></figure><h2 id="三、Docker常用命令"><a href="#三、Docker常用命令" class="headerlink" title="三、Docker常用命令"></a>三、Docker常用命令</h2><p>docker [OPTION] COMMAND</p><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><ol><li>docker version    查看docker版本</li><li>docker info    docker的详细信息</li><li>docker —help    查看Docker的帮助信息</li></ol><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><ol><li>docker images    列出本地所有的镜像<ul><li>-a   列出本地所有的镜像，（含中间层）</li><li>-q    只显示镜像的ID</li><li>-qa    所有镜像的ID</li><li>—digests    列出所有镜像，带有镜像的摘要信息</li><li>—no-trunc    没有截取显示所有信息（如查看完整ID）</li></ul></li><li>docker search 镜像名字（是从docker hub上查询的）<ul><li>-s    查询出点赞数超过50的镜像（docker search -s 50 tomcat）</li><li>—no-trunc    没有截取显示所有信息（可以看到完整的Description）</li></ul></li><li>docker pull 镜像名字  （下载镜像，默认最新版本 :latest ）<ul><li>:5.6    拉取相应版本的镜像（docker pull :5.6）</li></ul></li><li>docker rmi 镜像名（删除镜像remove images）<ul><li>-f    强制删除镜像</li><li>镜像名 镜像名    删除多个镜像（docker rmi hello-word tomcat）</li><li>$(docker images -qa)    删除所有镜像 docker rmi  -f $(docker images -qa)</li></ul></li></ol><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><ol><li><p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]  启动容器</p><ul><li><p>-i：  以交互模式运行容器，通常与 -t 同时使用</p></li><li><p>-t：  为容器重新分配一个伪输入终端，通常与 -i 同时使用（-it）</p></li><li><p>—name=”容器新名字”:   为容器指定一个名称；</p></li><li><p>-d:   后台运行容器，并返回容器ID，也即启动守护式容器；</p></li><li><p>-P:   随机端口映射；</p></li><li><p>-p:   指定端口映射 </p><p>例如：docker run -it -p 8090:8080 tomcat     Docker运行tomcat tomcat的8080端口映射到8090，实际向外暴露的8090端口。</p></li></ul></li><li><p>docker ps    正在运行的容器</p><ul><li>-l    上一个运行的容器</li><li>-a    运行过的所有容器</li><li>-n    n是一个数字，列出最近运行出的n个容器</li><li>-q    只显示容器的编号（ID）用于批量删除容器</li></ul></li><li><p>exit    退出容器（容器停止运行）</p></li><li><p>Ctrl + P +Q  <strong>退出容器，容器仍在运行</strong></p></li><li><p>docker start 容器ID    启动已经停止了的容器</p></li><li><p>docker restart 容器ID    重启某个容器</p></li><li><p>docker stop 容器ID     停止容器运行</p></li><li><p>docekr kill 容器ID    强制停止容器（马上停止）</p></li><li><p>docker rm 容器ID    删除某个容器（已经停止了的）</p><ul><li>-f    强制删除</li></ul></li><li><p>docker ps -d 容器ID    运行容器，运行后就停止了（<strong>Docker机制：Docker 后台运行，必须有一个前台进程</strong>）</p></li><li><p>docker attach 容器ID    <strong>进入正在运行的容器</strong></p></li><li><p>docker exec -it 容器ID /bin/bash    进入到容器中打开终端</p><p>或者直接运行bash:    docker exec -it 容器ID bash</p><p>或者使用容器的名字来替换容器ID</p></li><li><p>docker logs 容器ID</p><ul><li>-t     加入时间戳</li><li>-f    跟随最新日志打印</li><li>—tail 数字     显示最后多少条</li></ul></li><li><p>docker top 容器ID    查看容器中运行的进程</p></li><li><p>docker inspect 容器ID    查看容器的内部细节</p></li><li><p>docker cp 容器ID:/tmp/test.txt /root    将容器中的文件拷贝到宿主机（命令在宿主机中执行，冒号前后没有空格）</p></li></ol><h3 id="提交命令"><a href="#提交命令" class="headerlink" title="提交命令"></a>提交命令</h3><ol><li>docker commit    提交容器副本使之成为新的镜像<ul><li>docker commit -m=”提交信息” -a=”作者” 容器ID 要创建的镜像名:版本号</li><li>eg：docker commit -m=”tomcat of me” -a=”xuwei” fq48903bfd beyonderwei/mytomcat:1.2</li></ul></li></ol><h2 id="四、镜像-UnionFS"><a href="#四、镜像-UnionFS" class="headerlink" title="四、镜像(UnionFS)"></a>四、镜像(UnionFS)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>镜像：</strong> 轻量级的可执行的独立软件包，用来打包运行环境和基于运行环境开发的软件。</p><ul><li>UnionFS:联合文件系统，是一种分层、轻量级并且高性能的文件系统，<strong>支持对文件系统的修改作为一次提交来一层层叠加。</strong></li><li>bootFS：包含bootloader 和 kernel ，bootloader 用来引导和加载kernel,<strong>Docker镜像的最底层也是bootFS</strong>。</li><li>rootFS：在bootFS之上，包含的是典型的Linux系统中的/dev /bin等目录文件，root就是各种不同linux系统的发行版如：Ubuntu，CentOS等。<strong>Docker的镜像共用了内核，只是rootFS不同，因此很小。</strong> </li><li>分层结构：为了共享资源，多个镜像用到相同的base镜像时，宿主机只需要保存一份base镜像。</li></ul><h2 id="五、容器数据卷"><a href="#五、容器数据卷" class="headerlink" title="五、容器数据卷"></a>五、容器数据卷</h2><p><strong>简介：</strong> Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据作为镜像的一部分保存下来的话，当我们删除容器后，数据就消失了，<strong>而容器数据卷实现了数据的持久化</strong>。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>容器与主机之间的数据共享。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol><li>数据卷可以在容器之间共享或重用数据</li><li>卷中的更改可以直接生效</li><li>数据卷中的更改不会包含在镜像的更新当中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ol><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ol><li><p>docker run -it -v /宿主机绝对路径目录：/容器内目录 镜像名      运行镜像的过程中添加数据卷</p><p>eg：docker run -it -v /dataVolume:/dataVolumeContainer 镜像名</p></li><li><p>docker run -it -v  /宿主机绝对路径目录：/容器内目录:ro 镜像名      添加权限（容器内只读read only）</p><p><strong>注：</strong></p><ul><li><strong>容器停止以后，主机修改数据，当再次启动容器时，数据会同步。</strong> </li></ul></li><li><p><strong>可通过 docker inspect 容器ID 来查看容器数据卷与宿主机之间的绑定关系</strong> </p></li></ol><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><strong>注：容器之间的配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。</strong></p><ol><li>docker run -it —name doc2 —volumes-from 已有容器ID beyonderwei/ubuntu     运行容器beyonderwei/ubuntu 名为doc2 继承自 已有容器ID，这样就有父容器的所有数据卷</li></ol><h2 id="六、DockerFile添加容器卷"><a href="#六、DockerFile添加容器卷" class="headerlink" title="六、DockerFile添加容器卷"></a>六、DockerFile添加容器卷</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p><strong>DockerFile 是镜像模板的描述文件，用来构建Docker镜像的构建文件，由一系列命令和参数构成的脚本。（有自己的一套语法规则）。</strong> </p><h3 id="DockerFile形式添加数据卷"><a href="#DockerFile形式添加数据卷" class="headerlink" title="DockerFile形式添加数据卷"></a>DockerFile形式添加数据卷</h3><p>可在Docker中使用VOLUME指令来给镜像添加一个或者多个数据卷</p><ol><li><p>宿主机根目录下新建mydocker文件夹并进入</p></li><li><p>File构建（脚本文件）</p><p>vim DockerFile     并输入以下内容</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> volume <span class="built_in">test</span></span></span><br><span class="line">RROM ubuntu</span><br><span class="line">VOLUME ["/dataVolumeContainer"]</span><br><span class="line">CMD echo "success!"</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><ol><li>docker build -f /mydocker/DockerFile -t beyonderwei/ubuntu .      构建一个新的镜像文件（<strong>命令最后有一个点，表示执行所有指令</strong>）</li><li>docker images      查看自己刚构建好的镜像</li><li>运行自己构建的容器，这样就会自动构建容器数据卷</li></ol><h2 id="七、DockerFile"><a href="#七、DockerFile" class="headerlink" title="七、DockerFile"></a>七、DockerFile</h2><h4 id="构建docker镜像的步骤"><a href="#构建docker镜像的步骤" class="headerlink" title="构建docker镜像的步骤"></a>构建docker镜像的步骤</h4><ol><li><p>编写Dockerfile文件</p></li><li><p>docker build Dockerfile文件</p><p>命令：<code>docker build -f dockerfile文件 -t 镜像名:版本号 .</code>  </p><p>命令最后的点表示输出镜像到当前路径</p></li><li><p>docker run  运行镜像文件</p></li></ol><p>注：每条指令都会创建一个镜像层，并对镜像进行提交。</p><p><strong>在我们得到镜像以后，就可以定制自己的镜像，然后完善自己的工具库。</strong> </p><h4 id="Docker-执行DockerFile的大致流程"><a href="#Docker-执行DockerFile的大致流程" class="headerlink" title="Docker 执行DockerFile的大致流程"></a>Docker 执行DockerFile的大致流程</h4><ol><li>Docker 从基础镜像运行一个容器</li><li>执行一条指令，并对容器做出修改</li><li>执行类似 docker commit的操作提交一个新的镜像</li><li>Dcoker再基于刚提交的镜像运行一个新的容器</li><li>执行DockerFile的下一条指令直到所有的指令都执行完成。</li><li>最终形成一个我们自定义的镜像。</li></ol><p><strong>最终目的：</strong>服务器只需要安装Docker镜像后，直接运行我们自己弄好的镜像就完成部署。</p><h4 id="Docker-关键字"><a href="#Docker-关键字" class="headerlink" title="Docker 关键字"></a>Docker 关键字</h4><ol><li><p>FROM：基础镜像，当前镜像是基于哪个镜像的</p></li><li><p>MAINTAINER：镜像维护者的姓名和邮箱</p></li><li><p>RUN：构建时需要运行的额外的命令</p></li><li><p>EXPOSE：当前容器对外暴露的端口（这也就解释了为什么Docker内的Redis只能用6379端口的原因）</p></li><li><p>WORKDIR：指在创建容器后，终端默认登录进来的工作目录。</p></li><li><p>ENV：用来在构建镜像的过程中设置环境变量，键值对，其他内容可引用</p></li><li><p>ADD：将宿主机目录下的文件拷贝进镜像，ADD命令会自动处理URL和解压tar压缩包</p></li><li><p>COPY：类似ADD，拷贝问价和目录到镜像中，</p><p>将从构建上下文目录中&lt;源路径&gt;的文件 / 目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</p><p>语法： COPY src dest  或  COPY [“src”,”dest”]</p></li><li><p>VOLUME：容器的数据卷，用来数据保存和持久化工作</p></li><li><p>CMD：指定一个容器启动时要运行的命令</p><p><strong>注：</strong>Dockerfile中可以有多个CMD指令，但是只有最后一个会生效，<strong>CMD会被Docker run之后的参数替换</strong>，即会被在终端执行的命令所覆盖。</p></li><li><p>ENTRYPOINT：指定一个容器启动时要运行的命令</p><p><strong>注：</strong>和CMD一样，都是指定容器启动程序及参数，但不会被我们在终端执行的命令带的参数所覆盖，而是将终端的命令加到 ENTRYPOINT 中。</p></li><li><p>ONBUILD：当构建一个被集成的Dockerfile时运行的命令，父镜像在被子镜像继承后，父镜像的onbuild会被触发。</p></li></ol><h2 id="八、Docker安装mysql"><a href="#八、Docker安装mysql" class="headerlink" title="八、Docker安装mysql"></a>八、Docker安装mysql</h2><p>直接执行下面命令的话，没有相关的配置文件，按照配置文件启动还没有测试。</p><ul><li>原配置文件位置(8.0.12版本)：进入容器后，/etc/mysql/  下my.cnf</li></ul><ol><li><p>docker search mysql</p></li><li><p>docker pull mysql</p></li><li><p>docker run -p 3306:3306 —name 容器名</p><p>-v /xuwei/mysql/conf:/etc/mysql/conf.d      配置文件数据卷</p><p>-v /xuwei/mysql/logs:/logs      日志数据卷</p><p>-v /xuwei/mysql/data:/var/lib/mysql       数据的数据卷</p><p>-e MYSQL_ROOT_PASSWORD=123456      数据库密码</p><p>-d mysql     后台运行mysql，默认latest版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3307:3306 --name learnmysql -v /xuwei/mysql/conf:/etc/mysql/conf.d -v /xuwei/mysql/logs:/logs -v /xuwei/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>docker exec -it 容器ID /bin/bash    进入到容器中打开mysql终端</p></li><li><p>mysql -V    查看MySQL版本</p></li><li><p>mysql -uroot -p     登录mysql</p></li><li><p>mysql&gt;  show variables like ‘character%’;    查看数据库的字符设置</p></li><li><p>exit     退出mysql</p></li><li><p>exit     退出容器</p></li></ol><h2 id="九、Docker安装Redis"><a href="#九、Docker安装Redis" class="headerlink" title="九、Docker安装Redis"></a>九、Docker安装Redis</h2><ol><li><p>docker search redis</p></li><li><p>docker pull redis</p></li><li><p>vim /xuwei/myredis/conf/redis.conf        配置redis，通过数据卷实现在本机操作配置</p><p>配置文件地址：<a href="https://github.com/antirez/redis/blob/unstable/redis.conf" target="_blank" rel="noopener">redis.conf</a>  </p></li><li><p>docker run -p 6379:6379</p><p>—name myredis        容器名字</p><p>-v /xuwei/myredis/data:/data      redis数据与本地绑定</p><p>-v /xuwei/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf       通过数据卷映射配置文件到宿主机，默认：<strong>Docker中的redis无配置文件</strong></p><p>-d redis redis-server /usr/local/etc/redis/redis.conf      后台启动，按照配置文件启动</p><p>—appendonly yes        开启AOF持久化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6380:6379 --name myredis01 -v /xuwei/myredis/data:/data -v  /xuwei/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server /usr/local/etc/redis/redis.conf --port 6380 --appendonly yes</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>docker exec -it redis容器ID redis-cli      开启一个redis客户端，连接redis</p></li><li><p>docker exec -it redis容器ID bash      进入到redis容器</p><ul><li>redis-server —version      查看redis版本</li></ul></li><li><p>exit      退出redis容器</p></li><li><p>shutdown    退出redis 并停止</p></li></ol><p><strong>注意：</strong> docker 启动redis，redis只能以6379启动，但是可以通过docker 映射到主机的其他端口。</p><h2 id="十、本地镜像push到阿里云"><a href="#十、本地镜像push到阿里云" class="headerlink" title="十、本地镜像push到阿里云"></a>十、本地镜像push到阿里云</h2><ol><li><p>运行镜像得到一个容器实例（进行定制化修改）</p></li><li><p>提交（commit）：提交容器，得到新的定制化的镜像（可以提交已有的镜像素材）</p><p>docker commit -a beyonderwei -m “my test ubuntu image” 容器ID 新的镜像名:镜像版本</p></li><li><p>去阿里云创建镜像仓库</p><ul><li>命名空间：即beyonderwei/myubuntu   中的beyonderwei</li><li>选择本地仓库</li></ul></li><li><p>创建好后点击管理，可以看到操作指南。</p><ul><li>登录时使用的密码就是最开始注册容器服务时输入的那个密码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录到Registry</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker login --username=tb896628372 registry.cn-shanghai.aliyuncs.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给镜像打版本（tag）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/beyonderwei/myubuntu:[镜像版本号]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送到Registry  要求版本号与上一步的相同</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker push registry.cn-shanghai.aliyuncs.com/beyonderwei/myubuntu:[镜像版本号]</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端通过MathJax显示数学公式</title>
      <link href="/2020/01/10/%E5%89%8D%E7%AB%AF%E9%80%9A%E8%BF%87MathJax%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%EF%BC%88vue-MathJax%EF%BC%89/"/>
      <url>/2020/01/10/%E5%89%8D%E7%AB%AF%E9%80%9A%E8%BF%87MathJax%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%EF%BC%88vue-MathJax%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于MathJax"><a href="#一、关于MathJax" class="headerlink" title="一、关于MathJax"></a>一、关于MathJax</h2><ol><li>官方网址：<a href="https://docs.mathjax.org/en/latest/web/start.html" target="_blank" rel="noopener">MathJax使用文档</a> </li><li>简介：MathJax支持使用LaTeX，MathML或AsciiMath语法在网页中渲染数学公式。我们常用的语法为LaTex,比如该论坛支持的也是<a href="https://www.latex-project.org/" target="_blank" rel="noopener">LaTex</a> 。<h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2>&ensp;&ensp;&ensp;&ensp;想实现在用户选择文件后能够直接在前端预览文件内容，如下：<br><img src="https://img-blog.csdnimg.cn/20200228192716795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></li></ol><h2 id="三、遇到的问题"><a href="#三、遇到的问题" class="headerlink" title="三、遇到的问题"></a>三、遇到的问题</h2><h3 id="问题1-没有渲染效果"><a href="#问题1-没有渲染效果" class="headerlink" title="问题1(没有渲染效果)"></a>问题1(没有渲染效果)</h3><p><strong>问题描述：</strong><br>&ensp;&ensp;&ensp;&ensp;官网推荐使用CDN的方式，因此按照要求在index.html中添加了标签，并在vue组件中渲染。依然还是上面那个样子，并没有对公式进行渲染显示。<br>index.html:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">id</span>=<span class="string">"MathJax-script"</span> <span class="attr">async</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br>xxx.vue：对question进行监视，内容改变后渲染界面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">      question: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">window</span>.MathJax.Hub.Queue([<span class="string">"Typeset"</span>, MathJax.Hub]);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>解决办法：</strong><br>&ensp;&ensp;&ensp;&ensp;原来由于被qiang的原因，MathJax官网给出的加速的CDN是国外的，速度慢的感人，因此看不到效果，因此换成了国内的（<a href="https://www.bootcdn.cn/mathjax/" target="_blank" rel="noopener">BootCDN</a> 等），由于好多CDN不提供该服务，终于找到一个可以用的。cloudflare的，如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">async</span> </span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br>然后终于显示出来了，如下图：<br><img src="https://img-blog.csdnimg.cn/20200228194914607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h3 id="问题2-行间公式不被渲染"><a href="#问题2-行间公式不被渲染" class="headerlink" title="问题2(行间公式不被渲染)"></a>问题2(行间公式不被渲染)</h3><p><strong>问题描述：</strong><br>&ensp;&ensp;&ensp;&ensp;看上图红框中的内容发现，还是有一部分行间公式没有被渲染，显示的依然是原来的状态。<br><strong>解决办法：</strong><br>&ensp;&ensp;&ensp;&ensp;仔细阅读<a href="https://docs.mathjax.org/en/latest/web/start.html" target="_blank" rel="noopener">MathJax使用文档</a> 发现，在MathJax的配置中说明了，如果想支持行间公司，需要做如下配置：注意2.x版本与3.x版本配置的书写方式不同，当然上面用的是2.7.5版本，因此就使用如下配置方式：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"</span>&gt;</span></span><br><span class="line">     MathJax.Hub.Config(&#123;</span><br><span class="line"><span class="actionscript">       tex2jax: &#123;inlineMath: [[<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">'\('</span>,<span class="string">'\)'</span>]]&#125;</span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这样上面那个问题完美解决，效果如下：<br><img src="https://img-blog.csdnimg.cn/20200228195801995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h2 id="四、未来的方向"><a href="#四、未来的方向" class="headerlink" title="四、未来的方向"></a>四、未来的方向</h2><p>原本很想使用3.0及以上版本的，奈何没找到合适的国内CDN加速，待高手评论区指点~~~</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MathJax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级</title>
      <link href="/2020/01/09/MySQL%E9%AB%98%E7%BA%A7/"/>
      <url>/2020/01/09/MySQL%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="一、架构"><a href="#一、架构" class="headerlink" title="一、架构"></a>一、架构</h2><p>​    <strong>MySQL采用分层结构设计，可在不同需求场景中利用不同的存储引擎，插件式的存储引擎架构将查询处理和其他的系统任务以及数据存储相分离。</strong> </p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced01.png" alt></p><h3 id="1-连接层"><a href="#1-连接层" class="headerlink" title="1. 连接层"></a>1. 连接层</h3><p>最上层是客户端和连接服务，包含本地的socket和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信，完成<strong>连接处理</strong>、<strong>授权认证</strong>等安全方案。连接层上引入了<strong>连接池</strong>，为通过安全认证的客户端提供线程，在该层可实现SSL安全连接，服务器还会对每个安全接入的客户端进行验证，赋予操作权限。</p><h3 id="2-服务层"><a href="#2-服务层" class="headerlink" title="2. 服务层"></a>2. 服务层</h3><p>完成大多数的核心服务功能，如SQL接口，完成缓存的查询，SQL的分析优化及内置函数的执行，跨存储引擎的功能实现也在该层，如过程、函数等。在这一层，服务器会解析查询，并创建相应的内部解析树，完成相应的优化，如查询表的顺序、是否利用索引、最后生成相应的执行操作，如果是select操作，服务器会查询内部缓存，如果缓存的空间足够大，在解决大量的读环境中能很好的提升性能。</p><h3 id="3-引擎层"><a href="#3-引擎层" class="headerlink" title="3. 引擎层"></a>3. 引擎层</h3><p>存储引擎实现了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通讯，不同的存储引擎的特性不同，可根据需求选取，主要用到的是MyISAM和InnoDB。</p><h3 id="4-存储层"><a href="#4-存储层" class="headerlink" title="4. 存储层"></a>4. 存储层</h3><p>将数据存储在裸设备的文件系统之上，并完成与存储引擎的交互。</p><h2 id="二、存储引擎"><a href="#二、存储引擎" class="headerlink" title="二、存储引擎"></a>二、存储引擎</h2><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced02.png" alt></p><h3 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1. InnoDB"></a>1. InnoDB</h3><p>​    默认的存储引擎，支持外键、事务，行锁（适合高并发），缓存索引和真实数据，对内存的要求高，内存的大小对性能有决定性影响，表的空间大，更关注于事务，安装时默认安装该存储引擎。</p><h3 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2. MyISAM"></a>2. MyISAM</h3><p>​    不支持外键、事务，采用表锁，在操作一条记录时也会锁住整张表，不适合并发场景，只缓存索引，不缓存真实数据。表空间小，更关注性能。安装时默认安装该存储引擎。</p><h3 id="3-Percona的XtraDB"><a href="#3-Percona的XtraDB" class="headerlink" title="3. Percona的XtraDB"></a>3. Percona的XtraDB</h3><p>​    Percona对MySQL进行了改进，使其在功能和性能上都有了很大的提升，使用XtraDB代替了InnoDB，在性能和并发上做的更好。阿里等公司使用该引擎，或进一步优化。</p><h2 id="三、-索引"><a href="#三、-索引" class="headerlink" title="三、 索引"></a>三、 索引</h2><ul><li>索引时帮助MySQL高效获取数据的<strong>数据结构</strong>，<strong>排好序的快速查找数据结构。</strong> </li><li>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构通过引用（指针）的方式引用数据，这样就可以在此数据结构的基础上实现高级算法，这种数据结构就是索引。</li><li>索引也是一张表，该表保存了主键与索引字段，并指向实体表记录。</li><li><strong>主键本身就是索引。</strong> </li></ul><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><ul><li><strong>Btree索引</strong> （常用）</li><li>Hash索引</li><li>full-text全文索引</li><li>R-Tree索引</li></ul><h3 id="①-数据结构"><a href="#①-数据结构" class="headerlink" title="① 数据结构"></a>① 数据结构</h3><h5 id="B树（多路搜索树）"><a href="#B树（多路搜索树）" class="headerlink" title="B树（多路搜索树）"></a>B树（多路搜索树）</h5><p>​    通常所说的索引</p><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>​    聚集索引、次要索引、复合索引、前缀索引、唯一索引</p><h3 id="②-优缺点"><a href="#②-优缺点" class="headerlink" title="② 优缺点"></a>② 优缺点</h3><ul><li>优点：<ul><li>提高数据的检索效率，降低数据库的IO成本</li><li>通过索引对数据进行排序，降低数据的排序成本，降低CPU的消耗</li></ul></li><li>缺点：<ul><li>索引也是一张表，会占用空间</li><li>对表进行insert update delete时不仅要保存数据，还要维护添加了索引的字段，会调整因为更新所带来的键值变化后的索引信息。</li></ul></li></ul><h3 id="③-索引分类"><a href="#③-索引分类" class="headerlink" title="③ 索引分类"></a>③ 索引分类</h3><h5 id="单值索引："><a href="#单值索引：" class="headerlink" title="单值索引："></a>单值索引：</h5><p>​    一个索引只包含单个列，一个表可以有多个单列索引</p><h5 id="唯一索引："><a href="#唯一索引：" class="headerlink" title="唯一索引："></a>唯一索引：</h5><p>​    索引<strong>列的值必须唯一</strong>，允许有空值</p><h5 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h5><p>​    一个索引包含了多个列</p><h3 id="④-基本语法"><a href="#④-基本语法" class="headerlink" title="④ 基本语法"></a>④ 基本语法</h3><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p><code>CREATE [UNIQUE] INDEX indexName ON tableName(columnName);</code></p><p><code>ALTER tableName ADD [UNIQUE] INDEX [indexName] ON(columnName);</code> </p><ul><li>加UNIQUE表示唯一索引</li><li>单值索引：一个字段   多值索引：多个字段</li></ul><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p><code>DROP INDEX [indexName] ON tableName;</code></p><h5 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h5><h3 id="②-注意点"><a href="#②-注意点" class="headerlink" title="② 注意点"></a>② 注意点</h3><ul><li>索引会影响到查找和ORDER BY 的排序</li><li>一般不实际删除表的数据，而是通过标志位（is_deleted）的形式使之无效，以此来维护索引的结构，避免查到一半查不到了，这种情况导致的查询变慢可通过重建索引来解决。</li><li>索引是提高效率的一个因素，需要根据点击数据不断的优化。</li><li>经常更新删除的数据不适合添加索引</li><li>一张表的索引最好不要超过5个</li></ul><h2 id="四、-索引与SQL"><a href="#四、-索引与SQL" class="headerlink" title="四、 索引与SQL"></a>四、 索引与SQL</h2><h3 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1. 创建索引"></a>1. 创建索引</h3><h4 id="①-单值索引"><a href="#①-单值索引" class="headerlink" title="① 单值索引"></a>① 单值索引</h4><p><code>create index idx_user_name on user(name);</code> </p><p><strong>索引命名</strong>：</p><ul><li>以idx 开头，接着是表名和创建索引的字段名</li><li>各部分以下环线分开，这样通过创建了索引的字段来查询就会很快。</li></ul><h4 id="②-复合索引"><a href="#②-复合索引" class="headerlink" title="② 复合索引"></a>② 复合索引</h4><p><code>create index idx_user_nameEmail on user(name,email);</code> </p><p><strong>索引命名：</strong> </p><ul><li>多个索引字段按小驼峰命名接在表名后</li></ul><h3 id="2-SQL性能下降"><a href="#2-SQL性能下降" class="headerlink" title="2. SQL性能下降"></a>2. SQL性能下降</h3><h4 id="①-性能下降原因"><a href="#①-性能下降原因" class="headerlink" title="① 性能下降原因"></a>① 性能下降原因</h4><p>​    主要时执行时间长或等待时间长，原因如下：</p><ul><li>查询语句写的不好</li><li>索引失效</li><li>多表关联查询，关联的表太多（设计缺陷或万不得已）</li><li>服务器调优和参数设置等问题</li></ul><h4 id="②-Join查询"><a href="#②-Join查询" class="headerlink" title="② Join查询"></a>② Join查询</h4><h3 id="3-SQL的执行顺序"><a href="#3-SQL的执行顺序" class="headerlink" title="3. SQL的执行顺序"></a>3. SQL的执行顺序</h3><ul><li><p>手写的SQL顺序</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced03.png" alt></p></li><li><p>MySQL内部的解析顺序</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced04.png" alt></p></li><li><p>执行的顺序</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced05.png" alt></p></li></ul><h3 id="4-常用SQL-JOINS"><a href="#4-常用SQL-JOINS" class="headerlink" title="4. 常用SQL JOINS"></a>4. 常用SQL JOINS</h3><ul><li>左连接(右连接同理)</li></ul><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced06.png" alt></p><ul><li><p>内连接</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced07.png" alt></p></li><li><p>左连接去重</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced08.png" alt></p></li><li><p>全连接(MySQL不支持)，通过union去重，连接左连接和右连接</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced09.png" alt></p></li></ul><h2 id="五、-创建索引-OR-不创建"><a href="#五、-创建索引-OR-不创建" class="headerlink" title="五、 创建索引 OR 不创建"></a>五、 创建索引 OR 不创建</h2><h3 id="1-需要创建索引的情况"><a href="#1-需要创建索引的情况" class="headerlink" title="1. 需要创建索引的情况"></a>1. 需要创建索引的情况</h3><ul><li>主键自动创建唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其他表关联的字段，外键关系建立索引，即作为外键的字段</li><li>单值、复合索引的选择（<strong>高并发下倾向创建复合索引</strong>）</li><li>查询中排序的字段（排序字段若通过索引去访问将大大提高排序速度）</li><li>查询中统计或分组字段</li></ul><h3 id="2-不需要创建索引"><a href="#2-不需要创建索引" class="headerlink" title="2. 不需要创建索引"></a>2. 不需要创建索引</h3><ul><li>频繁更新的字段不适合创建索引，（因为更新也要更新索引）</li><li>Where条件里用不到的字段不建索引</li><li>表记录太少（300万以内不用建）</li><li>重复且分布均匀的表字段不建索引，如果某个字段的重复内容过多（<strong>如性别、国籍等</strong>），为他建索引没有什么实际效果，反而增减了维护索引的成本。</li></ul><h3 id="3-索引的选择性"><a href="#3-索引的选择性" class="headerlink" title="3. 索引的选择性"></a>3. 索引的选择性</h3><p>​    <strong>索引的选择性</strong>表示索引列中不同值得数目与表中记录数的比，例如，表中有100条记录，索引列有99个不同的值，那么这个选择性就是99/100=0.99。选择性越接近1，这个索引的效率就越高。</p><h2 id="六、-性能分析"><a href="#六、-性能分析" class="headerlink" title="六、 性能分析"></a>六、 性能分析</h2><h3 id="1-MySQL-Query-Optimizer-查询优化器"><a href="#1-MySQL-Query-Optimizer-查询优化器" class="headerlink" title="1. MySQL Query Optimizer(查询优化器)"></a>1. MySQL Query Optimizer(查询优化器)</h3><ul><li>MySQL中有专门负责优化SELECT语句的优化器模块，该模块主要通过计算分析系统中手机的统计信息，为客户端请求的Query提供他人为最优的执行计划（但是他认为最优的检索方式不见得是DBA人为最优的）</li><li>当客户端向MySQL请求一条Ｑｕｅｒｙ时，命令解析器模块完成请求分类，区别出是SELECT并转发给MySQL Query Optimizer时，MySQL Query Optimizer首先对整条Query中的查询条件进行简化和转换，如去掉一些无用或者显而易见的条件、结构调整等，然后分析Query中的Hint信息（如果有）,看监视Hint信息是否可以完全确定Query的执行计划，如果没有Hint或Hint信息不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行谐响应的计算分析，然后得出最后的执行计划。</li></ul><h3 id="2-MySQL的常见瓶颈"><a href="#2-MySQL的常见瓶颈" class="headerlink" title="2. MySQL的常见瓶颈"></a>2. MySQL的常见瓶颈</h3><ul><li>CPU：CPU饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候</li><li>IO：磁盘的IO瓶颈发生在装入数据远大于内存容量的时候</li><li>服务器硬件的性能瓶颈：<strong>top，free，iostat，vmstat</strong>来查看系统的性能状态。</li></ul><h2 id="七、Explain（计划）"><a href="#七、Explain（计划）" class="headerlink" title="七、Explain（计划）"></a>七、Explain（计划）</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>​    使用Explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析查询语句或是表结构的性能瓶颈。</p><h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><ul><li>查看表的读取顺序（id，table字段）</li><li>展现数据读取操作的操作类型（select_type）</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h3><p>​    Explain + SQL语句，得到分析结果。</p><h4 id="①-包含信息"><a href="#①-包含信息" class="headerlink" title="① 包含信息"></a>① 包含信息</h4><p>原则：小表驱动大表。逐步调优，实现先加载小的，后加载大的。</p><h5 id="id："><a href="#id：" class="headerlink" title="*id："></a>*id：</h5><p>​    select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序，NULL最后执行。</p><ul><li>id相同，执行顺序由上至下（table字段）</li><li>id不同，如果是子查询，id的序列号会递增，id值越大，所对应的table字段的表越先执行。</li><li>id相同和不同：id值越大，优先级越高，越先执行，id相同的部分是一组，从上往下执行。</li></ul><p>注：table中的derivedx表示衍生表，x代表由谁执行后衍生的。</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced10.png" alt></p><h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><ul><li><p>SIMPLE</p><p>简单的select查询，查询中不包含子查询或UNION</p></li><li><p>PRIMARY</p><p>查询中若包含任何复杂的子部分时，最外层查询被标记为子查询（最后加载的那个）</p></li><li><p>SUBQUERY</p><p>在SELECT或WHERE列表中包含了子查询</p></li><li><p>DERIVED</p><p>在FROM列表中包含的子查询被标记为DERIVED（衍生表），MySQL会递归执行这些子查询，把结果放在临时表中。</p></li><li><p>UNION</p><p>若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为DERIVED</p></li><li><p>UNION RESULT</p><p>从UNION表获取结果的SELECT</p></li></ul><h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>​    关于哪一张表</p><h5 id="type"><a href="#type" class="headerlink" title="*type"></a>*type</h5><p>​    访问类型排列，显示了查询使用了哪种类型，从好到差的排列顺序为：<strong>systerm&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</strong> </p><p>注：ALL表示全表扫描，一般来说至少达到range级别，最好能达到ref。（<strong>达到百万级别的表才需要优化</strong>）</p><ul><li>systerm：表只有一行记录（等于系统表），是const类型的特例，平时不会出现，可忽略不计</li><li>const：表示通过索引一次就找到了，const用来比较<strong>primary key</strong>或<strong>unique</strong>索引，因为只匹配一行数据，所以很快，如果将主键至于WHERE列表中，MySQL就将该查询转换为一个常量。</li><li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描。（只有一条符合匹配）</li><li><strong>ref</strong>：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值得行，然而它可能会找到多个符合条件得行，所以它应该属于查找和扫描得混合体。（有多条符合匹配）</li><li><strong>range</strong>：只检索给定范围得行，使用一个索引来选择行，key列表显示了使用了哪些索引。一般就是在你得where语句中出现了between、&lt;、&gt;、in等得查询。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引得某一个点，而不用扫描全部索引。（如id大于多少、小于多少）</li><li><strong>index</strong>：Full Index Scan ，index于All的区别为index只遍历索引树。这通常要比ALL快，因为索引文件通常要比数据文件小。也就是说，虽然All和index都是读全表，但是index是从索引中读取的，而all是从硬盘中读取的。</li><li>all：全表扫描</li></ul><h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p>​    显示可能用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但在该查询中不一定被使用到</strong> </p><h5 id="key"><a href="#key" class="headerlink" title="*key"></a>*key</h5><p>​    表示实际使用到的索引，如果位NULL则表示没有使用索引</p><p>​    查询中若使用到了覆盖索引，则该索引仅出现在key列表中。（<strong>覆盖索引：</strong> select的数据列只用从索引中取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取文件，即<strong>查询列要被所建的索引覆盖</strong>。如下图：）</p><ul><li>如果用到覆盖索引，select列表中只取出需要的列，不可select*</li></ul><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced11.png" alt></p><h5 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h5><p>​    表示索引中使用的字节数，可通过该列计算查询中使用的索引长度，在不损失精度的情况下，长度越短越好。（在建了索引的前提下，查询条件越精确，key_len的值越大）</p><p>​    key_len显示的值为索引字段的最大可能长度，并非实际使用长度，该值是根据表定义计算得到，不是通过表内检索出来的。</p><h5 id="ref"><a href="#ref" class="headerlink" title="*ref"></a>*ref</h5><p>​    显示索引的哪一列被使用了（索引的具体引用情况），如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。格式为（库名.表名.字段名 或 const）</p><h5 id="rows"><a href="#rows" class="headerlink" title="*rows"></a>*rows</h5><p>​    表示每张表有多少行被优化器查询过（加起来越少越好）。</p><h5 id="Extra（重要）"><a href="#Extra（重要）" class="headerlink" title="Extra（重要）"></a>Extra（重要）</h5><p>​    包含不适合在其他列显示，但<strong>十分重要</strong>的额外信息。</p><p><strong>注意：</strong>要么不建索引，要么就按照索引的顺序去查，不然很容易产生文件内排序、临时表等问题。</p><ul><li><p><strong>Using filesort</strong>：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引排序进行读取，MySQL无法利用索引完成的排序操作称为“文件排序”，<strong>需要尽快优化</strong>。<strong>MySQL自己在内部产生了一次排序</strong>，会导致性能下降。因此尽可能的使用原本创建好的索引和索引的顺序。</p></li><li><p><strong>Using temporary</strong>：使用了临时表保存中间结果，MySQl在对中间结果排序时使用临时表，常见于排序order by 和分组查询 group by。（<strong>一定要赶紧优化，需要见表、删表、性能急速下降,如下图</strong>）</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced12.png" alt></p></li><li><p>Using index：</p><ul><li><p>表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。</p></li><li><p>如果同时出现using where ，表明索引被用来执行索引键值的查找</p></li><li>如果没有同时出现using where，表明索引用来读取；数据而非执行查找动作。</li></ul></li><li><p>Using where：表明使用了where过滤</p></li><li><p>Using join buffer：使用了连接缓存</p></li><li><p>impossible where：where子句的值总是false，不能用来获取任何元组</p></li><li><p>select tables optimized away（了解）：在没有GROUP BY 子句的情况下，基于索引优化MIN/MAX操作或者对于M有ISAM存储引擎优化COUNT（*）操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即可完成优化。</p></li><li><p>distinct（了解）：优化distinct操作，在找到第一匹配的元组胡即停止找同样值得动作。</p></li></ul><h2 id="八、索引优化"><a href="#八、索引优化" class="headerlink" title="八、索引优化"></a>八、索引优化</h2><h3 id="1-索引分析"><a href="#1-索引分析" class="headerlink" title="1. 索引分析"></a>1. 索引分析</h3><h4 id="①-单表"><a href="#①-单表" class="headerlink" title="① 单表"></a>① 单表</h4><p>​    范围需求字段建了索引以后，其后的索引会失效，降低效率。</p><h4 id="②-两表"><a href="#②-两表" class="headerlink" title="② 两表"></a>② 两表</h4><p>​    由左右连接的特性来决定，左连接则左表一定全要，从右表搜索，此时要在右表建立索引。</p><p>​    <strong>注：左连接加右表，右连接加左表，如果DBA已经建好索引，可以通过改变左右连接来提高效率。</strong> </p><h4 id="③-三表"><a href="#③-三表" class="headerlink" title="③ 三表"></a>③ 三表</h4><p>​    依然按照两表中的原则，索引最好设置在需要经常查询的字段中。</p><h4 id="④-结论"><a href="#④-结论" class="headerlink" title="④ 结论"></a>④ 结论</h4><ul><li>尽可能减少Join语句中的NestedLoop的循环总次数，永远用小表驱动大表。</li><li>优先优化NestedLoop的内层循环</li><li>保证Join语句中被驱动表上Join条件字段已经被索引</li><li>当无法把凭证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝啬JoinBuffer的设置。</li></ul><h3 id="2-索引失效"><a href="#2-索引失效" class="headerlink" title="2. 索引失效"></a>2. 索引失效</h3><h4 id="①-最好使用全值匹配"><a href="#①-最好使用全值匹配" class="headerlink" title="① 最好使用全值匹配"></a>① 最好使用全值匹配</h4><p>​    查询条件中直接用值匹配，如 name = “张三”</p><h4 id="②-最佳左前缀法则（重要）"><a href="#②-最佳左前缀法则（重要）" class="headerlink" title="② 最佳左前缀法则（重要）"></a>② 最佳左前缀法则（重要）</h4><p>​    如果索引中引入了多列，要遵守该原则，查询从索引的最左前列开始（如果顺序不同，没有跳过某个列，MySQL优化器会进行优化），并且<strong>不跳过索引中的列</strong>。</p><p>​    <strong>order by</strong> 如果不按照索引顺序，几乎都会产生文件排序。</p><p>​    <strong>group by</strong> 如果不按照索引顺序，几乎都会产生文件排序和临时表。group by 分组之前需要排序。</p><h4 id="③-不再索引上做任何操作"><a href="#③-不再索引上做任何操作" class="headerlink" title="③ 不再索引上做任何操作"></a>③ 不再索引上做任何操作</h4><p>​    在索引上做计算、函数、（自动或手动）类型转换，都会导致索引失效，转为全表扫描。</p><h4 id="④-范围条件右边不可用"><a href="#④-范围条件右边不可用" class="headerlink" title="④ 范围条件右边不可用"></a>④ 范围条件右边不可用</h4><p>​    存储引擎不能使用范围条件右边的列。如 pos = 1 and age &gt; 18 and name = “zhangsan”   此时，最后 name = “zhangsan”  就无法使用索引，但前面两个就能用到。</p><h4 id="⑤-使用覆盖索引"><a href="#⑤-使用覆盖索引" class="headerlink" title="⑤ 使用覆盖索引"></a>⑤ 使用覆盖索引</h4><p>​    尽量使用索引覆盖（只访问某些或全部索引列的查询），减少使用select *</p><h4 id="⑥-避免使用-和-lt-gt"><a href="#⑥-避免使用-和-lt-gt" class="headerlink" title="⑥ 避免使用 != 和 &lt;&gt;"></a>⑥ 避免使用 != 和 &lt;&gt;</h4><p>​    8.0版本进行了优化，但是还是range级别，Extra为 useing index condition。但是还是尽量避免使用。</p><p>举例：where name != “zhangsan”</p><h4 id="⑦-避免使用is-not-null"><a href="#⑦-避免使用is-not-null" class="headerlink" title="⑦ 避免使用is (not) null"></a>⑦ 避免使用is (not) null</h4><p>​    name is null；    <strong>可能在高版本会用到索引，待测</strong></p><h4 id="⑧-like以通配符开头"><a href="#⑧-like以通配符开头" class="headerlink" title="⑧ like以通配符开头"></a>⑧ like以通配符开头</h4><p>​    以通配符开头（’%abc‘）索引失效，导致全表扫描。</p><p>​    like 以百分号结尾，type 为 range，因此like “abc%” 后的也不能被用到索引。</p><p><strong>解决like “%字符串%” 时，索引不被使用的解决办法</strong></p><p>​    通过覆盖索引来解决问题，可以从ALL提升到index</p><h4 id="⑨-字符串不加单引号（重要）"><a href="#⑨-字符串不加单引号（重要）" class="headerlink" title="⑨ 字符串不加单引号（重要）"></a>⑨ 字符串不加单引号（重要）</h4><p>​    varchar类型的数据在进行匹配的时候，如果不加单引号，可能导致隐式的类型转换，如数字与字符串之间的转换，因此会导致索引失效。</p><h4 id="⑩少用or"><a href="#⑩少用or" class="headerlink" title="⑩少用or"></a>⑩少用or</h4><p>​    如： name = “zhangsan” OR name = “lisi”, 会导致索引失效。8.0以上可能是range。</p><h3 id="3-一般性建议"><a href="#3-一般性建议" class="headerlink" title="3. 一般性建议"></a>3. 一般性建议</h3><ul><li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好</li><li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where子句中更多字段的索引。</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。</li></ul><h2 id="九、-查询截取分析"><a href="#九、-查询截取分析" class="headerlink" title="九、 查询截取分析"></a>九、 查询截取分析</h2><h3 id="0-分析优化过程"><a href="#0-分析优化过程" class="headerlink" title="0. 分析优化过程"></a>0. 分析优化过程</h3><ul><li>观察，至少跑一天，看看生产中慢SQL的情况</li><li>开启慢查询日志，设置阈值，比如超过三秒的SQL语句，并抓取</li><li>explain + 慢SQL分析</li><li>show profile，查询SQL在MySQL服务器里面的执行细节和生命周期情况</li><li>DBA进行SQL数据库服务器的参数调优</li></ul><h3 id="1-查询优化"><a href="#1-查询优化" class="headerlink" title="1. 查询优化"></a>1. 查询优化</h3><h4 id="①-永远小表驱动大表"><a href="#①-永远小表驱动大表" class="headerlink" title="① 永远小表驱动大表"></a>① 永远小表驱动大表</h4><p>​    即小的数据集，驱动大的数据集，从而减少IO次数，</p><ul><li><p>B表的数据集小于A表时，用in优于exists</p></li><li><p>A表的数据集小于B表时，用exists优于in</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced13.png" alt></p></li></ul><h4 id="②-in和exists"><a href="#②-in和exists" class="headerlink" title="② in和exists"></a>② in和exists</h4><ul><li><p>EXISTS</p><p><code>SELECT ... FROM table WHERE EXISTS(subquery)</code> </p><p>将主拆线呢的数据，放到子查询中做条件验证，根据验证结果（true或false）来决定主查询的数据结果是否得以保留。</p></li><li><p>提示：</p><ul><li>EXISTS(subquery)只返回RTUE或FALSE，因此子查询中的SELECT *也可以是SELECT 1或SELECT ‘X’，官方说法是实际执行时会忽略SELECT清单，因此没区别</li><li>EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，可实际验证是否有效率问题</li><li>EXISTS子查询往往也可以用条件表达式、其他子查询或者JOIN来代替，何种最优需要具体问题具体分析。</li></ul></li></ul><h4 id="③-order-by关键字优化"><a href="#③-order-by关键字优化" class="headerlink" title="③ order by关键字优化"></a>③ order by关键字优化</h4><h5 id="最佳左前缀原则依然有效"><a href="#最佳左前缀原则依然有效" class="headerlink" title="最佳左前缀原则依然有效"></a>最佳左前缀原则依然有效</h5><ul><li>order by后所用的索引<strong>要按照创建的顺序，不能间断</strong>，否则会产生文件排序。跟前面的内容无关。</li><li>默认是升序，如果同时使用降序和升序，即使按照索引顺序，也会导致文件排序。除非所有索引都降序，且按照索引顺序，就不会产生文件排序。</li></ul><h5 id="filesort排序算法"><a href="#filesort排序算法" class="headerlink" title="filesort排序算法"></a>filesort排序算法</h5><ul><li>双路排序：MySQL4.1之前使用的是该算法，取一批数据需要进行两次扫描。</li><li>单路排序：4.1版本以后采用单路算法，一次读取，在buffer中排序，只用读一次，总体好于双路排序。</li><li>结论：单路排序可能会因为sort_buffer的太小产生多次IO，还不如双路排序，因此需要进行相应的配置。</li></ul><h5 id="提升性能方法"><a href="#提升性能方法" class="headerlink" title="提升性能方法"></a>提升性能方法</h5><ul><li><p>加order by 就尽量不要SELECT *，因为如果产生了filesort就会增加缓存，把sort_buffer_size给用满了，导致产生多次IO。</p></li><li><p>有filesort可尝试提高sort_buffer_size，根据系统能力去提高，该参数针对每个进程。</p></li><li><p>有filesort可尝试提高max_length_for_sort_data，太大，数据总量超过sort_buffer_size会导致高的磁盘IO和低的处理器利用率。</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced14.png" alt></p></li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><p>order能使用最左前缀索引</p></li><li><p>如果最左前缀为常量，order by也能使用索引</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced15.png" alt></p></li></ul><h4 id="④-group-by关键字优化"><a href="#④-group-by关键字优化" class="headerlink" title="④ group by关键字优化"></a>④ group by关键字优化</h4><p>​    group by 的实质是先排序后分组，遵照索引建的最佳左前缀，当无法使用索引列，增大sort_buffer_size 和 max_length_for_sort_data的参数设置，</p><p>​    where高于having ，因此能写在where里的条件就不要到having中去限制。</p><h3 id="2-慢查询日志"><a href="#2-慢查询日志" class="headerlink" title="2. 慢查询日志"></a>2. 慢查询日志</h3><h4 id="①-简介"><a href="#①-简介" class="headerlink" title="① 简介"></a>① 简介</h4><ul><li>MySQl的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值得SQL，则会记录在慢查询日志中。</li><li>long_query_time得默认值是10，即10秒钟</li></ul><h4 id="②-使用"><a href="#②-使用" class="headerlink" title="② 使用"></a>② 使用</h4><ul><li><p>默认MySQL数据库没有开启，需要我们手动得开启慢查询日志。非调优需要不建议开启，因为开启慢查询会多少对性能造成影响，慢查询日志支持将日志写入文件。</p></li><li><p>命令：</p><ul><li><code>SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</code>    查看是否开启及存储文件</li><li><code>set global show_query_log=1;</code>     开启慢查询（只对当前数据库有效，重启后就会失效）</li><li><code>set global long_query_time=3;</code>   设置阈值为3 （本库有效，重启无效，重开一个连接通过show才能查到）</li><li><code>SHOW global status like &#39;%Slow_queries%&#39;;</code>   查询日志的条数</li></ul></li><li><p>永久开启（不建议）</p><ul><li>修改my.cnf在[mysqld]下增加或修改参数</li><li>slow_query_log=1</li><li>slow_query_log_file=/var/lib/mysql/xxx.log   (缺省得文件名为主机+slow.log)</li><li>long_query_time = 3</li><li>log_output=FILE</li></ul></li><li><p>执行测试</p><p>可通过select sleep(5); 等方式来执行语句，这样如果阈值低于5秒得话，该语句会被记录。</p></li></ul><h4 id="③-分析工具"><a href="#③-分析工具" class="headerlink" title="③ 分析工具"></a>③ 分析工具</h4><p>​        在生产中，手工分析日志比较麻烦，因此MySQL提供了日志分析工具，<strong>mysqldumpslow</strong>。通过<code>mysqldumpslow --help</code> 查看如何使用，查询出相关数据</p><ul><li>s：按照何种方式排序</li><li>c：访问次数</li><li>l：锁定时间</li><li>r：返回记录</li><li>t：以查询总时间方式从大到小排序</li><li>al：平均锁定时间</li><li>ar：平均返回记录</li><li>at：平均查询时间</li><li>g：后面搭配正则表达式，大小写不敏感。</li></ul><h3 id="3-批量数据脚本"><a href="#3-批量数据脚本" class="headerlink" title="3. 批量数据脚本"></a>3. 批量数据脚本</h3><p>​    以插入1000W条数据为例</p><ul><li><p><code>set global log_bin_trust_function_creators=1;</code>   开启二进制方法创建</p><p>或在[mysqld] 下加上 log_bin_trust_function_creators=1</p></li><li><p>创建函数，保证每条数据都不同</p><ul><li><p>随机产生字符串</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced16.png" alt></p></li></ul></li></ul><ul><li><p>随机产生编号</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced17.png" alt></p></li></ul><ul><li><p>创建存储函数,一次插入批量数据，如几十万的数据(插入其他数据同理)</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced18.png" alt></p></li><li><p>调用</p><ul><li>DELIMITER ;     将结束符改为分号</li><li>CALL 函数名来调用</li></ul><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced19.png" alt></p></li></ul><h3 id="4-Show-Profile"><a href="#4-Show-Profile" class="headerlink" title="4. Show Profile"></a>4. Show Profile</h3><p><strong>简介：</strong></p><p>​    是mySQL提供的可以用来分析当前会话中语句执行的资源消耗情况，可以用于SQL的调优测量，默认是关闭状态，并保存最近15次的运行结果。</p><p><strong>命令：</strong></p><ul><li><p><code>show variables like &#39;profiling;&#39;</code>    查看是否开启</p></li><li><p><code>set profiling=on;</code>    打开profile</p></li><li><p><code>show profiles;</code>    查看执行过的SQL，包含执行时间和SQL语句、查询ID信息。</p></li><li><p><code>show profile cpu,block io for query 查询ID;</code>  列出上面某个查询的详细过程信息。一条SQL的完整生命周期。</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced21.png" alt></p></li><li><p><strong>结果中需要注意的点：</strong></p><ul><li>converting HEAP to MyISAM  查询结果太大，内存不够，需要往磁盘存储</li><li>Creating tmp table   创建了临时表（拷贝数据到临时表，用完再删）</li><li>Copying to tmp table on disk  把内存中临时表复制到磁盘，<strong>危险</strong></li><li>locked</li></ul></li><li><p>除了cpu block io还有其他的开销信息，如下表</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced20.png" alt></p></li></ul><h3 id="5-全局查询日志"><a href="#5-全局查询日志" class="headerlink" title="5. 全局查询日志"></a>5. 全局查询日志</h3><p>​    <strong>只能在测试环境用，不能在生产环境用。</strong> </p><h4 id="①-配置使用"><a href="#①-配置使用" class="headerlink" title="① 配置使用"></a>① 配置使用</h4><p>在my.cnf设置如下</p><ul><li>general_log=1    开启</li><li>general_log_file=/path/logfile    日志文件路径</li><li>log_output=FILE    输出格式</li></ul><h4 id="②-命令使用"><a href="#②-命令使用" class="headerlink" title="② 命令使用"></a>② 命令使用</h4><ul><li><code>set global general_log=1;</code> </li><li><code>set global log_output=&#39;TABLE&#39;;</code> </li><li>然后所编写的SQL语句会记录到mysql数据库里的general_log表</li><li><code>select * from mysql.general_log;</code> 查看该表的数据</li></ul><h2 id="八、-MySQL锁机制"><a href="#八、-MySQL锁机制" class="headerlink" title="八、 MySQL锁机制"></a>八、 MySQL锁机制</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>​    锁是计算机协调多个进程或线程并发访问某一资源的机制</p><p>​    在数据库中，除传统的CPU、RAM、IO等资源的征用以外，数据也是一种很多用户共享的资源，如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是并发访问性能的一个重要的因素，锁对于数据库尤为的重要，也更复杂。</p><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h3><ul><li>读锁（共享锁）：针对同一份数据，多个读操作可同时进行，互不影响</li><li>写锁（排他锁）：当前写操作未完成之前，会阻断其他的写锁和读锁。</li></ul><h3 id="3-表锁"><a href="#3-表锁" class="headerlink" title="3. 表锁"></a>3. 表锁</h3><p>​    偏向于<strong>MyISAM存储引擎</strong>，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发度低。</p><p><strong>MyISQM在执行select前会对所涉及的表加读锁，在执行增删改之前，会对涉及的表加写锁。</strong></p><h4 id="①-命令"><a href="#①-命令" class="headerlink" title="① 命令"></a>① 命令</h4><ul><li><code>show open tables;</code>    查看表上加过的锁，0未锁</li><li><code>lock table 表名 read(write);</code>    给表加读锁或者写锁</li><li><code>unlock tables;</code>    解除库中所有的锁</li></ul><p><strong>注意点（针对MyISAM引擎）：</strong></p><ul><li>加表的读锁以后，只能读该表，不能读其他表或写这个表，一定要解除了自己加的这个锁以后才能做其他操作。其他连接要进行写操作要被堵塞。</li><li>对表加写锁后，该连接可读、改自己锁的表，同样在没有解锁前不能操作其他表。其他表对该表查询和写同样阻塞。</li></ul><h4 id="②-表锁分析"><a href="#②-表锁分析" class="headerlink" title="② 表锁分析"></a>② 表锁分析</h4><p><code>show status like &#39;table%&#39;;</code>   可以查看表锁的情况，</p><ul><li>Table_locks_immediate：产生表锁的次数，表示可以立即获取锁的查询次数，每立即获取锁值加一</li><li>Table_locks_waited：出现表级锁定征用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值加一），此值高说明存在着严重的表级锁争用情况。</li></ul><p><strong>注意：</strong> MyISAM的读写锁调度是写优先，因此不适合作为写为主的情况，写锁后其他线程不能做任何操作，大量更新会使查询很难得到锁，从而造成永远阻塞。</p><h3 id="4-行锁"><a href="#4-行锁" class="headerlink" title="4. 行锁"></a>4. 行锁</h3><p>​    偏向于InnoDB引擎，开销大、加锁慢，会出现死锁，锁的粒度小，发生冲突的可能小，并发高。<strong>InnoDB支持事务，并采用了行锁。</strong> （复习事务的隔离级别，和数据库事务。） </p><h4 id="①-行锁变表锁"><a href="#①-行锁变表锁" class="headerlink" title="① 行锁变表锁"></a>① 行锁变表锁</h4><p>​    <strong>重要提示：</strong> 索引失效会导致行锁变表锁，常出现索引失效就是自动类型转换，即varchar数据不加单引号。这时操作数据会导致索引失效，操作过程所住整个表。</p><h4 id="②-间隙锁危害"><a href="#②-间隙锁危害" class="headerlink" title="② 间隙锁危害"></a>② 间隙锁危害</h4><p>​    当我们用范围条件而不是相等条件去检索数据的时候，并请求共享和排他锁时，InnoDB会给符合条件的已有数据的索引加索，对于键值在条件范围内但不存在的记录，叫做间隙（GAP）。</p><p>​    当锁定一个范围的键值以后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候，无法插入锁定范围内的任何数据</p><h4 id="③-优化分析"><a href="#③-优化分析" class="headerlink" title="③ 优化分析"></a>③ 优化分析</h4><ul><li><code>show status like &#39;innodb_row_lock&#39;;</code>    查看行锁的状态</li><li>innodb_row_lock_current_waits:  当前正在等待的锁的数量</li><li><strong>innodb_row_lock_time</strong>：  从系统锁定到现在锁定的总时间长度</li><li>innodb_row_lock_time_max： 从系统锁定到现在锁定最长的一次所花时间</li><li><strong>innodb_row_lock_time_avg</strong>：  从系统锁定到现在锁定的平均时长</li><li><strong>innodb_row_lock_waits</strong>：系统启动后到现在总共等待的次数</li></ul><h4 id="④-优化建议"><a href="#④-优化建议" class="headerlink" title="④ 优化建议"></a>④ 优化建议</h4><ul><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少检索条件，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可能低级别事务隔离。</li></ul><h2 id="九、-主从复制"><a href="#九、-主从复制" class="headerlink" title="九、 主从复制"></a>九、 主从复制</h2><h3 id="①-复制过程"><a href="#①-复制过程" class="headerlink" title="① 复制过程"></a>① 复制过程</h3><ul><li><p>master将干煸记录到二进制日志（binary log）中，这些日志叫做二进制日志事件，binary log events。</p></li><li><p>slave将master的binary log events拷贝到它的中继日志（relay log）</p></li><li><p>slave重做中继日志中的事件，将改变应用到自己的数据库中，MySQL复制是异步且串行化的。</p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/mysql/MySQLAdvanced22.png" alt></p></li></ul><h3 id="②-复制原则"><a href="#②-复制原则" class="headerlink" title="② 复制原则"></a>② 复制原则</h3><ul><li>每个slave只能有一个master</li><li>买个slave只能有一个唯一的服务器ID</li><li>每个master可以有多个slave</li></ul><h3 id="③-复制的最大问题"><a href="#③-复制的最大问题" class="headerlink" title="③ 复制的最大问题"></a>③ 复制的最大问题</h3><ul><li>延时</li></ul><h3 id="④-一主一从"><a href="#④-一主一从" class="headerlink" title="④ 一主一从"></a>④ 一主一从</h3><ul><li>MySQL版本一致，且以后台服务运行</li><li>主从配置在[mysqld]节点下，都是小写</li><li>主机和从机都要关闭防火墙 <code>service iptables stop</code> 关闭linux防火墙</li></ul><h5 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主服务器唯一ID[必须]</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 启用二进制日志[必须]</span></span><br><span class="line"><span class="meta">log-bin</span>=<span class="string">"本地路径/mysqlbin"</span></span><br><span class="line"><span class="comment"># 启用错误日志[可选]  主从复制不成功可以记录下来</span></span><br><span class="line"><span class="meta">log-err</span>=<span class="string">"本地路径/mysqlerr"</span></span><br><span class="line"><span class="comment"># 根目录[可选]</span></span><br><span class="line"><span class="attr">basedir</span>=<span class="string">"自己本地路径"</span></span><br><span class="line"><span class="comment"># 临时目录[可选]</span></span><br><span class="line"><span class="attr">tmpdir</span>=<span class="string">"自己本地路径"</span></span><br><span class="line"><span class="comment"># 数据目录[可选]</span></span><br><span class="line"><span class="attr">datadir</span>=<span class="string">"本机的目录/Data"</span></span><br><span class="line"><span class="comment"># 主机读写都可以</span></span><br><span class="line"><span class="meta">read-only</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 设置不需要复制的数据库（如mysql库）[可选]</span></span><br><span class="line"><span class="meta">binlog-ignore-db</span>=<span class="string">mysql</span></span><br><span class="line"><span class="comment"># 设置需要复制的数据库 [可选] 不写表示都复制</span></span><br><span class="line"><span class="meta">binlog-do-db</span>=<span class="string">需要复制的数据库名</span></span><br></pre></td></tr></table></figure><ul><li><p>在主机上给从机授权，登录后执行</p><p><code>GRANT REPLICATION SLAVE ON *.* TO &#39;用户名&#39; @‘从机IP’ IDENTIFIED BY &#39;密码&#39;;</code> </p></li><li><p><code>flush privileges;</code>   查询master的状态</p></li><li><p><code>show master status;</code>  查看主机二进制文件、复制和不复制的数据库信息</p></li></ul><h5 id="从机"><a href="#从机" class="headerlink" title="从机"></a>从机</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主服务器唯一ID[必须]</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">2</span></span><br><span class="line"><span class="comment"># 启用二进制日志[可选]</span></span><br><span class="line"><span class="meta">log-bin</span>=<span class="string">"本地路径/mysqlbin"</span></span><br></pre></td></tr></table></figure><ul><li><pre><code class="lang-shell">ChANGE MASTER TO MASTER_HOST=&#39;主机ip&#39;,MASTER_USER=&#39;用户名&#39;,MASTER_PASSWORD=&#39;密码&#39;,MASTER_LOG_FILE=&#39;mysql.具体数字&#39;, MASTER_LOG_POS=具体值;</code></pre><p>MASTER_LOG_FILE和MASTER_LOG_POS的值是在主机中通过<code>show master status</code> 查询到的。</p></li><li><p><code>start slave;</code>  重启服务，开启从服务器复制功能</p></li><li><p><code>show slave status\G</code>   以下两个参数都是yes说明配置成功</p><ul><li>Slave_IO_Running：Yes</li><li>Slave_SQL_Running：Yes</li></ul></li><li><p><code>stop slave;</code>    关闭复制，如果要重启，需要重新更改MASTER_LOG_FILE和MASTER_LOG_POS。</p></li></ul><h2 id="十、配置文件"><a href="#十、配置文件" class="headerlink" title="十、配置文件"></a>十、配置文件</h2><ul><li>log-bin    二进制日志，用于主从复制</li><li>log-error    错误日志，用于记录错误</li><li>log    查询日志，用于记录查询，当需要记录哪些SQL执行时间很慢时可以记录下来，用于优化</li><li><code>ls -lF|grep ^d</code>     进入容器后，查询创建的库的位置</li><li>数据文件<ul><li>frm文件    存放的数据库表结构</li><li>myd文件    存放的表数据</li><li>myi文件    存放的表索引 </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册-登录实现过程详解</title>
      <link href="/2020/01/02/%E6%B3%A8%E5%86%8C-%E7%99%BB%E5%BD%95-%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/01/02/%E6%B3%A8%E5%86%8C-%E7%99%BB%E5%BD%95-%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>&ensp;&ensp;&ensp;&ensp;一般的平台基本上都有用户管理这一部分，虽然我们都是各个平台的用户，对于一般的流程有所了解，看似简单，但是真正实现的过程中确遇到了很多的困难。</p><h2 id="二、实现过程图解"><a href="#二、实现过程图解" class="headerlink" title="二、实现过程图解"></a>二、实现过程图解</h2><h3 id="注册："><a href="#注册：" class="headerlink" title="注册："></a>注册：</h3><p><img src="https://img-blog.csdnimg.cn/20200123183013482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="90%" height="90%"><br>看似过程似乎很简单但是这过程还有很多需要考虑的因素，采取邮箱发送验证码的方式实现验证：</p><ol><li>验证码如何产生：<br> &ensp;&ensp;&ensp;&ensp;通常我们的验证码是0-9中的六个或者四个数字，因此需要循环产生四个或者六个随机数字。python版可参考：<a href="https://blog.csdn.net/CSDN_X_W/article/details/103844723" target="_blank" rel="noopener">使用Flask发送邮件</a></li><li>验证码保存到哪里？如何设置验证码的有效期？<br> &ensp;&ensp;&ensp;&ensp;验证码和用户邮箱是需要绑定存储到数据库用来后端验证的，而验证码是有有效期的，因此采用Redis来存储更为方便，在set数据时直接设置数据的有效期。当然也可以通过MySQL来实现。只是稍微繁琐些，但注册成功后的用户数据一般都是存储在MySQL中。</li><li>验证成功后，为了保证安全，用户名和密码等需要加密后存储到数据库<br>&ensp;&ensp;&ensp;&ensp;那么如何加密呢？加密算法有很多（对称、非对称、线性散列算法等），而用户的密码等信息是对安全度要求很高的信息，因此采用了SHA-1（线性散列加密的一种）加密。</li></ol><h3 id="登录："><a href="#登录：" class="headerlink" title="登录："></a>登录：</h3><p><img src="https://img-blog.csdnimg.cn/20200123201003163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="90%" height="90%"></p><ol><li>通常有些接口的访问都是有权限的，那么如何进行验证呢？<br>&ensp;&ensp;&ensp;&ensp;验证方式通常有cookie、session、token、JWT等，和加密方式一样，需要根据不同情况进行选择，在前后端分离中使用了JWT（Json Web Token），JWT使用公钥签名生成并保存到用户本地，减少了查询服务器的压力。</li><li>既然前端访问接口时需要携带jwt，那么jwt字符串存储在哪里呢？<br>因为每次访问某些接口时都需要携带jwt字符串，那么存储在哪里也是个问题，可以考虑的方式包括：cookie等（可根据场景选择），我选择的方式是localStrong方式来存储。</li></ol><p><strong>注：</strong> 各种加密算法的选择与对比、验证方式选择、jwt存储方式对比等仍需另外写博客完善。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 登录 </tag>
            
            <tag> 注册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu上使用Qt Creator编译、下载PX4代码</title>
      <link href="/2019/12/25/Ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8Qt-Creator%E7%BC%96%E8%AF%91%E3%80%81%E4%B8%8B%E8%BD%BDPX4%E4%BB%A3%E7%A0%81/"/>
      <url>/2019/12/25/Ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8Qt-Creator%E7%BC%96%E8%AF%91%E3%80%81%E4%B8%8B%E8%BD%BDPX4%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="一、创建工程文件"><a href="#一、创建工程文件" class="headerlink" title="一、创建工程文件"></a>一、创建工程文件</h2><p>在命令行执行以下几条命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/src/Firmware</span><br><span class="line">mkdir ../Firmware-build</span><br><span class="line">cd ../Firmware-build</span><br><span class="line">cmake ../Firmware -G "CodeBlocks - Unix Makefiles" -DCONFIG=nuttx_px4fmu-v2_default</span><br></pre></td></tr></table></figure><br><strong>注意：官方文档通常没有<code>-DCONFIG</code>这个参数或者参数就是上面的<code>nuttx_px4fmu-v2_default</code>，这个需要根据自己的板子来选择</strong>：比如我的板子是雷迅的Pixhawk v3x，使用的参数就是：<code>nuttx_px4fmu-v3_default</code>，另外作为开发PX4，个人不推荐这个板子，因为只能运行1.8.0或者1.8.1的版本，建议买V5 或 Pixhawk4。</p><h2 id="二、Qt-加载工程文件"><a href="#二、Qt-加载工程文件" class="headerlink" title="二、Qt 加载工程文件"></a>二、Qt 加载工程文件</h2><p>&ensp;&ensp;&ensp;&ensp;点击 Open Project，或者点击File -&gt; Open File or Project，选择在创建工程时Firmware目录下生成的 CMakeLists.txt文件。<br><img src="https://img-blog.csdnimg.cn/20200426173422735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"><br>&ensp;&ensp;&ensp;&ensp;加载后如下：<br><img src="https://img-blog.csdnimg.cn/2020042617375434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h2 id="三、工程的配置"><a href="#三、工程的配置" class="headerlink" title="三、工程的配置"></a>三、工程的配置</h2><p>&ensp;&ensp;&ensp;&ensp;没有配置的情况下是只能编译，不能通过Qt下载程序到飞控板的。点击左侧Projects，第一次进来的界面如下图：<br><img src="https://img-blog.csdnimg.cn/20200426174308289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"><br>&ensp;&ensp;&ensp;&ensp;点击Add按钮，选择<strong>Custom Executable</strong>添加一个用户可执行的运行配置，具体输入内容如下图：<br><img src="https://img-blog.csdnimg.cn/20200426175007591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h2 id="四、编译工程"><a href="#四、编译工程" class="headerlink" title="四、编译工程"></a>四、编译工程</h2><p>&ensp;&ensp;&ensp;&ensp;回到Edit菜单栏，点击左下角的锤子图标，对工程进行编译，编译成功后如下：<br><img src="https://img-blog.csdnimg.cn/20200426175412845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h2 id="五、下载程序"><a href="#五、下载程序" class="headerlink" title="五、下载程序"></a>五、下载程序</h2><p>&ensp;&ensp;&ensp;&ensp;<strong>在下载之前请确保已经完成了第三部对于工程的配置，并通过USB线连接飞控。</strong> 该过程会再次对代码进行编译，然后下载到飞控，当然下载的版本就是我们加载工程时所显示的v1.8.0，当然你可以在当初选择任何适用于你板子的版本，成功后如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200426180107251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h2 id="六、连接QGC验证"><a href="#六、连接QGC验证" class="headerlink" title="六、连接QGC验证"></a>六、连接QGC验证</h2><p>&ensp;&ensp;&ensp;&ensp;打开QGC连接飞控，可以查看到所下载的代码版本，如下图所示，如果是第一次使用需要对传感器、遥控器等进行校准。<br><img src="https://img-blog.csdnimg.cn/20200426180728497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 命令汇总</title>
      <link href="/2019/12/12/Docker%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
      <url>/2019/12/12/Docker%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<ol><li>attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像</li><li>build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像</li><li>commit    Create a new image from a container changes   # 提交当前容器为新的镜像</li><li>cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中</li><li>create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</li><li>diff      Inspect changes on a container’s filesystem   # 查看 docker 容器变化</li><li>events    Get real time events from the server          # 从 docker 服务获取容器实时事件</li><li>exec      Run a command in an existing container        # 在已存在的容器上运行命令</li><li>export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应</li><li>import ]history   Show the history of an image                  # 展示一个镜像形成历史</li><li>images    List images                                   # 列出系统当前镜像</li><li>import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</li><li>info      Display system-wide information               # 显示系统相关信息</li><li>inspect   Return low-level information on a container   # 查看容器详细信息</li><li>kill      Kill a running container                      # kill 指定 docker 容器</li><li>load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</li><li>login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器</li><li>logout    Log out from a Docker registry server          # 从当前 Docker registry 退出</li><li>logs      Fetch the logs of a container                 # 输出当前容器日志信息</li><li>port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口</li><li>pause     Pause all processes within a container        # 暂停容器</li><li>ps        List containers                               # 列出容器列表</li><li>pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像</li><li>push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器restart   Restart a running container                   # 重启运行的容器</li><li>rm        Remove one or more containers                 # 移除一个或者多个容器</li><li>rmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</li><li>run       Run a command in a new container              # 创建一个新的容器并运行一个命令</li><li>save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]</li><li>search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像</li><li>start     Start a stopped containers                    # 启动容器</li><li>stop      Stop a running containers                     # 停止容器</li><li>tag       Tag an image into a repository                # 给源中镜像打标签</li><li>top       Lookup the running processes of a container   # 查看容器中运行的进程信息</li><li>unpause   Unpause a paused container                    # 取消暂停容器</li><li>version   Show the docker version information           # 查看 docker 版本号</li><li>wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值 </li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 安装Docker</title>
      <link href="/2019/11/21/CentOS%E5%AE%89%E8%A3%85Docker/"/>
      <url>/2019/11/21/CentOS%E5%AE%89%E8%A3%85Docker/</url>
      
        <content type="html"><![CDATA[<p>1、centos系统的内核必须高于3.10<br>uname -r</p><p>2、yum 包更新到最新<br>yum update</p><p>3、卸载旧版本(如果安装过旧版本的话)<br>yum remove docker  docker-common docker-selinux docker-engine</p><p>4、安装需要的软件包<br>yum install -y yum-utils device-mapper-persistent-data lvm2</p><p>5、设置yum源<br>yum-config-manager —add-repo <a href="https://download.docker.com/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://download.docker.com/linux/centos/docker-ce.repo</a></p><p>6、安装最新版本的Docker<br>yum install docker-ce docker-ce-cli containerd.io</p><p>7、启动Docker并设置开机启动<br>systemctl start docker<br>systemctl enable docker</p><p>8、重启daemon并重启docker服务<br>systemctl daemon-reload<br>systemctl restart docker</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GitBook完成你的创作</title>
      <link href="/2019/11/04/%E4%BD%BF%E7%94%A8GitBook%E5%AE%8C%E6%88%90%E4%BD%A0%E7%9A%84%E5%86%99%E4%BD%9C/"/>
      <url>/2019/11/04/%E4%BD%BF%E7%94%A8GitBook%E5%AE%8C%E6%88%90%E4%BD%A0%E7%9A%84%E5%86%99%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是GitBook"><a href="#一、什么是GitBook" class="headerlink" title="一、什么是GitBook"></a>一、什么是GitBook</h2><p><strong>Document everything for you,your users and your team.</strong><br>&#8195;&#8195;GitBook并不是Git的教程，而是以Git作为版本控制系统，结合Github、Markdown用来写书（文档等）的工具。你可以在GitBook的网站、计算机本地上进行你的创作，GitBook帮你制作出精美的电子书籍，同时GitBook的网站对于写作和协同创作都有较好的支持。</p><h2 id="二、GitBook特点"><a href="#二、GitBook特点" class="headerlink" title="二、GitBook特点"></a>二、GitBook特点</h2><ol><li>凭借这个平台可以创建精美的个人笔记、说明文档、甚至是写书等…</li></ol><p><img src="https://img-blog.csdnimg.cn/20200115111556464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><ol><li>Markdown书写，简单方便</li><li><strong>多地同步：</strong> 文档与GitHub仓库绑定，本地创作Push到Github后可自动同步到GitBook并展示，在GitBook上创作后可一键提交到Github仓库。</li><li>可输出各种格式化文档，包括PDF、HTML、eBook等</li><li><strong>缺点：</strong> GitBook网页创作及查看书籍目前需要翻墙才可以使用。<br>……<h2 id="三、开始使用"><a href="#三、开始使用" class="headerlink" title="三、开始使用"></a>三、开始使用</h2><strong>前提：</strong> 默认你是拥有Git和Github的使用经验的</li><li>在Github上创建一个仓库，并克隆到本地</li><li>注册登录GitBook（通过Github账号登录，方便后期绑定仓库），创建一个新的Space</li></ol><p><img src="https://img-blog.csdnimg.cn/20200115114648213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><ol><li>进入到创建好的Book中，在左侧intergrations开启Github并绑定之前创建好的仓库</li></ol><p><img src="https://img-blog.csdnimg.cn/20200115115220228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><ol><li>因为GitBook是基于Node.js的工具，因此需要在计算机本地安装Node.js，可以在<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 下载并傻瓜式安装，安装完成后可以在命令行通过 <code>node -v</code> 和 <code>npm -v</code> 查看版本号</li></ol><p><img src="https://img-blog.csdnimg.cn/20200115114302945.png" width="60%" height="60%"></p><ol><li>在本地安装GitBook脚手架：<code>npm install gitbook-cli -g</code>  通过 <code>gitbook -V</code> 查看gitbook和CLI的版本。</li><li>在之前拉取的仓库目录下执行 <code>gitbook init</code> 来初始化书籍，这时由于已经有了原有仓库的README.dm  因此GitBook自带的README.md便不会再生成。成功后会包含如下三个文件夹：</li></ol><p><img src="https://img-blog.csdnimg.cn/20200115120133652.png" width="60%" height="60%"></p><p> 注：_book为自动生成的文件，SUMMARY.md为书籍的目录文件，这个需要按照一定格式来书写，很简单，以下分别表示一级、二级…目录，以此类推。括号内为与之绑定要显示的内容的文件</p><p> <img src="https://img-blog.csdnimg.cn/20200115120716178.png" width="60%" height="60%"></p><ol><li>运行 <code>gitbook serve</code> 即可在本地运行项目，并可以通过 访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 查看效果。</li><li>最后add commit push 项目到github 仓库，这时由于GitBook已经绑定了该仓库，因此，访问GitBook即可查看到最新的书籍状态。</li></ol>]]></content>
      
      
      <categories>
          
          <category> GitBook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2019/10/16/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/10/16/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="DBMS："><a href="#DBMS：" class="headerlink" title="DBMS："></a>DBMS：</h2><ol><li><p>DBMS：数据库管理系统</p><p>实际上数据库还是通过一套软件来管理文件中的数据。</p><ul><li>基于共享文件系统的DBMS  如access</li><li>基于客户机/<strong>服务器</strong>的DBMS： MySQL Oracle等</li></ul></li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>注：画五角星的要随时都可以写出来。</p><pre><code>一、为什么要学习数据库二、数据库的相关概念          DBMS、DB、SQL三、数据库存储数据的特点四、初始MySQL    MySQL的介绍            MySQL的安装          ★            MySQL服务的启动和停止     ★    MySQL服务的登录和退出     ★          MySQL的常见命令和语法规范      五、DQL语言的学习   ★                  基础查询        ★                 条件查询         ★                排序查询         ★                    常见函数        ★                   分组函数        ★                  分组查询           ★                连接查询         ★                子查询       √                      分页查询       ★                  union联合查询    √            六、DML语言的学习    ★                 插入语句                            修改语句                            删除语句                        七、DDL语言的学习      库和表的管理     √                    常见数据类型介绍  √              常见约束        √            八、TCL语言的学习    事务和事务处理                 九、视图的讲解           √十、变量                      十一、存储过程和函数   十二、流程控制结构       </code></pre><h2 id="一、数据库的好处"><a href="#一、数据库的好处" class="headerlink" title="一、数据库的好处"></a>一、数据库的好处</h2><p>​    1.持久化数据到本地<br>​    2.可以实现结构化查询，方便管理</p><h2 id="二、数据库相关概念"><a href="#二、数据库相关概念" class="headerlink" title="二、数据库相关概念"></a>二、数据库相关概念</h2><p>​    1、DB：数据库，保存一组有组织的数据的容器<br>​    2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据<br>​    3、SQL:结构化查询语言，用于和DBMS通信的语言</p><p>数据库存储数据的特点：</p><p>​    1、将数据放到表中，表再放到库中<br>​    2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。<br>​    3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。<br>​    4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”<br>​    5、表中的数据是按行存储的，每一行类似于java中的“对象”。</p><h2 id="三、MySQL的介绍和安装"><a href="#三、MySQL的介绍和安装" class="headerlink" title="三、MySQL的介绍和安装"></a>三、MySQL的介绍和安装</h2><h3 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h3><ol><li>进入MySQL容器 :<code>docker exec -it 容器ID /bin/bash</code></li><li>/etc/mysql/my.cnf  （需要安装vim打开 <code>apt-get install -y vim</code>）</li></ol><h3 id="Docker中操作"><a href="#Docker中操作" class="headerlink" title="Docker中操作"></a>Docker中操作</h3><p>进入容器后：</p><ol><li>登录MySQL：<code>mysql -u root -p</code></li><li>exit    退出MySQL </li></ol><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><pre><code>1.查看当前所有的数据库show databases;2.打开指定的库use 库名3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名(    列名 列类型,    列名 列类型，    。。。);6.查看表结构desc 表名;7.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V</code></pre><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><p>​    1.不区分大小写,但建议关键字大写，表名、列名小写<br>​    2.每条命令最好用分号结尾<br>​    3.每条命令根据需要，可以进行缩进 或换行<br>​    4.注释<br>​        单行注释：#注释文字<br>​        单行注释：— 注释文字<br>​        多行注释：/<em> 注释文字  </em>/<br>​    5.<code>name</code> 1旁白你的字符，表示着重符，当表中存在纯大写的字段时加上着重符，防止被认为是关键字</p><p>​<br>​    </p><h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><p>​    DQL（Data Query Language）：数据查询语言<br>​        select<br>​    DML(Data Manipulate Language):数据操作语言<br>​        insert 、update、delete<br>​    DDL（Data Define Languge）：数据定义语言<br>​        create、drop、alter<br>​    TCL（Transaction Control Language）：事务控制语言<br>​        commit、rollback</p><h3 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h3><pre><code>show databases； 查看所有的数据库use 库名； 打开指定 的库show tables ; 显示库中的所有表show tables from 库名;显示指定库中的所有表create table 表名(    字段名 字段类型,        字段名 字段类型); 创建表desc 表名; 查看指定表的结构select * from 表名;显示表中的所有数据</code></pre><h2 id="四、DQL语言的学习"><a href="#四、DQL语言的学习" class="headerlink" title="四、DQL语言的学习"></a>四、DQL语言的学习</h2><p><strong>Data Query Language</strong> </p><h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><p>​    语法：<br>​    SELECT 要查询的东西<br>​    【FROM 表名】;<br>​    </p><pre><code>类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</code></pre><ol><li>select 常量值；    并不是去库中查询，是支持这样的运算</li><li>select 表达式；    可以在要查询的东西中加入表达式</li><li>select 函数；    调用该函数，并得到函数的返回值</li><li>select name AS 名字 from account；    给查询的字段取一个别名。（为了在查询的字段中有重名时区分开来）住：AS可以不写 用空格代替，当别名中包含关键字时用双引号括起来。</li><li>select DISTINCT class_number from class;    在要查询的字段前加上 <strong>DISTINCT</strong> 去除重复的班级号</li><li>“+”    只是运算符，不会拼接字符串，<ul><li>select ‘abc’+123    不能转换成数值的字符串都会被认为是0。</li><li>select ‘123’+456      结果为579</li><li>select null+123      有null则结果永远为null</li><li><strong>注</strong> ：如果要将两个字段拼在一起查询用CONCAT函数，参考函数章节。</li></ul></li></ol><h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><pre><code>条件查询：根据条件过滤原始表的数据，查询到想要的数据语法：select     要查询的字段|表达式|常量值|函数from     表where     条件 ;分类：一、条件表达式    示例：salary&gt;10000    条件运算符：    &gt; &lt; &gt;= &lt;= = &lt;&gt; != 二、逻辑表达式示例：salary&gt;10000 &amp;&amp; salary&lt;20000逻辑运算符：    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false    or(||)：两个条件只要有一个成立，结果为true，否则为false    not(!)：如果条件成立，则not后为false，否则为true三、模糊查询     运算符：like、between and、in、is null、is not null    示例：last_name like &#39;a%&#39; </code></pre><p><strong>①.LIKE</strong> </p><ol><li>select <em> from account where name LIKE ‘%a%’ ;    表示名字中带有字母a的（注：<strong>通配符</strong>% ，表示任意多个字符，<em>*不区分大小写</em></em>）</li><li>select <em> from account where name LIKE ‘_a%’ ;    表示第二个字符为a的名字（<em>*通配符</em></em>下划线 表示任意单个字符）</li><li>转义字符，比如查询带有下划线时，同样是通过“\”来转义</li><li>自定义转义字符：select * from account where name LIKE ‘^_%’  ESCAPE ‘^’;    自定义”^” 为转义字符</li></ol><p><strong>②. BETWEEN AND</strong> </p><ol><li>select <em> from account where number BETWEEN 10 AND 20;    员工编号在10到 20之间。（使语法简洁，<em>*包含临界值</em></em>） </li><li>规则：大于等于左边，小于的等于右边的值，<strong>不能颠倒</strong>。</li></ol><p><strong>③. IN</strong> </p><ol><li>select * from account where type IN (‘assistant’, ‘teacher’);     查询用户类型为助教和老师的用户（避免写过多的或判断条件）</li><li>规则：IN 后（）中的内容类型应该相同，且括号中的内容不支持通配符。</li></ol><p><strong>④. is NULL</strong> </p><ol><li>select * from account where tel IS NOT NULL;    查询用户的tel信息为空（非空）的用户。</li><li>规则：=  和 &lt;&gt; 无法判断该栏是否为空，同样is也不能判断是否等于一个值。</li></ol><h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><pre><code>语法：select    要查询的东西from    表where     条件order by 排序的字段|表达式|函数|别名 【asc|desc】descend：降序  ascend：升序（可省略，加上order by 默认升序）</code></pre><ol><li>select salary*12 年薪 FROM employee ORDER BY 年薪 DESC；    可按照表达式排序</li><li>select salary FROM employee ORDER BY salary ASC，num DESC;    先按照员工的工资升序排列，工资一样的按工号降序排列。</li></ol><h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><ol><li>调用函数：select 函数名（实参列表） [from 表名]；</li><li>函数可以嵌套调用，某个函数的返回值可以作为另一个函数的参数。</li><li>MySQL中的<strong>索引都是从1开始</strong>的。</li><li>只有 LENGTH中是按照字节算，其余都按照字符算。</li></ol><p>一、<strong>单行函数</strong> </p><pre><code>1、字符函数    concat拼接        select CONCAT(lastname,firstname) 姓名 from 表名    substr截取子串        select SUBSTR(name,1,5)  从1开始截取截取3个长度字符长度（不是字节长度）。    upper转换成大写    lower转换成小写    trim去前后指定的空格和字符        默认去空格，去特殊字符需指定。        select TRIM（&#39;_&#39; FROM name）  去掉name字段前后的下划线。    ltrim去左边空格    rtrim去右边空格    replace替换    lpad左填充    rpad右填充    instr返回子串第一次出现的索引    length 获取字节个数2、数学函数    round 四舍五入        select ROUND(1.456,2)  小数点后保留两位四舍五入    rand 随机数        返回大于等于该数的最小整数    floor向下取整        返回小于等于该数的最小整数    ceil向上取整    mod取余        MOD(a,b) 结果返回的为   a-a/b*b    truncate截断3、日期函数    now当前系统日期+时间        SELECT YEAR(NOW()) 年   只获取日期中的年 还包括MONTH()、MONTHNAME()    curdate当前系统日期    curtime当前系统时间    str_to_date 将字符转换成日期    date_format将日期转换成字符4、流程控制函数    if 处理双分支    case语句 处理多分支        情况1：处理等值判断        情况2：处理条件判断5、其他函数    select version();    版本    select database();    当前库    select user();    当前连接用户</code></pre><ol><li><p>日期格式化输出 <strong>str_to_date</strong> </p><p>select DATA_FORMAT(NOW(),’%y年%月%日’)；</p></li></ol><div class="table-container"><table><thead><tr><th>序号</th><th>格式符</th><th>功能</th></tr></thead><tbody><tr><td>1</td><td>%Y</td><td>四位年份</td></tr><tr><td>2</td><td>%y</td><td>2位月份</td></tr><tr><td>3</td><td>%m</td><td>月份（01,02…11,12）</td></tr><tr><td>4</td><td>%c</td><td>月份（1,2…11,12）</td></tr><tr><td>5</td><td>%d</td><td>时（01,02…）</td></tr><tr><td>6</td><td>%H</td><td>小时（24小时制）</td></tr><tr><td>7</td><td>%h</td><td>小时（12小时制）</td></tr><tr><td>8</td><td>%i</td><td>分钟（01,02，…59）</td></tr><tr><td>9</td><td>%s</td><td>秒（00,01，…59）</td></tr></tbody></table></div><ol><li><p>流程控制函数</p><p>select IF(age&gt;35,’开除’, ‘不开除’) 状态 FROM account；    相当于三元运算符</p></li></ol><p>二、<strong>分组函数</strong>（又叫<strong>统计函数</strong>或<strong>聚合函数</strong>）</p><pre><code>    sum 求和（NULL不参与运算）    max 最大值（NULL不参与运算）    min 最小值（NULL不参与运算）    avg 平均值（NULL不参与运算）    count 计数（NULL不参与运算）    特点：    1、以上五个分组函数都忽略null值，除了count(*)    2、sum和avg一般用于处理数值型        max、min、count可以处理任何数据类型    3、都可以搭配distinct使用，用于统计去重后的结果    4、count的参数可以支持：        字段、*、常量值，一般放1       建议使用 count(*)  可查看有多少行（只要任意一个字段不为nUll就会被统计）</code></pre><ol><li>select OCUNT(DISTINCT person_type)    对类型去重后计数，其他函数也可以这样用，可以被 IN 等代替，因此用的较少。<strong>这里，子查询后执行，子查询在主查询结果中筛选，因此也叫相关子查询。</strong> </li><li><strong>和分组函数一起查询的字段要是GROUP BY 后的字段</strong>，其他不可以。不然会出现只查出一个的情况。</li></ol><h3 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h3><pre><code>语法：select 分组函数，查询的字段(要求出现在分组函数的后面)from 表where [筛选条件]group by 分组的字段[或者按函数结果分组]HAVING [筛选条件]    # 指上面分组后再筛选，支持别名判断</code></pre><p>​    特点：<br>​    1、可以按单个字段分组<br>​    2、和分组函数一同查询的字段最好是分组后的字段<br>​    3、分组筛选<br>​            针对的表    位置            关键字<br>​    分组前筛选：    原始表        group by的前面        where<br>​    分组后筛选：    分组后的结果集    group by的后面        having<br>​<br>​    4、可以按多个字段分组，字段之间用逗号隔开<br>​    5、可以支持排序<br>​    6、having后可以支持别名</p><p>​    select COUNT(*), name FROM account GROUP BY LENGTH(name)    按照函数的结果分组</p><h3 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h3><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件</code></pre><p>select boy_name, girl_name from boys, girls WHERE girls.boyfrend_id = boys.id;    查询每个男生的女朋友（当有多个查询条件是中间用AND连接）</p><p>一、传统模式下的连接 ：等值连接——非等值连接</p><pre><code>1.等值连接的结果 = 多个表的交集2.n表连接，至少需要n-1个连接条件3.多个表不分主次，没有顺序要求4.一般为表起别名，提高阅读性和性能</code></pre><p>二、sql99语法：通过join关键字实现连接</p><pre><code>含义：1999年推出的sql语法支持：等值连接、非等值连接 （内连接）外连接交叉连接语法：select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on  连接条件【inner|left outer|right outer|cross】join 表3 on  连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</code></pre><p><strong>外连接</strong>：一个表中有，一个表中没有的查询</p><p>如果从表中有匹配的值，则显示匹配的值，从表中没有则显示NULL</p><p>外连接结果=内连接结果 + 主表有而从表没有的记录</p><ul><li>主表：left join左边，right join 右边，的是主表</li><li>从表：</li></ul><p>连接类型：左外-&gt;left   右外-&gt;right   全外-&gt;full 三、自连接</p><p><strong>使用场景：</strong>查询员工名和直接上级的名称，当表中有该员工的领导id，但领导同时也是员工，也在这张表中的情况下使用。</p><p>sql99  （提高了可读性）</p><pre><code>SELECT e.last_name,m.last_nameFROM employees eJOIN employees m ON e.`manager_id`=m.`employee_id`;</code></pre><p>sql92</p><pre><code>SELECT e.last_name,m.last_nameFROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`;</code></pre><h2 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h2><p><strong>子查询出现的位置：</strong> （加黑为重要）</p><p>select后  ：仅支持标量子查询（结果集为一行一列）</p><p>from后 ：支持表子查询（查询结果为多行多列）</p><p><strong>where或having后</strong> ：支持<strong>标量子查询</strong>，<strong>列子查询</strong>（查询结果为一列多行）、行子查询（查询结果为一行多列）</p><p>exists后：支持表子查询</p><p>含义：</p><p>​    一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询<br>在外面的查询语句，称为主查询或外查询 </p><p>特点：</p><p>1、子查询都放在小括号内（<strong>结尾不要带分号</strong>）<br>2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧<br>3、子查询优先于主查询执行，主查询使用了子查询的执行结果<br>4、子查询根据查询结果的行数不同分为以下两类：<br>① 单行子查询<br>    结果集只有一行，一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;=<br>    非法使用子查询的情况：<br>    a、子查询的结果为一组值<br>    b、子查询的结果为空</p><p>② 多行子查询<br>    结果集有多行<br>    一般搭配多行操作符使用：any、all、in、not in<br>    in： 属于子查询结果中的任意一个就行<br>    any和all往往可以用其他查询代替</p><p><strong>exists：</strong> 只关心查询结果有还是没有，有的话返回为1，没有返回为0。</p><p>例如： select EXISTS(select id from account where id=1000)    r如果exist中的子查询语句结果存在，则返回1，否则返回0。</p><h2 id="进阶8：分页查询（重要、常用）"><a href="#进阶8：分页查询（重要、常用）" class="headerlink" title="进阶8：分页查询（重要、常用）"></a>进阶8：分页查询（重要、常用）</h2><p>应用场景：</p><pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</code></pre><p>语法：</p><pre><code>select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【offset，】size;offset:起始索引。size：要显示的条目数。</code></pre><p>特点：</p><ol><li><p><strong>起始条目索引从0开始</strong> </p></li><li><p>limit子句放在查询语句的最后</p></li><li><p>公式：select <em> from  表 limit （page-1）</em>sizePerPage,sizePerPage<br>假如:<br>每页显示条目数sizePerPage<br>要显示的页数 page</p></li></ol><h2 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h2><p>引入：<br>    union 联合、合并，将多个查询的结果联合成一个结果</p><p><strong>常用在在多个表中查询，多个表没有连接关系，但查询的信息一样，最后合并成一个结果</strong>：</p><p>select  * from china where sex=’男’</p><p>union </p><p>select* from american where sex=’male’</p><p>语法：</p><pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】union select 字段|常量|表达式|函数 【from 表】 【where 条件】 union .....select 字段|常量|表达式|函数 【from 表】 【where 条件】</code></pre><p><strong>特点：</strong> </p><p>1、多条查询语句的查询的<strong>列数必须是一致的</strong><br>2、多条查询语句的查询的<strong>列的类型几乎相同</strong>,顺序一致。<br>3、<strong>union代表去重，union all代表不去重</strong> </p><h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><p><strong>Data Manipulate Language</strong> </p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>语法一：(支持插入多行和子查询插入)<br>    insert into 表名 (字段名，…) values(值1，…);</p><p>​    插入多行的情况：insert into 表名(字段名，…) values(值1，…)， values(值1，…)， values(值1，…);</p><p><strong>子查询插入：</strong> 将查询的结果集插入。</p><p>例如：  insert into 表名 （id, name）</p><p>​            select id, name from 表名；</p><p>语法二：</p><p>​    insert into 表名</p><p>​    set 字段名=值, 字段名=值, 字段名=值,…;</p><p>特点：</p><p>1、字段类型和值类型<strong>一致或兼容</strong>，而且一一对应<br>2、可以为空的字段，可以不用插入值，或用null填充<br>3、不可以为空的字段，必须插入值<br>4、<strong>字段个数和值的个数必须一致</strong><br>5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</p><p>6、列的顺序可以颠倒，但是插入的值要与之一一对应。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改单表语法：</p><pre><code>update 表名 set 字段=新值,字段=新值【where 条件】</code></pre><p>修改多表语法：</p><pre><code>update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>方式1：delete语句 </p><p>单表的删除： ★<br>    delete from 表名 【where 筛选条件】</p><p>多表的删除：<br>    delete 别名1，别名2    # 这里可以写一个表，这样只删除一个表的数据<br>    from 表1 别名1，表2 别名2<br>    where 连接条件<br>    and 筛选条件;</p><p>方式2：truncate语句</p><pre><code>truncate table 表名</code></pre><p>两种方式的区别【<strong>面试题</strong>】</p><ol><li><p><strong>truncate不能加where条件，而delete可以加where条件</strong> </p></li><li><p><strong>truncate的效率高一丢丢</strong> </p></li><li><p><strong>truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始</strong> </p></li><li><p><strong>truncate删除不能回滚，delete删除可以回滚</strong></p></li></ol><h2 id="五、DDL语句"><a href="#五、DDL语句" class="headerlink" title="五、DDL语句"></a>五、DDL语句</h2><p><strong>Data Define Language</strong> </p><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><p>库的管理：</p><p>库名是不支持修改的。</p><pre><code>一、创建库create database 库名CREATE database IF NOT EXISTS 库名    有的话就不会再创建了二、删除库drop database 库名DROP DATABASE IF EXISTS 库名;    如果存在才删除三、修改库的字符集alter database 库名 CHARACTER SET utf8;   默认为utf8</code></pre><p>表的管理：<br>    1.创建表</p><pre><code>CREATE TABLE IF NOT EXISTS stuinfo(    stuId INT,    stuName VARCHAR(20),    gender CHAR,    bornDate DATETIME</code></pre><p>​    );<br>​<br>​    DESC studentinfo;    查看表结构</p><p>​    2.修改表 alter<br>​    语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;<br>​<br>​    ①修改字段名</p><p>​    ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;<br>​<br>​    ②修改表名</p><p>​    ALTER TABLE stuinfo RENAME [TO]  studentinfo;</p><p>​    ③修改字段类型和列级约束</p><p>​    ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;</p><p>​    ④添加字段</p><p>​    ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;</p><p>​    ⑤删除字段</p><p>​    ALTER TABLE studentinfo DROP COLUMN email;<br>​    #3.删除表<br>​    DROP TABLE [IF EXISTS] studentinfo;</p><p>​    </p><h4 id="复制表："><a href="#复制表：" class="headerlink" title="复制表："></a>复制表：</h4><ol><li><p>复制表的结构（数据不复制，仅复制表的结构）</p><p>CREATE TABLE 表名(要得到的表) LIKE 表名(被复制的表)</p></li><li><p>复制部分结构，加部分数据</p><p>CREATE TABLE 表名(要得到的表) </p><p>SELECT 字段1，字段2 FROM 表名(被复制的表)</p><p>WHERE 筛选条件；</p></li><li><p>仅复制表的部分结构（只需将筛选条件设为假）</p><p>CREATE TABLE 表名(要得到的表) </p><p>SELECT 字段1，字段2 FROM 表名(被复制的表)</p><p>WHERE 0；</p></li></ol><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><ol><li><p>数值型：</p><ul><li><p>整数型 ：tinyint 、smallint 、mediumint、 int/integer、bigint  </p><p> <strong>整数形括号内的数值表示长度，对数值范围没有影响，仅仅影响在数据库表中显示的长度，不够长度用0填充。</strong></p></li><li><p>小数型：</p><pre><code>浮点型：float（M,D）、double（M,D）  定点型：dec（M,D）保存精度更高时用。</code></pre><p>​        M: 总共的位数（等于小数点前的位数加上小数点后的位数）。</p><p>​        D: 小数点后的位数（多的四舍五入，少的补零）</p></li></ul></li><li><p>字符型：</p><p>|         | 写法       | M                     | 特点                        | 空间 | 效率 |<br>| ———- | ————— | ——————————- | —————————————- | —— | —— |<br>| char    | char(M)    | 最大字符数（0-255）   | 固定长度（M多大分配多大）   | 耗费 | 高   |<br>| varchar | varchar(M) | 最大字符数（0-65535） | 可变长度（小于M时按需分配） | 节省 | 低   |</p><p><strong>注意：</strong>char中M可以省略，默认为1，varchar中不能省略。</p><p><strong>如何选择</strong>：当固定字符数时用char,字符数不固定时用varchar。</p><p>|      |                   |      |      |      |      |<br>| —— | ————————- | —— | —— | —— | —— |<br>| enum | enum(‘a’,’b’,’c’) |      |      |      |      |<br>|      |                   |      |      |      |      |</p><p><strong>ENUM :</strong> 枚举类型，要求插入的值只能为列表中指定的值之一(每次插入一个值)。</p><p>​    eg：create table tab_enum ( e1 ENUM(‘a’,’b’,’c’) );</p><p>​            insert into tab_enum (e1) values(‘a’);</p><p>使用场景：适合于存储性别等这种有固定个数且只能唯一选择一个的。</p><p><strong>SET:</strong> 不同于枚举的是，允许插入多个。</p><p>​    eg：create table tab_set ( s1 ENUM(‘a’,’b’,’c’) );</p><p>​            insert into tab_set (s1) values(‘a,b’);</p><p><strong>注：</strong> ENUM 和SET 均不区分大小写。</p></li><li><p>日期型：</p><p>| 日期类型  | 内容       |<br>| ————- | ————— |<br>| date      | 日期       |<br>| time      | 时间       |<br>| year      | 年         |<br>| datetime  | 日期和时间 |<br>| timestamp | 日期和时间 |</p><p>注：datetime范围大，不受时区影响，timestamp受时区影响。</p><ul><li>设置时区：<code>set time_zone=+10:00</code> 设置为东十区 </li><li>查看当前时区：<code>show variables like &#39;time_zone&#39;</code> </li></ul></li><li><p>Blob类型：</p></li></ol><h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><ol><li><p>整型如果不设置，默认类型为有符号，</p><p>无符号需要在类型后加unsigned  如：create table tab (num INT UNSIGNED);</p></li><li><p>插入数据超出范围，会默认取临界值。</p></li><li><p>整数插入的数据的范围是由类型决定的，括号内的数值仅仅在位数不够该数值位，且设置了ZEROFILL时有用（很少用）。</p></li><li><p>不显示声明浮点中的M和D时，浮点型数据在范围内就可，而定点型默认为MD为10和 0。</p></li></ol><h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><p>约束：用于限制表中的数据，为了保证我们插入的数据的一致性。</p><p><code>SHOW INDEX FROM 表名</code>    可以查看当前表所添加的约束。</p><ol><li>NOT NULL：非空（NN）</li><li>DEFAULT：有默认值的字段</li><li>UNIQUE：唯一（UQ）</li><li>CHECK：检查约束，<strong>MySQL中不支持，但语法不报错。</strong></li><li>PRIMARY KEY：主键，非空、唯一（PK）</li><li>FOREIGN KEY：外键，用来限制两个表之间的关系，保证该字段的值必须是关联表中与之关联的列的值。</li></ol><p>注：</p><ul><li>AI：自增（auto increment）</li><li>UN：无符号的（unsigned）</li><li>B : 二进制（binary）</li><li>ZF：零填充（zero fill）</li></ul><p><strong>添加约束：</strong> 在创建或修改表时添加约束。添加位置如下：</p><p>CREATE TABLE 表名 （</p><p>​    字段名 类型 列级约束（如果多个列级约束则用空格分开），</p><p>​    字段名 类型 列级约束，</p><p>​    表级约束</p><p>）</p><p>表级约束内容：</p><p>约束类型（字段名）如：FOREIGN KEY(字段名) REFERENCES 表名(字段名)</p><p><strong>约束分类（重要）：</strong> </p><ul><li>列级约束：不支持在该位置添加外键约束</li><li>表级约束：不支持在该位置添加非空和默认值的约束。</li></ul><h4 id="修改时添加或删除约束"><a href="#修改时添加或删除约束" class="headerlink" title="修改时添加或删除约束"></a>修改时添加或删除约束</h4><ul><li>alter table 表名 MODIFY COLUMN 字段名 VARCHAR(10) NOT NULL;    列级约束写法</li><li>alter table 表名 ADD DEFAULT(字段) 20;    表级约束写法</li><li>添加外键：ALTER ATBLE 表1 ADD FOREING KEY(字段1) REFERENCES 表2(字段2)</li><li><strong>注：</strong> 删除约束时与添加数据时类似如：<ul><li>alter table 表名 MODIFY COLUMN 字段名 VARCHAR(10) NULL;    列级约束写法</li></ul></li></ul><h4 id="约束备注（面试）"><a href="#约束备注（面试）" class="headerlink" title="约束备注（面试）"></a>约束备注（面试）</h4><ol><li>主键和唯一键都支持组合键(不推荐这样设置)，如将多个字段组合设置为主键或者唯一键，这样即这多个字段不同时一样，就是合法的。如名字和身份证号组合为主键，但两个人的名字可能相同，也合法。</li><li>语法：  PRIMARY KEY(id,name)</li><li>外键：该表的外键必须是另一个表中的主键（常用）或者唯一键。插入数据时先插入到主表，再插入到从表，删除数据时，先删从表，再删主表。</li></ol><h3 id="TCL（Transaction-Control-Language）"><a href="#TCL（Transaction-Control-Language）" class="headerlink" title="TCL（Transaction Control Language）"></a>TCL（Transaction Control Language）</h3><h3 id="DCL-Data-Control-Langusge"><a href="#DCL-Data-Control-Langusge" class="headerlink" title="DCL (Data Control Langusge)"></a>DCL (Data Control Langusge)</h3><h2 id="六、数据库事务"><a href="#六、数据库事务" class="headerlink" title="六、数据库事务"></a>六、数据库事务</h2><p><strong>数据库引擎：</strong> 因为MySQL的存储引擎有很多，常用的是innodb，myisam，memory等，而这三个中只有innodb是支持事务的。</p><ul><li><code>show engines</code> 查看当前数据库使用的引擎</li></ul><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>​    通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>如果其中某条SQL语句执行失败，则会进行<strong>回滚</strong> ，即将之前执行的撤销，回到最开始的状态，所有语句都执行成功时，则事务被顺利执行。</p><pre><code>事务的特点：（ACID）原子性(Atomicity)：要么都执行，要么都回滚一致性(Consistency)：保证数据的状态操作前和操作后保持一致隔离性(Isolation)：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰持久性(Durablity)：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</code></pre><p>相关步骤：</p><pre><code>1、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务</code></pre><h3 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h3><p>隐式事务，没有明显的开启和结束事务的标志</p><pre><code>比如insert、update、delete语句本身就是一个事务</code></pre><p>显式事务，具有明显的开启和结束事务的标志</p><ol><li><p>开启事务<br>取消自动提交事务的功能</p><ul><li>查看自动提交是否开启：<code>show variables like &#39;autocommit&#39;;</code> </li><li>取消自动提交：<code>set autocommit=0;</code></li></ul></li><li><p>编写事务的一组逻辑操作单元（多条sql语句）<br>insert<br>update<br>delete</p></li><li><p>提交事务或回滚事务</p></li></ol><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>; <span class="comment"># 写不写这一句都可以</span></span><br><span class="line"><span class="comment"># 一堆SQL 语句</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p><strong>问题：</strong> 事务执行完以后（commit后），autocommit是否会再次变为打开的状态。（不会），但是一般不需要重新打开，因为关闭的自动提交只针对该连接有效，通常不会在一个程序代码中进行多次事务操作。</p><h3 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h3><pre><code>set autocommit=0;start transaction;commit;rollback; # 如果执行了回滚，则数据不会改变，即没有写到磁盘。savepoint  断点commit to 断点rollback to 断点</code></pre><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别:"></a>事务的隔离级别:</h3><p>事务并发问题如何发生？</p><pre><code>当多个事务同时操作同一个数据库的相同数据时</code></pre><p>事务的<strong>并发问题</strong>有哪些？</p><pre><code>脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据</code></pre><p>如何避免事务的并发问题？</p><p>隔离级别越高，则效率就越低。</p><pre><code>事务的隔离级别1、READ UNCOMMITTED  脏读、不可重复读和幻读均可能出现2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读</code></pre><p>设置隔离级别：</p><p><strong>注意：</strong> 每启动一个MySQL连接，该连接就会有一个全局变量@@tx_isolation 表示当前的隔离级别。</p><ol><li><p>设置数据库系统全局的隔离级别（重启后才有效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global  transaction isolation level 隔离级别名;</span><br></pre></td></tr></table></figure></li><li><p>设置当前连接的隔离级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level 隔离级别名;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注：</strong> 连接数据库的软件相当于开了一个连接。</p><p>查看隔离级别：</p><pre><code>select @@tx_isolation;</code></pre><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol><li><p>在事务中删除表时，delete 支持回滚，而truncate不支持回滚。</p></li><li><p>例如：TRUNCATE 后不支持回滚，数据还是会被删除。</p><ul><li><p>SET autocommit=0;</p><p>START TRANSACTION;</p><p>TRUNCATE TABLE 表名；</p><p>ROLLBACK;</p></li></ul></li></ol><h2 id="七、视图"><a href="#七、视图" class="headerlink" title="七、视图"></a>七、视图</h2><p><strong>疑问：</strong> 如果在创建视图后表有更新，那么下一次调用视图的查询是否会也跟着更新？</p><p>含义：理解成一张虚拟的表（MySQL 5.1之后版本的新特性）,行和列的数据来自定义视图的查询中所生成的表，在使用视图时动态生成，只保存了SQL逻辑，不保存查询内容。</p><p><strong>使用场景：</strong> </p><p>​    多个地方用到同样的查询结果，该查询结果使用的SQL语句较复杂时。</p><p><strong>视图和表的区别：</strong></p><p>由于视图和表基本完全相同，因此像表与视图连接的查询也是支持的。</p><pre><code>    使用方式    占用物理空间视图    完全相同    不占用，仅仅保存的是sql逻辑(一般不进行增删改）表    完全相同    占用</code></pre><p>视图的好处：</p><ol><li><p><strong>sql语句提高重用性</strong>，效率高</p></li><li><p>和表实现了分离，提高了安全性</p><p><strong>安全性:</strong> 可针对不同的用户设定不同的视图，比如我表中包含了很多其他的数据，有隐私型数据，但是我通过视图返回数据，这样就提高了安全性，视图中只包含了该用户想知道的数据。</p></li><li><p>对数据库重构，不影响程序的运行。</p></li></ol><h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><p>​    语法：<br>​    CREATE VIEW  视图名<br>​    AS<br>​    查询语句;</p><h3 id="视图的数据的增删改查（不建议这么做）"><a href="#视图的数据的增删改查（不建议这么做）" class="headerlink" title="视图的数据的增删改查（不建议这么做）"></a>视图的数据的增删改查（不建议这么做）</h3><p><strong>重要：</strong> 在视图中更删改数据后，那么原始的表也会跟着改变。</p><p>一般不对视图的数据进行增删改查，对视图设置权限，只允许读。</p><pre><code>1、查看视图的数据 ★SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name=&#39;Partners&#39;;2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);3、修改视图的数据UPDATE my_v4 SET last_name =&#39;梦姑&#39; WHERE last_name=&#39;虚竹&#39;;4、删除视图的数据DELETE FROM my_v4;</code></pre><h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><p>​    包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all<br>​    常量视图<br>​    Select中包含子查询<br>​    join<br>​    from一个不能更新的视图<br>​    where子句的子查询引用了from子句中的表</p><h3 id="视图SQL逻辑的更新"><a href="#视图SQL逻辑的更新" class="headerlink" title="视图SQL逻辑的更新"></a>视图SQL逻辑的更新</h3><p>​    1. 方式一：CREATE OR REPLACE VIEW 视图名 AS 查询语句<br>​        CREATE OR REPLACE VIEW test_v7<br>​        AS<br>​        SELECT last_name FROM employees<br>​        WHERE employee_id&gt;100;</p><pre><code>2. 方式二：ALTER VIEW 视图名 AS ；查询语句；ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7;</code></pre><h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><p>​    DROP VIEW test_v1,test_v2,test_v3;</p><h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><p>​    DESC test_v7;<br>​    SHOW CREATE VIEW test_v7;</p><h2 id="八、变量"><a href="#八、变量" class="headerlink" title="八、变量"></a>八、变量</h2><ol><li>系统变量：<ul><li>全局变量：由系统提供，针对整个MySQL服务器的变量，每次启动后赋予默认初值，更改后跨链接有效，跨重启无效。</li><li>会话变量：针对当前连接</li></ul></li><li>自定义变量：<ul><li>用户变量：针对该用户</li><li>局部变量：仅仅定义在begin end中有效（begin end中开始位置）</li></ul></li></ol><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><strong>系统变量：</strong> </p><p>默认为会话（session）级别，即session可以省略。</p><ol><li><code>show global|[session] variables;</code> 查看所有的系统变量</li><li><code>select @@global|[session].系统变量名;</code> 查看指定变量的值</li><li><code>set global|[session] 系统变量名=值;</code> 为某变量赋值</li></ol><p><strong>自定义变量：</strong></p><ol><li><code>SET @用户变量名:=值;</code> 声明并初始化用户变量，或对某用户变量赋予新的值。</li><li><code>SELECT 字段 INTO 用户变量名 FROM 表;</code> 将查询结果付给变量。要求查询结果为一个，而不是多个。</li><li><code>SELECT @用户变量名;</code> 查看用户变量</li><li><code>DECLARE 局部变量名 类型 [DEFAULT 值];</code> 声明局部变量（并赋初值。）</li><li><code>SET @局部变量名 :=值;</code> 为局部变量赋值</li><li><code>SELECT 局部变量名;</code> 查看局部变量的值</li></ol><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>含义：<strong>一组</strong>经过预先编译的sql语句的集合<br><strong>好处：</strong> </p><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率（减少了SQL语句的编译次数和跟数据库服务器连接的次数）3、减少了传输次数</code></pre><p>分类：</p><pre><code>1、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个</code></pre><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>应用：<strong>常用于增删改，涉及多条数据的增删改</strong>。 而<strong>函数</strong>用来做查询。</p><p>语法：</p><pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)begin    存储过程体end</code></pre><p>类似于方法：</p><pre><code>修饰符 返回类型 方法名(参数类型 参数名,...){    方法体;}</code></pre><p><strong>注意</strong> </p><ol><li><p>存储过程中每条存储语句中都要有<strong>分号</strong>。通过设置结束标志来判断什么时候结束。</p></li><li><p>设置完结束符以后，结束符就是设置的字符了，因此以后的SQL语句的结束符就是设置的字符，如果需要的话需要针对性再改。</p></li><li><p>设置的新的结束标记仅针对一次连接。</p><p> 1、需要设置新的结束标记<br> delimiter 新的结束标记<br> 示例：<br> delimiter $<br> set @name$  # 作为存储过程的返回值<br> CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,…)<br> BEGIN</p><pre><code> sql语句1; sql语句2;</code></pre><p> END $<br> SELECT @name$   # 查询返回值的内容。</p><p> 2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end</p><p> 3、参数前面的符号的意思<br> in:该参数只能作为输入 （该参数不能做返回值）<br> out：该参数只能作为输出（该参数只能做返回值）<br> inout：既能做输入又能做输出，重新赋值后，参数值就会发生改变。</p></li></ol><p>注：</p><ol><li>OUT参数的值在存储过程执行结束之后会自动返回。因此需要在内部将结果付给存储变量，在外部定义用户变量传入才能出过程调用时的参数，然后方便后面使用。</li></ol><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><pre><code>call 存储过程名(实参列表)</code></pre><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><p><code>DROP PROCEDURE 存储过程名;</code>  删除存储过程，只能一个一个删</p><h3 id="查案存储过程"><a href="#查案存储过程" class="headerlink" title="查案存储过程"></a>查案存储过程</h3><p><code>SHOW CREATE PROCEDURE 存储过程名;</code>  查看存储过程的信息</p><p>没有更新存储过程的命令。    </p><h2 id="九、函数"><a href="#九、函数" class="headerlink" title="九、函数"></a>九、函数</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>函数的特点与存储过程相同，</li><li>函数有且仅有一个返回值。</li><li>区别于存储过程，函数用于对查询的封装。</li></ol><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p><pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN    函数体END</code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>调用函数，并显示查询的结果。</p><pre><code>SELECT 函数名（实参列表）</code></pre><h3 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h3><pre><code>        关键字        调用语法    返回值            应用场景函数        FUNCTION    SELECT 函数()    只能是一个        一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程    PROCEDURE    CALL 存储过程()    可以有0个或多个        一般用于更新</code></pre><h2 id="十、流程控制结构"><a href="#十、流程控制结构" class="headerlink" title="十、流程控制结构"></a>十、流程控制结构</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>一、全局变量</p><p>作用域：针对于所有会话（连接）有效，但不能跨重启</p><pre><code>查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0;</code></pre><p>二、会话变量</p><p>作用域：针对于当前会话（连接）有效</p><pre><code>查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation=&#39;read-uncommitted&#39;;SET SESSION tx_isolation=&#39;read-committed&#39;;</code></pre><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>一、用户变量</p><p>声明并初始化：</p><pre><code>SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select @变量名;</code></pre><p>二、局部变量</p><p>声明：</p><pre><code>declare 变量名 类型 【default 值】;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select 变量名</code></pre><p>二者的区别：</p><pre><code>        作用域            定义位置        语法</code></pre><p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>一、if函数<br>    语法：if(条件，值1，值2)<br>    特点：可以用在任何位置</p><p>二、case语句</p><p>语法：</p><pre><code>情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</code></pre><p>特点：</p><pre><code>1. 可以用在任何位置 2. ELSE 可以省略 3. 满足条件后，执行THEN 后的语句，然后直接跳出。</code></pre><p>三、if elseif语句</p><p>语法：</p><pre><code>if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if;</code></pre><p>特点：<br>    只能用在begin end中！！！！！！！！！！！！！！！</p><p>三者比较：<br>            应用场合<br>    if函数        简单双分支<br>    case结构    等值判断 的多分支<br>    if结构        区间判断 的多分支</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p><pre><code>【标签：】WHILE 循环条件  DO    循环体END WHILE 【标签】;</code></pre><p>特点：</p><pre><code>只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装Docker（官方/阿里源）</title>
      <link href="/2019/10/15/Ubuntu%E5%AE%89%E8%A3%85Docker%EF%BC%88%E5%AE%98%E6%96%B9-%E9%98%BF%E9%87%8C%E6%BA%90%EF%BC%89/"/>
      <url>/2019/10/15/Ubuntu%E5%AE%89%E8%A3%85Docker%EF%BC%88%E5%AE%98%E6%96%B9-%E9%98%BF%E9%87%8C%E6%BA%90%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、为什么使用Docker"><a href="#一、为什么使用Docker" class="headerlink" title="一、为什么使用Docker"></a>一、为什么使用Docker</h2><p>&#8195;&#8195;构建后处处运行：Build Ship and Run Any App Anywhere<br>&#8195;&#8195;Docker解决了因为配置、环境等不同造成的项目部署后无法运行的问题，避免多台机器部署时的反复配置。相对于虚拟机来说，因为Docker使用的是宿主机的内核，具有轻量、占用资源少、启动快等特点，容器间相互隔离，不会相互影响。</p><h2 id="二、Ubuntu安装Docker"><a href="#二、Ubuntu安装Docker" class="headerlink" title="二、Ubuntu安装Docker"></a>二、Ubuntu安装Docker</h2><p>注：root用户下不需要sudo，官方和阿里的源选择其一，建议使用阿里源，速度快。</p><ol><li>安装必要的系统工具 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure></li><li>将Docker存储库添加到APT源：<br> ①. 官方源  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</span><br></pre></td></tr></table></figure> ②. 阿里源 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"</span><br></pre></td></tr></table></figure></li><li>将Docker存储库的GPG密钥添加到系统：<br> ①. 官方的GPG证书 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure> ②. 阿里的GPG证书 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li>确保从Docker repo 安装docker <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache policy docker-ce</span><br></pre></td></tr></table></figure></li><li>安装Docker(社区版) <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y docker-ce</span><br></pre></td></tr></table></figure></li><li>查看docker版本 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker -v</span><br></pre></td></tr></table></figure></li><li>启动Docker <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure><h2 id="三、配置阿里源"><a href="#三、配置阿里源" class="headerlink" title="三、配置阿里源"></a>三、配置阿里源</h2>&#8195;&#8195;由于从国外的网站拉镜像比较慢，因此国内如阿里云提供了容器镜像服务（如果不使用国内的镜像服务也没关系）。注册阿里云账号后，一般进入控制台/产品与服务/容器镜像服务/镜像加速器（第一次进入会让你设置一个Rigistry密码,这个密码当以后想上传镜像到阿里的docker仓库时会用到，类似于github，不过由于DockerHub太慢了）。然后就可以看到你的专属加速器地址和配置使用方法(<strong>根据系统按照操作文档中的命令运行即可（推荐），或者通过修改配置文件内容的方式</strong>)。如下图：<br><img src="https://img-blog.csdnimg.cn/20200105215657348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"><h2 id="四、查看所使用的源"><a href="#四、查看所使用的源" class="headerlink" title="四、查看所使用的源"></a>四、查看所使用的源</h2>注：命令最后是数字1，不是小写的L<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info|grep Mirrors -A 1</span><br></pre></td></tr></table></figure></li></ol><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask发送邮件</title>
      <link href="/2019/10/01/Flask-%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
      <url>/2019/10/01/Flask-%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是POP3、SMTP和IMAP"><a href="#一、什么是POP3、SMTP和IMAP" class="headerlink" title="一、什么是POP3、SMTP和IMAP?"></a>一、什么是POP3、SMTP和IMAP?</h1><p><a href="https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac22dc0e9af8168582a" target="_blank" rel="noopener">POP3、SMTP和IMAP</a></p><h1 id="二、开启邮箱的SMTP服务"><a href="#二、开启邮箱的SMTP服务" class="headerlink" title="二、开启邮箱的SMTP服务"></a>二、开启邮箱的SMTP服务</h1><p>以常用的<strong>网易邮箱</strong>为例(其他同理)：登录后进入常规设置</p><ol><li>选择POP3/SMTP/IMAP：开启如下两条服务,并注意到这里提示<strong>使用的是授权码登录第三方客户端，而非邮箱密码（有些邮箱使用的是密码而非授权码）</strong>。<br><img src="https://img-blog.csdnimg.cn/20200105164619496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></li><li>页面的最下方还有一个提示内容如下，这个也会在后面用到,有两个重要信息：</li></ol><ul><li>SMTP的服务器：smtp.163.com</li><li>安全支持：POP3/SMTP/IMAP服务是全部支持SSL连接的<br><img src="https://img-blog.csdnimg.cn/20200105165609472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></li></ul><ol><li>设置中选择 客户端授权密码 这一栏并选择开启，并记住这个授权码，开启后如下：<br><img src="https://img-blog.csdnimg.cn/20200105170144837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></li><li>网易邮箱的相关服务器信息：<br><img src="https://img-blog.csdnimg.cn/20200105171212581.png" width="80%" height="80%"><h1 id="三、Python-Flask框架发送邮件"><a href="#三、Python-Flask框架发送邮件" class="headerlink" title="三、Python Flask框架发送邮件"></a>三、Python Flask框架发送邮件</h1></li><li>安装依赖包：flask_mail<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask_mail</span><br></pre></td></tr></table></figure></li><li>这里假设一种情况，比如一般在注册一个网站时，会给用户发送验证邮件，这时我们用浏览器访问这个接口（<a href="http://localhost:5000/register）时就会发送对应的邮件到用户邮箱（当然省略了很多如生成验证码等内容）。" target="_blank" rel="noopener">http://localhost:5000/register）时就会发送对应的邮件到用户邮箱（当然省略了很多如生成验证码等内容）。</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_mail <span class="keyword">import</span> Mail, Message</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span><span class="params">(object)</span>:</span></span><br><span class="line">    DEBUG = <span class="literal">True</span></span><br><span class="line">    MAIL_SERVER = <span class="string">'smtp.163.com'</span> <span class="comment"># 邮件服务器地址</span></span><br><span class="line">    MAIL_PORT = <span class="string">'465'</span> <span class="comment"># SSL协议端口号</span></span><br><span class="line">    MAIL_USE_SSL = <span class="literal">True</span> <span class="comment"># 使用SSL加密</span></span><br><span class="line">    MAIL_USERNAME = <span class="string">'youremail@163.com'</span> <span class="comment"># 邮箱</span></span><br><span class="line">    MAIL_PASSWORD = <span class="string">'xxxxxxxx'</span> <span class="comment"># 授权码（某些邮箱是直接使用密码）</span></span><br><span class="line">app.config.from_object(Config)</span><br><span class="line"></span><br><span class="line">mail = Mail(app)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/register', strict_slashes = False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">()</span>:</span></span><br><span class="line">    msg = Message(<span class="string">'填写邮件标题'</span>, sender=<span class="string">'youremail@163.com'</span>, recipients=[<span class="string">'xxx@gmail.com'</span>, <span class="string">'xxx@qq.com'</span>])</span><br><span class="line">    msg.body = <span class="string">'邮件内容'</span></span><br><span class="line">    mail.send(msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'邮件发送成功！'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host = <span class="string">'0.0.0.0'</span>,port = <span class="number">5000</span>)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> 邮件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>E-R模型与E-R图</title>
      <link href="/2019/09/30/E-R%E6%A8%A1%E5%9E%8B%E4%B8%8EE-R%E5%9B%BE/"/>
      <url>/2019/09/30/E-R%E6%A8%A1%E5%9E%8B%E4%B8%8EE-R%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>用户需求分析-概念结构设计-ER图</p><p>自底向上方法设计，从中层开始下手，先设计局部ER图，集成再优化。</p><h2 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h2><ul><li>矩形：表示实体</li><li>菱形：关系</li><li>椭圆：属性</li><li>直线：属性与实体之间的从属关系，连接实体和联系</li><li>下划线：主码属性，表示唯一</li><li>双矩形：弱实体集</li><li>下划虚线：弱实体集的鉴别键</li></ul><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="复合属性"><a href="#复合属性" class="headerlink" title="复合属性"></a>复合属性</h3><p>​    如地址包含了省、市、街道、联系人信息，而联系人信息又包含了姓名、电话等。</p><h3 id="多元联系集"><a href="#多元联系集" class="headerlink" title="多元联系集"></a>多元联系集</h3><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/ERModle/ERModle01.png" alt></p><p><img src="https://beyonderwei-blog.oss-cn-shanghai.aliyuncs.com/article/ERModle/ERModle02.png" alt></p><h3 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h3><ul><li>强实体：有键的实体</li><li>弱实体：无键的实体称为弱实体（依赖于强实体而存在）</li><li>鉴别键（偏键）：弱实体区分各个实体的属性集合，弱实体集的主键由所依赖的强实体主键加上弱实体的鉴别键构成</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>不可分割</li><li>不能再由另一些属性组成</li><li>不能与其他实体具有联系</li><li>联系只能发生在实体之间</li><li>尽可能的定义为属性，这样联系少，清晰</li></ul>]]></content>
      
      
      <categories>
          
          <category> E-R图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> E-R图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础环境搭建</title>
      <link href="/2019/09/16/Python-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/09/16/Python-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Python-IDE"><a href="#一、Python-IDE" class="headerlink" title="一、Python IDE"></a>一、Python IDE</h1><ol><li>常用的很多，可根据自己的习惯去选择，以 Sublime Text3211为例（我安装时的最新版本）。</li><li>下载地址：<a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">http://www.sublimetext.com/3</a> （安装时勾选Add to explorer context menu选项）</li></ol><h1 id="二、Sublime-Text配置"><a href="#二、Sublime-Text配置" class="headerlink" title="二、Sublime Text配置"></a>二、Sublime Text配置</h1><ol><li><strong>安装Package Control 插件：</strong>（通过这个插件可以来管理其他软件） : 快捷键 Ctrl + Shift + P 输入 “install Package Control” 搜索，点击一下后稍等就会提示安装成功，然后重启软件。</li><li><strong>汉化软件：</strong> Preferrence -&gt; Package Control -&gt; 点击Package Control：Install Package -&gt; 在搜索框内输入 chinese -&gt; 点击 Chinese Localizations 即可。稍等片刻，安装成功，所有的界面会变成中文。</li><li><strong>更改Sublime Text字体：</strong> 由于汉化后对于中文的支持并不是很好（部分中文显示错误），需要在计算机内装一个新的字体来使用。字体下载地址：<a href="https://github.com/yakumioto/YaHei-Consolas-Hybrid-1.12" target="_blank" rel="noopener">https://github.com/yakumioto/YaHei-Consolas-Hybrid-1.12</a> 下载后安装即可。安装好后点击Sublime Text中的首选项 -&gt; 设置 -&gt; 填入如下内容：(第二行内容)<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line"> <span class="attr">"color_scheme":</span> <span class="string">"Packages/ayu/ayu-dark.sublime-color-scheme"</span><span class="string">,</span></span><br><span class="line"> <span class="attr">"font_face":</span> <span class="string">"YaHei Consolas Hybrid"</span><span class="string">,</span></span><br><span class="line"> <span class="attr">"font_size":</span> <span class="number">13</span><span class="string">,</span></span><br><span class="line"> <span class="attr">"ignored_packages":</span></span><br><span class="line"> <span class="string">[</span></span><br><span class="line">  <span class="string">"Vintage"</span></span><br><span class="line"> <span class="string">],</span></span><br><span class="line"> <span class="attr">"theme":</span> <span class="string">"ayu-light.sublime-theme"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>主题更改：</strong><br>&#8195;&#8195;①.首选项 -&gt; 主题 选择ayu-light-sublime-theme (这个更改的是软件外部的框，并没有包含编辑部分)<br>&#8195;&#8195;②. 首选项 -&gt; 配色方案 选择Monokai Color Scheme - Default(为了后面更改注释颜色) 效果如下图所示：（也可以根据喜好选择其他的）</li></ol><p><img src="https://img-blog.csdnimg.cn/20191002214101963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><ol><li>注释颜色更改：① Ctrl + Shift +P 搜索 PackageResourceViewer:Open Resource 点击进入 ② 再搜索Color Scheme -Default,点击进入 ③ 搜索Monokai.sublime-color-scheme 进入，在文件的颜色部分添加你想要的颜色，并在Comment 处更改为你想要的颜色。如下<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加颜色</span></span><br><span class="line"><span class="attr">"green":</span> <span class="string">"hsl(144, 100%, 39%)"</span><span class="string">,</span></span><br><span class="line"><span class="comment">#配置颜色</span></span><br><span class="line"><span class="attr">"rules":</span></span><br><span class="line">    <span class="string">[</span></span><br><span class="line">        <span class="string">&#123;</span></span><br><span class="line">            <span class="attr">"name":</span> <span class="string">"Comment"</span><span class="string">,</span></span><br><span class="line">            <span class="attr">"scope":</span> <span class="string">"comment"</span><span class="string">,</span></span><br><span class="line">            <span class="attr">"foreground":</span> <span class="string">"var(green)"</span></span><br><span class="line">        <span class="string">&#125;,</span></span><br><span class="line">    <span class="string">]</span></span><br></pre></td></tr></table></figure>效果如图：<br><img src="https://img-blog.csdnimg.cn/20191003172630999.png" width="60%" height="60%"></li></ol><h1 id="三、Python-解释器（CPython）安装"><a href="#三、Python-解释器（CPython）安装" class="headerlink" title="三、Python 解释器（CPython）安装"></a>三、Python 解释器（CPython）安装</h1><p>注：Python 各个版本之间不兼容，这里使用3。</p><ol><li>安装包下载地址：<a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a>  （选则最新的稳定发行版本即可）</li><li>安装时选择自定义安装，并勾选Add Python to enviroemnt variables 选项来将Python的安装路径添加到PATH环境变量中。</li><li>更改安装路径，因为Python的默认安装路径太深了。</li><li>在命令行输入python来验证安装情况。</li><li>与此同时也安装了 IDEL （Python 的交互界面，但是并不用它来写代码，可以做测试用）。<h1 id="四、Sublime-整合Python解释器"><a href="#四、Sublime-整合Python解释器" class="headerlink" title="四、Sublime 整合Python解释器"></a>四、Sublime 整合Python解释器</h1><strong>目的：</strong> 为了可以在Sublime中直接执行Python 代码，而不需要切换到 Python 的交互界面中去执行写好的Python 代码。</li><li>可直接在 Sublime 中按 CTRL + B 来执行。</li><li>安装使用SublimeREPL 来执行Python程序。<br>安装方法：首选项 -&gt; Package Control -&gt; 点击Package Control：Install Package -&gt; 在搜索框内输入SublimeREPL 点击安装。安装后即可通过 工具 -&gt; SublimeREPL  -&gt; Python -&gt; Python -RUN current file 来执行代码。但是这样很麻烦，因此可以配置快捷键(F8 可自行选择快捷键，保证与软件已有的快捷键不冲突即可)来执行。在首选项 -&gt; 快捷键设置 中添加如下代码：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[</span></span><br><span class="line"> <span class="string">&#123;</span> <span class="attr">"keys":</span> <span class="string">["f8"],</span> <span class="attr">"caption":</span></span><br><span class="line">  <span class="string">"SublimeREPL:Python"</span><span class="string">,"command":</span> </span><br><span class="line">  <span class="string">"run_existing_window_command"</span><span class="string">,</span> <span class="attr">"args":</span></span><br><span class="line">  <span class="string">&#123;"id":</span> <span class="string">"repl_python_run"</span><span class="string">,"file":"config/Python/Main.sublime-menu"&#125;&#125;,</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><h1 id="五、配置sublime的终端"><a href="#五、配置sublime的终端" class="headerlink" title="五、配置sublime的终端"></a>五、配置sublime的终端</h1></li><li>Ctrl + Shift +P 搜索 package install</li><li>搜索Terminal 并点击安装（等待安装好后会在首选项（）下找到Package setting-&gt;Terminal-&gt;Setting -&gt;User 并进入）</li><li>配置文件中填写如下内容并保存退出：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">路径</span></span><br><span class="line"><span class="attr">"terminal":</span> <span class="string">"C:\\MyAPP\\cmder\\Cmder.exe"</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span> <span class="string">参数</span></span><br><span class="line"><span class="attr">"parameters":</span> <span class="string">["/START",</span> <span class="string">"%CWD%"</span><span class="string">]</span></span><br></pre></td></tr></table></figure></li><li>这样就可以通过快捷键 ctrl+shift+T 直接打开终端，并处于当前文件所在的路径。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git提交代码书写多行日志</title>
      <link href="/2019/08/12/Git-%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E6%97%B6%E4%B9%A6%E5%86%99%E5%A4%9A%E8%A1%8C%E6%97%A5%E5%BF%97%EF%BC%88%E9%85%8D%E7%BD%AEGit-commit-template/"/>
      <url>/2019/08/12/Git-%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E6%97%B6%E4%B9%A6%E5%86%99%E5%A4%9A%E8%A1%8C%E6%97%A5%E5%BF%97%EF%BC%88%E9%85%8D%E7%BD%AEGit-commit-template/</url>
      
        <content type="html"><![CDATA[<h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><p>&#8195;&#8195;通常我们会采用git commit -m “提交日志” 的方式去提交代码，但是如果我们程序更改的地方很多，那就需要写更多的日志来记录，当我们查看log以后是下面这个样子：（当然也可以在github上去点击查看效果）<br><img src="https://img-blog.csdnimg.cn/20190719104541808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"><br>这样的提交日志就相对来说很清除，下面就来记录一下实现提交多行日志的方式。</p><h2 id="二、配置-Git-提交模板"><a href="#二、配置-Git-提交模板" class="headerlink" title="二、配置 Git 提交模板"></a>二、配置 Git 提交模板</h2><ol><li>在仓库的根目录下新建一个模板文件：如：git_commit_template.txt</li><li>git config commit.template git_commit_template.txt     &#8195;&#8195; <strong>#注意这里文件要加后缀名，该方式设置的是当前分支的提交模板</strong><br>git config —global commit.template git_commit_template.txt  &#8195;&#8195;  <strong>#设置的是全局的提交模板。</strong></li><li>git config —global core.editor vim  &#8195;&#8195; #设置模板的文本编辑器为vim,当然就需要我们在编写日志时会用简单的vim命令。</li><li>git commit  &#8195;&#8195; #当我们再次提交时直接执行git commit 命令时会进入下图所示的模板界面，我们就可以“任意”书写多行的提交日志了。<br>&#8195;&#8195;日志模板中会提示当前所处的分支和修改过的文件可以很方便我们去写提交日志。<strong>强烈建议使用Git Bash   因为windows的命令行下不支持中文的输入，同时命令行对于高亮的支持也不好。</strong><br><img src="https://img-blog.csdnimg.cn/20190719111809358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"><h2 id="三、日志模板书写格式"><a href="#三、日志模板书写格式" class="headerlink" title="三、日志模板书写格式"></a>三、日志模板书写格式</h2>&#8195;&#8195;当然我们可以写多行提交日志也不是随便的写，是有一些通用的格式的，下面部分从网上复制过来的常用的格式可以参考。<br>&#8195;&#8195;1. 常用格式：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;type&gt;(&lt;scope&gt;):</span> <span class="string">&lt;subject&gt;</span></span><br><span class="line"><span class="string">//</span> <span class="string">空一行</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">//</span> <span class="string">空一行</span></span><br><span class="line"><span class="string">&lt;footer&gt;</span></span><br></pre></td></tr></table></figure>&#8195;&#8195;2. 参数要求<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span></span><br><span class="line">feat：新功能（feature）</span><br><span class="line">fix：修补bug</span><br><span class="line">docs：文档（documentation）</span><br><span class="line">style： 格式（不影响代码运行的变动）</span><br><span class="line">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span><br><span class="line">test：增加测试</span><br><span class="line">chore：构建过程或辅助工具的变动</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Body 部分是对本次 commit 的详细描述，可以分成多行</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">可以根据自己的需要书写。如影响范围等。</span><br></pre></td></tr></table></figure><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2>&#8195;&#8195;1. 书写完以后保存退出即可，直接git push 即可。<br>&#8195;&#8195;2. 提交后可以通过git log  或直接去github 上点击查看效果。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过GPRS上传GPS数据到服务器</title>
      <link href="/2019/07/10/%E9%80%9A%E8%BF%87GPRS%E5%B0%86GPS%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/07/10/%E9%80%9A%E8%BF%87GPRS%E5%B0%86GPS%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h2><p>&#8195;&#8195;将GPS获取到的位置信息，通过GPRS将数据上传到服务器，当然也可以传输其他的信息，这样就可以实现对某些东西的时时定位，比如共享单车、汽车的定位等等。</p><h2 id="二、使用的器件"><a href="#二、使用的器件" class="headerlink" title="二、使用的器件"></a>二、使用的器件</h2><h3 id="1-GPRS模块和物联网卡"><a href="#1-GPRS模块和物联网卡" class="headerlink" title="1. GPRS模块和物联网卡"></a>1. GPRS模块和物联网卡</h3><p>&#8195;&#8195;①. GPRS模块使用的是有方的N10标准版，如下图：<br><img src="https://img-blog.csdnimg.cn/20190704091553351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"><br>&#8195;&#8195;②. 腾讯云上购买的移动卡，比自己买方便许多，腾讯还会提供后台管理和其他接口服务，续费什么的也很方便。如下图：<br><img src="https://img-blog.csdnimg.cn/20190704092310820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h3 id="2-GPS模块"><a href="#2-GPS模块" class="headerlink" title="2. GPS模块"></a>2. GPS模块</h3><p>&#8195;&#8195;使用的是中科微电子的ATGM332D 5N-31,如下图：<br><img src="https://img-blog.csdnimg.cn/20190704093646522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h3 id="3-MCU"><a href="#3-MCU" class="headerlink" title="3. MCU"></a>3. MCU</h3><p>&#8195;&#8195;我使用的是TI的TM4C123G，不同MCU基本没有区别，使用这个的原因就是比赛TI送了好多块，总得找个地方用吧，哈哈。</p><h2 id="三、电路连接"><a href="#三、电路连接" class="headerlink" title="三、电路连接"></a>三、电路连接</h2><p>&#8195;&#8195;因为要GPS和GPRS通信，所以需要两个UART，一个用来解析GPS返回的数据和打印数据到控制台调试，另一个则与GPRS通信，向GPRS发送数据和接收GPRS返回的数据。<br>&#8195;&#8195;GPS的TX &lt;————————————-&gt; UART0的RX<br>&#8195;&#8195;UART0的TX &lt;——————————-&gt; 串口模块的RX<br>&#8195;&#8195;GPRS的TX &lt;———————————-&gt; UART1的RX<br>&#8195;&#8195;GPRS的RX &lt;———————————-&gt; UART1的TX</p><h2 id="四、程序设计"><a href="#四、程序设计" class="headerlink" title="四、程序设计"></a>四、程序设计</h2><p>&#8195;&#8195;①. <strong>GPS数据解析：</strong> 根据返回的数据是否有效，有效的话则将数据更新存放GPS数据的结构体，卖家也有相应的例程作为参考，移植过来用就可以了。<br>&#8195;&#8195;②. <strong>GPS数据转化：</strong> 因为要将数据通过GPRS上传到服务器，通信协议采用HTTP，这就需要将有用的GPS数据转成Json格式，当然要使用cJson了，<strong>但是这里有个坑，创建cJson对象时涉及内存申请，需要去startup_TM4C123.s 文件中将堆改到合适的大小，但堆栈加起来不要超过RAM的大小。</strong> 如下图所示（这是我修改后的，不然每次创建对象时程序会直接卡死）：<br><img src="https://img-blog.csdnimg.cn/2019070410333030.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"><br>&#8195;&#8195;③. <strong>解析GPRS返回的数据：</strong> 因为每发一条命令后，要等待GPRS会返回不同的数据并进行判断，然后根据实际情况去进行相应的处理，对于返回结果包含特殊字串的可以直接通过strstr()来判断，如“OK”、“ERROR”、“&gt;”等。但实际测试中还是发现，连接几百上千次之后还是会掉入循环卡死，为了保持稳定性，索性直接写个看门狗，卡死强行复位程序。<br>&#8195;&#8195;④. <strong>看门狗部分：</strong> 因为程序执行周期(每完成一次连接，发送数据)，大概需要三秒多一点，看门狗的触发时间我设置的7秒，如果超过此时间没有喂狗，直接复位。（注：TM4C123G的WDT有二次触发特性）。最后实际测试了四个半小时，建立连接4000次左右，程序没有出现卡死现象。<br><img src="https://img-blog.csdnimg.cn/20190704110839589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"><br>&#8195;&#8195;⑤. 后台的程序就简单用SpringBoot写一下，用来测试。</p><h2 id="五、程序代码"><a href="#五、程序代码" class="headerlink" title="五、程序代码"></a>五、程序代码</h2><ol><li>获取方式：<br>①. github下载：<a href="https://github.com/Beyonderwei/GPS-positioning-system" target="_blank" rel="noopener">https://github.com/Beyonderwei/GPS-positioning-system</a><br>②. CSDN下载：<a href="https://download.csdn.net/download/csdn_x_w/11274960" target="_blank" rel="noopener">https://download.csdn.net/download/csdn_x_w/11274960</a></li><li>IDE：keil5  下载后直接全编译即可使用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPRS </tag>
            
            <tag> GPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4开发环境搭建（Ubuntu1804+QGC+Qt Creator ）</title>
      <link href="/2019/06/12/PX4%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88Ubuntu1804-QGC-Qt-Creator-%EF%BC%89/"/>
      <url>/2019/06/12/PX4%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88Ubuntu1804-QGC-Qt-Creator-%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在这之前作者完全没接触过PX4，安装过程遇到了很多坑，而且每安装下载一个东西都要等好久，出现问题又要重新开始，前后折腾了四天才弄好，希望此文对大家有所帮助。</p><h2 id="一、安装环境"><a href="#一、安装环境" class="headerlink" title="一、安装环境"></a>一、安装环境</h2><ol><li>操作系统：windows10</li><li>虚拟机：VMWare</li><li>Linux系统：Ubuntu1804 Desktop（官网推荐）</li><li>科学上网工具(f*q)：Shadowsocks</li></ol><p>备注：</p><ul><li>使用虚拟机而不使用双系统方式的原因在于环境不容易一次安装成功，虚拟机重装系统的话很方便。</li><li>教程中在下载项目中子模块的时候需要科学上网。（当然也提出了另一种加速方式，不过作者没有试验过）<h2 id="二、PX4环境搭建"><a href="#二、PX4环境搭建" class="headerlink" title="二、PX4环境搭建"></a>二、PX4环境搭建</h2><h3 id="1-在虚拟机中安装Ubuntu"><a href="#1-在虚拟机中安装Ubuntu" class="headerlink" title="1. 在虚拟机中安装Ubuntu"></a>1. 在虚拟机中安装Ubuntu</h3>安装过程就不细讲了，可以去找些教程，简单安装即可。</li></ul><ol><li>在电脑中安装VMware：<a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">VMware下载地址</a></li><li>下载Ubuntu1804系统的镜像：<a href="https://ubuntu.com/download/desktop" target="_blank" rel="noopener">Ubuntu镜像下载地址</a><br>注：①. 镜像应下载桌面版（<strong>Desktop</strong>）而非服务器版本（Server），可以通过种子下载也可直接下载，建议用迅雷加速下载。②. <strong>不需要换源</strong>，直接使用系统已有的就好。</li></ol><h3 id="2-安装PX4环境"><a href="#2-安装PX4环境" class="headerlink" title="2. 安装PX4环境"></a>2. 安装PX4环境</h3><p>&ensp;&ensp;&ensp;&ensp;安装过程只有<strong>两步</strong>，只要这两步<strong>没有任何错误</strong>。</p><p>&ensp;&ensp;&ensp;&ensp;参考教程：<a href="https://dev.px4.io/master/en/index.html" target="_blank" rel="noopener">官方教程首页</a>，链接是针对最新版本的代码的，当然搭建好以后也可以编译之前版本的代码，直接看英文的就完事了，中文的最新的可能会存在问题。</p><p>&ensp;&ensp;&ensp;&ensp;即使你可以科学上网，未必也能下载成功，<strong>强烈建议</strong>科学上网的情况下，<strong>早上六点到八点</strong>之间下载源码及安装工具链，<strong>正常情况下执行命令下载是不应该出现Faile和Err的。否则最终就可能出问题。</strong></p><h4 id="1-下载PX4源码："><a href="#1-下载PX4源码：" class="headerlink" title="(1)下载PX4源码："></a>(1)下载PX4源码：</h4><p>参考：<a href="https://dev.px4.io/master/en/setup/dev_env_linux_ubuntu.html" target="_blank" rel="noopener">官方文档</a></p><p>&ensp;&ensp;&ensp;&ensp;通过命令：<code>git clone https://github.com/PX4/Firmware.git --recursive</code> 克隆。克隆地址可以改成你的码云地址。如下：<br><img src="https://img-blog.csdnimg.cn/20200327163421203.png" alt="在这里插入图片描述"><br>①. 完整源码组成：完整的源码由PX4源码和其所需子模块，但是子模块的代码并没有在该仓库下，实际上 clone 时通过 <code>--recursive</code> 参数实现在其他仓库中拉取的。<br>②. 源码地址：<a href="https://github.com/PX4/Firmware" target="_blank" rel="noopener">PX4Github地址</a><br>③. 建议通过码云（国内的github）加速，就是在码云中新建自己的仓库，创建时选择从Github导入，这样相当于他给你做了加速下载这个过程，但是注意，<strong>其所需的子模块并没有实现加速。</strong>（我闲麻烦没有这样做：所有的所需 submodule子模块内容都可以通过修改 .gitmodules为国内码云上的地址来加速下载，当然就需要你为每一个子模块都在码云建一个仓库）</p><p>码云的仓库：<br><img src="https://img-blog.csdnimg.cn/20200327161608471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt><br>如果你采取全部通过码云加速的方式，需要修改如下位置（可以科学上网f*q的话不建议）：<br><img src="https://img-blog.csdnimg.cn/20200327161857574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-安装工具链"><a href="#2-安装工具链" class="headerlink" title="(2) 安装工具链"></a>(2) 安装工具链</h4><p><strong>重要</strong>：在这之前确保源码及其子模块都完整下载。<br>在Firmware目录下执行（建议早上8点前）：<code>bash ./Tools/setup/ubuntu.sh</code>，这个过程可能比较久，确保整个过程无错误，成功后最重要的就是已经安装了<strong>正确版本</strong>的arm-none-eabi-gcc，安装后执行<code>arm-none-eabi-gcc --version</code> 如下：<br><img src="https://img-blog.csdnimg.cn/20200327163909142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3-jMAVSim仿真"><a href="#3-jMAVSim仿真" class="headerlink" title="(3)  jMAVSim仿真"></a>(3)  jMAVSim仿真</h4><p>参考官方教程Firmware下去执行：<code>make px4_sitl jmavsim</code>，效果如下：<br><img src="https://img-blog.csdnimg.cn/20200327171019491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="4-编译验证"><a href="#4-编译验证" class="headerlink" title="(4) 编译验证"></a>(4) 编译验证</h4><p>根据你要编译的版本，在Firmware目录下执行<br><img src="https://img-blog.csdnimg.cn/20200327170525152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="三、安装QGC"><a href="#三、安装QGC" class="headerlink" title="三、安装QGC"></a>三、安装QGC</h2><p>官方文档：<a href="https://docs.qgroundcontrol.com/en/getting_started/download_and_install.html" target="_blank" rel="noopener">QGC安装教程</a>（建议点进来看看，因为我的所有内容都是按照官方教程写的）</p><p>1.按顺序执行以下命令  然后<strong>重启</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G dialout $USER</span><br><span class="line">sudo apt-get remove modemmanager -y</span><br><span class="line">sudo apt install gstreamer1.0-plugins-bad gstreamer1.0-libav -y</span><br></pre></td></tr></table></figure><br>2.下载QGC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;s3-us-west-2.amazonaws.com&#x2F;qgroundcontrol&#x2F;latest&#x2F;QGroundControl.AppImage</span><br></pre></td></tr></table></figure><br>3.安装<br><code>chmod +x ./QGroundControl.AppImage</code></p><p>4.运行</p><ul><li>通过命令运行<code>./QGroundControl.AppImage</code></li><li>或者双击图标：<br><img src="https://img-blog.csdnimg.cn/2020032716560175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="四、安装Qt-Creator"><a href="#四、安装Qt-Creator" class="headerlink" title="四、安装Qt Creator"></a>四、安装Qt Creator</h2></li></ul><ol><li>更新源：<code>sudo apt-get update</code></li><li>用户目录下直接执行 <code>sudo apt-get install qtcreator</code> </li><li>在应用内找打图标运行就OK<br><img src="https://img-blog.csdnimg.cn/20200327170204463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过QT Creator开发，照着文档做就好<br><img src="https://img-blog.csdnimg.cn/2020032717122713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4开发基础</title>
      <link href="/2019/05/07/PX4%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/05/07/PX4%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一、与无人机的缘分"><a href="#一、与无人机的缘分" class="headerlink" title="一、与无人机的缘分"></a>一、与无人机的缘分</h2><p>&ensp;&ensp;&ensp;&ensp;做无人机是源于<strong>电赛</strong>，因为对无人机比较发烧就分到了无人机的组里，参加的三次电赛两次是做的无人机的题目，虽然后来不再做该方向的，但也算我的一项爱好吧，加上现在毕设是给老师搭建一个<strong>PX4</strong>的平台（比赛没用过PX4），因为无人机开发比较小众，价格贵、学习环境少并具有一定难度，外加发展的时间并不是很长，开发中就遇到了很多问题，在此做一些记录。</p><h2 id="二、开发前"><a href="#二、开发前" class="headerlink" title="二、开发前"></a>二、开发前</h2><p>&ensp;&ensp;&ensp;&ensp;这套开源软件的功能相当的齐全，实际上通过烧录PX4的固件，通过地面站的设置，就可以实现<strong>很多</strong>功能了，因此决定了你是否需要涉及到源码层面的开发。</p><h2 id="三、背景知识"><a href="#三、背景知识" class="headerlink" title="三、背景知识"></a>三、背景知识</h2><p>注：内容来自于一些资料和自我总结</p><h3 id="硬件PIXHAWK"><a href="#硬件PIXHAWK" class="headerlink" title="硬件PIXHAWK"></a>硬件PIXHAWK</h3><p>&ensp;&ensp;&ensp;&ensp;Pixhawk是第一款专门为PX4自驾软件而设计的无人机飞控。Pixhawk飞控是开源硬件架构，pixhawk系列”的板子在NuttX操作系统上运行PX4。全世界很多公司出品了基于Pixhawk的飞控产品。他们都有共同的硬件架构和相同的连接方式、输出接口及功能，仅仅是具体形式不同而已，例如接口的位置不同、外壳不同等等。</p><h5 id="pixhawkV1："><a href="#pixhawkV1：" class="headerlink" title="pixhawkV1："></a>pixhawkV1：</h5><p>&ensp;&ensp;&ensp;&ensp;第一版飞控，也被称作FMUv1,它包含PX4FMU和PX4IO两部分。PX4FMU是Pixhawk v1飞控的核心控制部分，主要负责姿态解算等等算法的执行；PX4IO主要负责飞控各外设接口的管理。下面的样子（市面已经看不到了）：<br><img src="https://img-blog.csdnimg.cn/20200326214821478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"></p><h5 id="pixhawkV2："><a href="#pixhawkV2：" class="headerlink" title="pixhawkV2："></a>pixhawkV2：</h5><p>&ensp;&ensp;&ensp;&ensp;继FMUv1飞控之后，第二代飞控被称为Pixhawk v2或FMUv2。在FMUv2这个版本飞控中，第一代中的PX4FMU和PX4IO被合并到了一个PCB上，成为了真正的一体化飞控。（市面还有很多卖的主要都是在这个基础上改进优化，比如处理器、传感器等的提升）<br><img src="https://img-blog.csdnimg.cn/2020032621510640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"></p><h5 id="pixhawkV3x："><a href="#pixhawkV3x：" class="headerlink" title="pixhawkV3x："></a>pixhawkV3x：</h5><p>&ensp;&ensp;&ensp;&ensp;比如我用的是如下的雷迅生产的V3x，到现在甚至已经出了到了<strong>V5</strong>，但是主要没有差太多。</p><p><img src="https://img-blog.csdnimg.cn/20200326215221385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"></p><h3 id="软件代码"><a href="#软件代码" class="headerlink" title="软件代码"></a>软件代码</h3><h5 id="ArduPilot"><a href="#ArduPilot" class="headerlink" title="ArduPilot"></a>ArduPilot</h5><p>&ensp;&ensp;&ensp;&ensp;APM固件程序比较<strong>混乱，零散</strong>。维护者多，代码风格不太统一，而且是单片机这种调用程序，<strong>不好入门。但是成熟稳定</strong>，支持硬件多。APM固件有ArduCopter社区支撑。</p><h5 id="PX4（推荐）"><a href="#PX4（推荐）" class="headerlink" title="PX4（推荐）"></a>PX4（推荐）</h5><p>&ensp;&ensp;&ensp;&ensp;PX4固件，在<strong>nuttx</strong>嵌入式<strong>实时操作系统</strong>上运行。采用多任务，模块化设计。相对来说方便入门，代码风格比较统一。PX4的是BSD协议，BSD协议可以将开源软件<strong>二次开发后用作商业用途。</strong> 着=这也就是当前很多公司的产品甚至就是直接在这个上面改装的。</p><h3 id="地面站（GCS）"><a href="#地面站（GCS）" class="headerlink" title="地面站（GCS）"></a>地面站（GCS）</h3><h5 id="Mission-Planner（MP）"><a href="#Mission-Planner（MP）" class="headerlink" title="Mission Planner（MP）"></a>Mission Planner（MP）</h5><p>&ensp;&ensp;&ensp;&ensp;支持Mavlink协议，一般用于APM的代码，当前使用的人比较多（截至到2020年之前），不支持Mac OS</p><h5 id="QGroundControl（QGC）"><a href="#QGroundControl（QGC）" class="headerlink" title="QGroundControl（QGC）"></a>QGroundControl（QGC）</h5><p>&ensp;&ensp;&ensp;&ensp;支持Mavlink协议，一般用于PX4代码，使用的人较少（<strong>未来趋势</strong>），PX4官方推荐的地面站软件。</p><ul><li>手机系统: Android 和 iOS (目前专注于平板电脑)</li><li>桌面系统: Windows, Linux, Mac OS</li></ul><h2 id="四、我的开发环境"><a href="#四、我的开发环境" class="headerlink" title="四、我的开发环境"></a>四、我的开发环境</h2><ol><li>硬件（hardware）：pixhawkV3x</li><li>软件（software）：PX4</li><li>操作系统（OS）：Ubuntu 1804 桌面版</li><li>地面站（GCS）：QGC</li><li>集成开发环境（IDE）：QT creater</li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——交换排序（冒泡、快排）</title>
      <link href="/2019/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%89/"/>
      <url>/2019/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><h3 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h3><p>&ensp;&ensp;&ensp;&ensp;从头到尾，两两比较相邻的两个元素，如果顺序不对，则交换顺序，这样每一次即可将参与比较中最小的找出来。</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>&ensp;&ensp;&ensp;&ensp;从下向上，如果array[i] &lt; array[i-1]则进行交换，如最左侧的一列，35交换-37交换-32不换-21不换-14交换-16交换。这样就得到了第二列，循环执行。<br><img src="https://img-blog.csdnimg.cn/20200301175854542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" heiht="80%"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param array[] 要排序的数组</span></span><br><span class="line"><span class="comment">  *        length 数组长度</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span> [],<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> change = TURE; <span class="comment">// 用来标识之前比较过的是否已经有序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;length<span class="number">-1</span> &amp;&amp; change ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        change = FALSE;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;length-(i+<span class="number">1</span>); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[j]&gt;<span class="built_in">array</span>[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=<span class="built_in">array</span>[j+<span class="number">1</span>];</span><br><span class="line">                <span class="built_in">array</span>[j+<span class="number">1</span>]=<span class="built_in">array</span>[j];</span><br><span class="line">                <span class="built_in">array</span>[j]=temp;</span><br><span class="line">                change=TURE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span> a /<span class="keyword">sizeof</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[i], i == length <span class="number">-1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    bubbleSort(a, length);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[i], i == length <span class="number">-1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、快速排序"><a href="#二、快速排序" class="headerlink" title="二、快速排序"></a>二、快速排序</h2><h3 id="排序思想-1"><a href="#排序思想-1" class="headerlink" title="排序思想"></a>排序思想</h3><p>&ensp;&ensp;&ensp;&ensp;选取一个元素值，通过比较（从数组两侧向中间比较），比该值小得交换到其左边，大的被交换到右边，这样将待排序的数组分成两部分，左侧都比该元素值小，右侧都比该元素值大，针对每一个部分再执行以上的过程，直到不能再分为止。</p><h3 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>元素选取：</strong> 每一次以该组数组的第一个值作为被选取得元素值。一次排序后分成两部分，左侧比4小，右侧比4大。不断执行该过程<br><img src="https://img-blog.csdnimg.cn/20200301183814422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" heigt="80%"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>&ensp;&ensp;&ensp;&ensp;递归方式实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( length &lt;= <span class="number">1</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=length<span class="number">-1</span>, temp = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>( i&lt;j ) &#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">array</span>[j]&gt;temp &amp;&amp; j&gt;i ) j--; <span class="built_in">array</span>[i] = <span class="built_in">array</span>[j];</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">array</span>[i]&lt;=temp &amp;&amp; i&lt;j ) i++; <span class="built_in">array</span>[j] = <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[i] = temp;</span><br><span class="line">    sort(<span class="built_in">array</span>, i);</span><br><span class="line">    sort(<span class="built_in">array</span>+i+<span class="number">1</span>, length-i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——插入排序</title>
      <link href="/2019/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、排序思想"><a href="#一、排序思想" class="headerlink" title="一、排序思想"></a>一、排序思想</h2><p>将数据元素，一个一个的插入到当前已经排序好的表中。</p><h2 id="二、图解"><a href="#二、图解" class="headerlink" title="二、图解"></a>二、图解</h2><p><img src="https://img-blog.csdnimg.cn/2020030120233792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, tmp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; <span class="built_in">array</span>[j] &gt; tmp; j--)</span><br><span class="line">                <span class="built_in">array</span>[j+<span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">            <span class="built_in">array</span>[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">-100</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">-10</span>, <span class="number">9</span>, <span class="number">46</span>, <span class="number">-4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">44</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span> a /<span class="keyword">sizeof</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[i], i == n <span class="number">-1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    insertSort(a, n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[i], i == n <span class="number">-1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——选择排序</title>
      <link href="/2019/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、排序思想"><a href="#一、排序思想" class="headerlink" title="一、排序思想"></a>一、排序思想</h2><p>每一次取出没有被排序的元素中最小的元素。</p><h2 id="二、图解"><a href="#二、图解" class="headerlink" title="二、图解"></a>二、图解</h2><ol><li>先从已有的七个中找到最小的（下标为2），记住下标，与下标为0的交换。</li><li>从剩下的六个中再找到这六个中最小的（下标为3），记住下标，与下标为1的交换。</li><li>直到循环六次（N-1次），全部排好。<br><img src="https://img-blog.csdnimg.cn/20200301160349301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param array[] 要排序的数组</span></span><br><span class="line"><span class="comment">  *        length 数组长度</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i, j, <span class="built_in">min</span>, temp;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">min</span> = i;</span><br><span class="line">         <span class="keyword">for</span>(j=i+<span class="number">1</span>; j&lt;length; j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(<span class="built_in">array</span>[<span class="built_in">min</span>] &gt; <span class="built_in">array</span>[j])</span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(i != <span class="built_in">min</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             temp = <span class="built_in">array</span>[<span class="built_in">min</span>];</span><br><span class="line">             <span class="built_in">array</span>[<span class="built_in">min</span>] = <span class="built_in">array</span>[i];</span><br><span class="line">             <span class="built_in">array</span>[i] = temp;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span> a /<span class="keyword">sizeof</span> a[<span class="number">0</span>]; <span class="comment">// 得到数组长度</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) <span class="comment">//打印原有数组</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[i], i == length <span class="number">-1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    selectSort(a, length);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) <span class="comment">// 打印</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[i], i == length <span class="number">-1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——查找（平衡二叉树、分块索引、哈希表）</title>
      <link href="/2019/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE%EF%BC%88%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%88%86%E5%9D%97%E7%B4%A2%E5%BC%95%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AF%B9%E6%AF%94%EF%BC%89/"/>
      <url>/2019/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE%EF%BC%88%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%88%86%E5%9D%97%E7%B4%A2%E5%BC%95%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AF%B9%E6%AF%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、平衡二叉树"><a href="#一、平衡二叉树" class="headerlink" title="一、平衡二叉树"></a>一、平衡二叉树</h2><h4 id="1-解决的问题"><a href="#1-解决的问题" class="headerlink" title="1. 解决的问题"></a>1. 解决的问题</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;对于<strong>顺序存储</strong>的有序表在查找时可以采用二分法、插值法等查找方式，使查找的时间复杂度由 $O[n]$ 提高到了$O[log_n]$ ,但是面临的问题是，<strong>顺序存储</strong>的有序表在插入和删除元素时的效率很低，为 $O[n]$，因此如何使查找、插入和删除的的效率都很高呢？</p><h4 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;<strong>平衡二叉树：</strong> 每个结点左右子树的深度差不大于1的有序二叉树。</p><h4 id="3-分析"><a href="#3-分析" class="headerlink" title="3. 分析"></a>3. 分析</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;因为有序的完全二叉树在查找时的时间复杂度为$O[log_n]$，而平衡二叉树和有序的完全二叉树在查找时时间复杂度相同，在插入或删除元素时只需要维护该树仍然为平衡二叉树即可，因此时间复杂度依然为$O[log_n]$，即查找时所花费的时间。</p><h2 id="二、分块索引"><a href="#二、分块索引" class="headerlink" title="二、分块索引"></a>二、分块索引</h2><h4 id="1-解决的问题-1"><a href="#1-解决的问题-1" class="headerlink" title="1. 解决的问题"></a>1. 解决的问题</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;当某个数据表中的内容过多时，即使有序，也使得查询的速度不尽人意。</p><h4 id="2-概念-1"><a href="#2-概念-1" class="headerlink" title="2. 概念"></a>2. 概念</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;<strong>分块索引：</strong> 将数据集按照关键字范围或者某个特定的关键字进行分块，各个块之间有序，块内无序或者有序均可。</p><h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h4><p>①. 按范围分块：将用户按照索引大小，每5000个分到一个块中。查找时先查找所属块，再到块内查找。<br>②. 电话的区号：先锁定区，再到该取的数据中去查找，从而缩小被查找的数据量。</p><h2 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h2><h4 id="1-解决的问题-2"><a href="#1-解决的问题-2" class="headerlink" title="1. 解决的问题"></a>1. 解决的问题</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;在之前的基础上，进一步提高插入、删除、查找的效率，将时间复杂度提高到 $O[1]$ ，但是<strong>缺点</strong>在于：要查找在一定范围内的数据时时间复杂度较低。</p><h4 id="2-概念-2"><a href="#2-概念-2" class="headerlink" title="2. 概念"></a>2. 概念</h4><p><strong>哈希表：</strong> 通过Hash函数，实现关键字与存储地址之间确定一种对应关系，在增删改查的过程中，直接通过函数关系找到存储地址。但也要解决因为散列不均匀而引发的冲突问题。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>①. 对于查询效率要求比较高，但很少或者几乎不涉及到范围查找的情况。<br>②. 如Redis等常见key-value数据库的实现。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——最小生成树</title>
      <link href="/2019/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2019/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><ol><li>连通图：图中的任意两个节点之间都是联通的，即：总能从A节点按照一定路径走到B节点。</li><li>生成树：为联通图的一个联通子图，包含N个结点和N-1条边。</li><li>最小生成树：当联通图中的每条边带有权值时，所有边权值和最小的生成树。<h2 id="二、问题导向"><a href="#二、问题导向" class="headerlink" title="二、问题导向"></a>二、问题导向</h2>&ensp;&ensp;&ensp;&ensp;各个城市之间修建铁路，城市之间铺设电缆、水管等，不考虑环境等复杂因素，肯定最小生成树对应的权值（对应管线、铁路等长度）和最小怎样才能成本最低。因此如何铺设的问题转化成了找到这个最小生成树的问题。如下图(A~F表示城市，线上的数字表示距离)：<br><img src="https://img-blog.csdnimg.cn/20200228215520217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="60%" height="60%"><h2 id="三、相关算法"><a href="#三、相关算法" class="headerlink" title="三、相关算法"></a>三、相关算法</h2>注：正常情况下没有办法一眼看出来该如何选择的，如果更复杂一点的话就更难用眼睛看出来的了，因此面对该问题需要有响应的算法来解决。<strong>听着很高端、实际实现的代码逻辑很复杂，但是懂了思想理解起来很容易。</strong><br><strong>最终目的：</strong> 找到我们想要的N-1条线。<h4 id="Prim算法："><a href="#Prim算法：" class="headerlink" title="Prim算法："></a>Prim算法：</h4><strong>通俗理解：</strong> </li><li>任意选择一个结点开始（从此已有结点多了一个0到1）</li><li>从已有的结点中，找与已有结点和剩下的结点连线权限最小的那个</li><li>迭代重复第二步，直到所有结点都被连接。此时刚哈N-1条边。</li></ol><p><strong>举例：</strong> 假设以A为第一个点，我们依次被连接的顶点顺序为：A-&gt;F-&gt;E-&gt;D-&gt;C-&gt;B，边被选择的顺序为：4、2、3、4、3。步骤为红色12345的顺序。<br><img src="https://img-blog.csdnimg.cn/20200228215957777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="60%" height="60%"></p><h4 id="Kruskal算法："><a href="#Kruskal算法：" class="headerlink" title="Kruskal算法："></a>Kruskal算法：</h4><p><strong>通俗理解：</strong></p><ol><li>从所有的边中找最短的边</li><li>保证，所有的边连起来不能构成环路，如果构成环路则选择次小的边、或者次次小的边，</li><li>按照第二部的要求，重复第一步的过程，直到所有的结点被连接。</li></ol><p><strong>举例：</strong> 依次被选择的边：2(EF)-&gt;3(D)-&gt;3(BC)-&gt;4(A)-&gt;4。步骤为红色12345的顺序。<br><img src="https://img-blog.csdnimg.cn/20200228220137507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="60%" height="60%"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
            <tag> Prim </tag>
            
            <tag> Kruskal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——赫夫曼树</title>
      <link href="/2019/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2019/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="一、实际问题场景"><a href="#一、实际问题场景" class="headerlink" title="一、实际问题场景"></a>一、实际问题场景</h2><p>&#8195;&#8195;比如要为学生的成绩按照分数线分为优、良、中、及格、和不及格，对应的分数线如下：</p><div class="table-container"><table><thead><tr><th>等级</th><th>优</th><th>良</th><th>中</th><th>及格</th><th>不及格</th></tr></thead><tbody><tr><td>分数区间</td><td>90-100</td><td>80-89</td><td>70-79</td><td>60-69</td><td>0-59</td></tr><tr><td>分数在该区间的概率</td><td>10%</td><td>30%</td><td>40%</td><td>10%</td><td>10%</td></tr></tbody></table></div><p>&#8195;&#8195;现在有大量的学生的成绩需要对比，如果按照下面两种顺序进行比较：由于不同分数段的概率不一样，因此不同的比较顺序需要比较的次数不一样，所需时间也就不一样了：(如对于大概率的分数75，图一比较了3次。而图二比较2<br>次)</p><p><img src="https://img-blog.csdnimg.cn/20200217083711945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="60%" height="60%"><br><img src="https://img-blog.csdnimg.cn/20200217083945912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"><br>&#8195;&#8195;因此为了得到最少的比较次数，就需要一种方法得到最优的比较顺序，即赫夫曼树。</p><h2 id="二、赫夫曼树"><a href="#二、赫夫曼树" class="headerlink" title="二、赫夫曼树"></a>二、赫夫曼树</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>路径长度：节点到节点之间的路径数<br>带权路径长度：节点上的权数与路径长度的乘机。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>&#8195;&#8195;下图的带权路径长度=10+2x10+3x40+4x30+4x10=310,显然按照这个概率和这种比较方式，100个成绩需要比较310次。因此问题就在于获得最小的带权路径长度。<br><img src="https://img-blog.csdnimg.cn/20200217090623227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="60%" height="60%"></p><h3 id="构造赫夫曼树："><a href="#构造赫夫曼树：" class="headerlink" title="构造赫夫曼树："></a>构造赫夫曼树：</h3><p>&#8195;&#8195;注：为方便表示，将优、良、中、及格、和不及格命名为A、B、C、D、E。</p><ol><li>将有权值的节点排序：A-10，B-30，C-40，D-10，E-10；</li><li>将最小权值的两个节点A-10、D-10作为新节点AD-20的左右孩子，权值小的作为左孩子，大的作为右孩子。并将新的节点AD与剩下的比较，并重复上述过程，直到只剩两个节点为止。</li><li>过程如下:</li></ol><ul><li>A-10，B-30，C-40，D-10，E-10；</li><li>E-10，AD-20，B-30，C-40；</li><li>EAD-30，B-30，C-40；</li><li>C-40，BEAD-60；</li></ul><ol><li>逆向上述过程，得到赫夫曼树(注意左子树或左孩子为权值小的)：<br><img src="https://img-blog.csdnimg.cn/20200217094215741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="60%" height="60%"></li><li>计算：带权路径长度=40+30x2+10x2+10x3+10x3=130,这时如果有100个数据，仅需要比较130次即可。</li><li>代码转换： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getGread</span><span class="params">(<span class="keyword">int</span> score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(score &gt;=<span class="number">70</span> &amp;&amp; score &lt;= <span class="number">79</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'C'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &gt;=<span class="number">80</span> &amp;&amp; score &lt;= <span class="number">89</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'B'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &gt;=<span class="number">0</span> &amp;&amp; score &lt;= <span class="number">59</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'E'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &gt;=<span class="number">90</span> &amp;&amp; score &lt;= <span class="number">100</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'D'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 赫夫曼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——KMP模式匹配算法</title>
      <link href="/2019/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
      <url>/2019/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="代码内容简介："><a href="#代码内容简介：" class="headerlink" title="代码内容简介："></a>代码内容简介：</h3><ol><li>常规的匹配方式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 常规匹配查找子串</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    str_o: 原始串  original string</span></span><br><span class="line"><span class="comment"> *    str_t: 要查找的目标字符串  target string</span></span><br><span class="line"><span class="comment"> * @return 成功：指向目标字符串所在原始串中的位置  失败：NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strStr</span><span class="params">(<span class="keyword">char</span> *str_o, <span class="keyword">char</span> *<span class="keyword">str_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len_str_o = <span class="built_in">strlen</span>(str_o);</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">len_str_t</span> = <span class="built_in">strlen</span>(<span class="keyword">str_t</span>);</span><br><span class="line"><span class="keyword">int</span> cnt_str_o = <span class="number">0</span>, <span class="keyword">cnt_str_t</span> = <span class="number">0</span>; <span class="comment">// 记录原始串与目标串 进行对比的下标</span></span><br><span class="line"><span class="keyword">while</span> (cnt_str_o &lt; len_str_o &amp;&amp; <span class="keyword">cnt_str_t</span> &lt; <span class="keyword">len_str_t</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str_o[cnt_str_o] == <span class="keyword">str_t</span>[<span class="keyword">cnt_str_t</span>])</span><br><span class="line">&#123;</span><br><span class="line">cnt_str_o++;</span><br><span class="line"><span class="keyword">cnt_str_t</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cnt_str_o = cnt_str_o - <span class="keyword">cnt_str_t</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">cnt_str_t</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">cnt_str_t</span> == <span class="keyword">len_str_t</span>)</span><br><span class="line">    <span class="comment">//返回目标字符串在原字符串中的位置指针</span></span><br><span class="line"><span class="keyword">return</span> str_o + (cnt_str_o - <span class="keyword">cnt_str_t</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li>KMP算法匹配字符串的方式，实现快速查找子串。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------KMP匹配-----------------*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 获取要查找的目标字符串的next数组</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    str: 指向目标字符串的指针</span></span><br><span class="line"><span class="comment"> *    next: 指向next数组的指针</span></span><br><span class="line"><span class="comment"> * @return 指向next数组的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; (len<span class="number">-1</span>) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">-1</span> || str[i] == str[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">            <span class="keyword">if</span>(str[i] != str[j])</span><br><span class="line">    next[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[i] = next[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function KMP算法匹配查找子串</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    str_o: 原始串  original string</span></span><br><span class="line"><span class="comment"> *    str_t: 要查找的目标字符串  target string</span></span><br><span class="line"><span class="comment"> *    next: </span></span><br><span class="line"><span class="comment"> * @return 指向next数组的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">kmp</span><span class="params">(<span class="keyword">char</span> *str_o, <span class="keyword">char</span> *<span class="keyword">str_t</span>, <span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt_str_o = <span class="number">0</span>, <span class="keyword">cnt_str_t</span> = <span class="number">0</span>; <span class="comment">// 记录原始串与目标串 进行对比的下标</span></span><br><span class="line"><span class="keyword">int</span> len_str_o = <span class="built_in">strlen</span>(str_o);</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">len_str_t</span> = <span class="built_in">strlen</span>(<span class="keyword">str_t</span>);</span><br><span class="line"><span class="keyword">while</span>(cnt_str_o &lt; len_str_o &amp;&amp; <span class="keyword">cnt_str_t</span> &lt; <span class="keyword">len_str_t</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">cnt_str_t</span> == <span class="number">-1</span> || str_o[cnt_str_o] == <span class="keyword">str_t</span>[<span class="keyword">cnt_str_t</span>])</span><br><span class="line">&#123;</span><br><span class="line">cnt_str_o++;</span><br><span class="line"><span class="keyword">cnt_str_t</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">cnt_str_t</span> = next[<span class="keyword">cnt_str_t</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">cnt_str_t</span> &gt;= <span class="keyword">len_str_t</span>)</span><br><span class="line"><span class="keyword">return</span> str_o + (cnt_str_o - <span class="keyword">cnt_str_t</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在最后对上述两种方式的测试</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmp.c</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created on: 2020年1月31日</span></span><br><span class="line"><span class="comment"> *     Author: Beyonderwei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试部分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">"123456789 abab 123456789"</span>; <span class="comment">// 注意空格也算一个字符</span></span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">"abab"</span>;</span><br><span class="line">    <span class="keyword">char</span> *status = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="built_in">strlen</span>(str2)];</span><br><span class="line">    getNext(str2, next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试普通查找方法</span></span><br><span class="line">    status = strStr(str1, str2);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"在原始字符串中子串位置第一个字符:%c\n"</span>, *status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子串在原始字符串中的位置：%d\n"</span>, (status-str1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试kmp算法查找</span></span><br><span class="line">    status = kmp(str1, str2, next);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"在原始字符串中子串位置第一个字符:%c\n"</span>, *status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子串位置：%d\n"</span>, (status-str1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——栈、队列</title>
      <link href="/2019/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/"/>
      <url>/2019/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>概念：一种特殊的线性表——先进后出（Last In First Out ）的线性表。</li><li>特点：先进后出，只能从栈顶弹出(pop)或压入(push)数据。</li><li>存储结构：顺序存储和链式存储（常用）。<h3 id="结构代码"><a href="#结构代码" class="headerlink" title="结构代码"></a>结构代码</h3>注：链式存储<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表元素所存储的数据类型（以int为例）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="comment">// 定义栈的结点结构及结点指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>;</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType data；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *StackNodePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义指向栈的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">StackNodePtr top; <span class="comment">// 指向栈顶结点的指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cnt; <span class="comment">// 栈内元素的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3>&ensp;&ensp;&ensp;&ensp;计算器（利用后缀表达书）、页面的跳转回退等。<h2 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3></li><li>概念：一种特殊的线性表——先进先出（First In First Out）.的线性表</li><li>特点：先进先出，队尾插入、对头删除。</li><li>存储结构：顺序存储（循环队列）和链式存储（常用）。<h3 id="结构代码-1"><a href="#结构代码-1" class="headerlink" title="结构代码"></a>结构代码</h3>注：链式存储<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表元素所存储的数据类型（以int为例）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列的结点结构及结点指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QueueNOde, *QueueNodePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列的链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueueNodePtr head, tail; <span class="comment">// 指向队列头部和尾部的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3>&ensp;&ensp;&ensp;&ensp;排队买票、抢购等先到先得的场景。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——链表</title>
      <link href="/2019/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><ul><li>线性表：多个数据元素组成的有限序列。</li><li>链表：线性表的链式存储结构<h2 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h2><h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1.单链表"></a>1.单链表</h3></li><li>概念： 链表的结点包含数据域和指针域，指针域只有一个，并指向下一个结点。</li><li>特点：插入删除数据的时间复杂度仅为O(1)，不需要预分配存储空间。<h3 id="2-循环链表"><a href="#2-循环链表" class="headerlink" title="2. 循环链表"></a>2. 循环链表</h3></li><li>概念：单链表中，终端结点的指针由空指针改为指向头结点的指针，形成一个环。</li><li>特点：相对于单链表，循环链表可以在任意位置开始访问到整个链表，尾指针的存在方便了链表的合并。<h3 id="3-双向链表"><a href="#3-双向链表" class="headerlink" title="3. 双向链表"></a>3. 双向链表</h3></li><li>概念：结点中除数据域以外包含两个指针域，一个指向前驱结点，一个指向后继结点。</li><li>特点：相对于单项链表可以实现双向的查找。<h2 id="三、单链表"><a href="#三、单链表" class="headerlink" title="三、单链表"></a>三、单链表</h2>&ensp;&ensp;&ensp;&ensp;注：C语言实现，包括单链表的创建、增加数据、查询某一个数据、删除某个结点、获取链表长度等。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * singly_linked_list.c</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created on: 2020年1月27日</span></span><br><span class="line"><span class="comment"> *     Author: Beyonderwei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------单链表----------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表元素所存储的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="comment">// 定义节点的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">// 定义链表指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 创建带有头节点的单链表，即创建一个头节点</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    list: 链表</span></span><br><span class="line"><span class="comment"> * @return 指向链表的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LinkList <span class="title">createList</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LinkList <span class="built_in">list</span>;</span><br><span class="line">  <span class="built_in">list</span> = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">  <span class="built_in">list</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 向链表追加数据</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    list: 链表</span></span><br><span class="line"><span class="comment"> *    elem: 要追加的数据</span></span><br><span class="line"><span class="comment"> * @return 指向链表的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LinkList <span class="title">listAppend</span><span class="params">(LinkList <span class="built_in">list</span>, ElemType elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LinkList tmp, node;</span><br><span class="line">  tmp = <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">while</span>(tmp-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  node = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//生成一个新的节点，来存储数据</span></span><br><span class="line">  node-&gt;data = elem;</span><br><span class="line">  node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  tmp-&gt;next = node;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 按照条件查找链表中的某个元素</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    list: 链表</span></span><br><span class="line"><span class="comment"> *    elem: 要查找的数据</span></span><br><span class="line"><span class="comment"> * @return 指向该结点的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LinkList <span class="title">getElem</span><span class="params">(LinkList <span class="built_in">list</span>, ElemType elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LinkList tmp = <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">while</span>(tmp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp-&gt;data == elem) <span class="comment">// 可以改为按照data中的某个条件来查找</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 获取链表的长度</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    list: 链表</span></span><br><span class="line"><span class="comment"> * @return 链表的长度（不包括头节点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(LinkList <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">  LinkList tmp;</span><br><span class="line">  tmp = <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">while</span>(tmp-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    length++;</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 按照条件删除链表的某一个结点</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    list: 链表</span></span><br><span class="line"><span class="comment"> *    elem: 要删除的元素</span></span><br><span class="line"><span class="comment"> * @return list: 删除成功</span></span><br><span class="line"><span class="comment"> *         NULL: 删除失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LinkList <span class="title">deleteElem</span><span class="params">(LinkList <span class="built_in">list</span>, ElemType elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LinkList last_node;</span><br><span class="line">  LinkList tmp = <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">while</span>(tmp-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    last_node = tmp;</span><br><span class="line">    tmp = tmp-&gt;next; <span class="comment">//因为头结点没有存储数据，直接略过</span></span><br><span class="line">    <span class="keyword">if</span>(tmp-&gt;data == elem)</span><br><span class="line">    &#123;</span><br><span class="line">      last_node-&gt;next = tmp-&gt;next;</span><br><span class="line">      <span class="built_in">free</span>(tmp);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------测试代码----------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LinkList <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> length;</span><br><span class="line">  <span class="built_in">list</span> = createList();</span><br><span class="line">  LinkList e;</span><br><span class="line">  listAppend(<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">  listAppend(<span class="built_in">list</span>, <span class="number">2</span>);</span><br><span class="line">  listAppend(<span class="built_in">list</span>, <span class="number">3</span>);</span><br><span class="line">  listAppend(<span class="built_in">list</span>, <span class="number">4</span>);</span><br><span class="line">  listAppend(<span class="built_in">list</span>, <span class="number">5</span>);</span><br><span class="line">  listAppend(<span class="built_in">list</span>, <span class="number">6</span>);</span><br><span class="line">  </span><br><span class="line">  deleteElem(<span class="built_in">list</span>, <span class="number">7</span>);</span><br><span class="line">  deleteElem(<span class="built_in">list</span>, <span class="number">5</span>);</span><br><span class="line">  length = getLength(<span class="built_in">list</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"链表长度为:%d\n"</span>,length);</span><br><span class="line">  e = getElem(<span class="built_in">list</span>, <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span>(e != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"查询的值为:%d\n"</span>,e-&gt;data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"链表第一个元素:%d"</span>,<span class="built_in">list</span>-&gt;next-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、循环链表与双向链表"><a href="#四、循环链表与双向链表" class="headerlink" title="四、循环链表与双向链表"></a>四、循环链表与双向链表</h2><p>&ensp;&ensp;&ensp;&ensp;对于以上功能的实现仅仅是在单项链表上做了一些改变。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kalman滤波算法</title>
      <link href="/2018/10/15/%E5%8D%A1%E5%B0%94%E6%9B%BC-Kalman-%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E3%80%81C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
      <url>/2018/10/15/%E5%8D%A1%E5%B0%94%E6%9B%BC-Kalman-%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E3%80%81C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h1><h2 id="一、滤波效果展示"><a href="#一、滤波效果展示" class="headerlink" title="一、滤波效果展示"></a>一、滤波效果展示</h2><p>&#8195;&#8195;蓝色的波形是实际测得的数据，红色的波形是经 Kalman 滤波后的数据波形。<br><strong>注：这里是实际应用激光测距传感器（TOF）vl53l0x 测得的距离数据。</strong><br><img src="https://img-blog.csdnimg.cn/20190517104449922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h2 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h2><p>&#8195;&#8195;采用递归的方法解决线性滤波问题，只需要当前的测量值和前一个采样周期的估计值就能进行状态估计，需要的存储空间小，每一步的计算量小。</p><h2 id="三、组成"><a href="#三、组成" class="headerlink" title="三、组成"></a>三、组成</h2><h3 id="1-预测状态方程"><a href="#1-预测状态方程" class="headerlink" title="1. 预测状态方程"></a>1. 预测状态方程</h3><h4 id="（1）目的："><a href="#（1）目的：" class="headerlink" title="（1）目的："></a>（1）目的：</h4><p>&#8195;&#8195;由 <strong>系统状态变量k-1时刻的最优值</strong> 和 <strong>系统输入</strong> 计算出k时刻的 <strong>系统预测值</strong>。</p><h4 id="（2）方程："><a href="#（2）方程：" class="headerlink" title="（2）方程："></a>（2）方程：</h4><p><img src="https://img-blog.csdnimg.cn/20190517104648876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h4 id="（3）备注"><a href="#（3）备注" class="headerlink" title="（3）备注"></a>（3）备注</h4><p>&#8195;&#8195;①.  X k-1|k-1  为k-1时刻的输出。<br>&#8195;&#8195;②.  当X为一维数据时，Fk的值是1。<br>&#8195;&#8195;③. <strong>一维数据下（uk=0时）：系统预测值 = 系统状态变量k-1时刻的最优值。</strong></p><h3 id="2-预测协方差方程"><a href="#2-预测协方差方程" class="headerlink" title="2. 预测协方差方程"></a>2. 预测协方差方程</h3><h4 id="（1）目的"><a href="#（1）目的" class="headerlink" title="（1）目的"></a>（1）目的</h4><p>&#8195;&#8195;根据 <strong>k-1时刻的系统协方差</strong> 预测 <strong>k时刻系统协方差</strong>。</p><h4 id="（2）方程"><a href="#（2）方程" class="headerlink" title="（2）方程"></a>（2）方程</h4><p><img src="https://img-blog.csdnimg.cn/20190517104838972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h4 id="（3）备注-1"><a href="#（3）备注-1" class="headerlink" title="（3）备注"></a>（3）备注</h4><p>&#8195;&#8195;①. 当X为一维数据时，Fk的值是1。</p><h3 id="3-卡尔曼增益方程"><a href="#3-卡尔曼增益方程" class="headerlink" title="3. 卡尔曼增益方程"></a>3. 卡尔曼增益方程</h3><h4 id="（1）目的-1"><a href="#（1）目的-1" class="headerlink" title="（1）目的"></a>（1）目的</h4><p>&#8195;&#8195;根据（k时刻） <strong>协方差矩阵的预测值</strong> 计算 <strong>卡尔曼增益</strong>。</p><h4 id="（2）方程-1"><a href="#（2）方程-1" class="headerlink" title="（2）方程"></a>（2）方程</h4><p><img src="https://img-blog.csdnimg.cn/20190517105000426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h4 id="（3）备注-2"><a href="#（3）备注-2" class="headerlink" title="（3）备注"></a>（3）备注</h4><p>&#8195;&#8195;①. 当 Pk|k-1 为一个一维矩阵时，Hk 是1。</p><h3 id="4-跟新最优值方程（卡尔曼滤波的输出）"><a href="#4-跟新最优值方程（卡尔曼滤波的输出）" class="headerlink" title="4. 跟新最优值方程（卡尔曼滤波的输出）"></a>4. 跟新最优值方程（卡尔曼滤波的输出）</h3><h4 id="（1）目的-2"><a href="#（1）目的-2" class="headerlink" title="（1）目的"></a>（1）目的</h4><p>&#8195;&#8195;根据 <strong>状态变量的预测值</strong> 和 <strong>系统测量值</strong> 计算出 <strong>k时刻状态变量的最优值</strong>。</p><h4 id="（2）方程-2"><a href="#（2）方程-2" class="headerlink" title="（2）方程"></a>（2）方程</h4><p><img src="https://img-blog.csdnimg.cn/20190517105207503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h4 id="（3）备注-3"><a href="#（3）备注-3" class="headerlink" title="（3）备注"></a>（3）备注</h4><p>&#8195;&#8195;①. 当 Pk|k-1 为一个一维矩阵时，Hk 是1。</p><h3 id="5-更新协方差方程"><a href="#5-更新协方差方程" class="headerlink" title="5. 更新协方差方程"></a>5. 更新协方差方程</h3><h4 id="（1）目的-3"><a href="#（1）目的-3" class="headerlink" title="（1）目的"></a>（1）目的</h4><p>&#8195;&#8195;为了求 <strong>k时刻的协方差矩阵</strong>。（为得到k+1时刻的卡尔曼输出值做准备）</p><h4 id="（2）方程-3"><a href="#（2）方程-3" class="headerlink" title="（2）方程"></a>（2）方程</h4><p><img src="https://img-blog.csdnimg.cn/20190517105449503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h4 id="（3）备注-4"><a href="#（3）备注-4" class="headerlink" title="（3）备注"></a>（3）备注</h4><p>&#8195;&#8195;①. 当 Pk|k-1 为一个一维矩阵时，Hk 是1。</p><h2 id="四、C-程序代码实现"><a href="#四、C-程序代码实现" class="headerlink" title="四、C 程序代码实现"></a>四、C 程序代码实现</h2><h3 id="1-参数列表"><a href="#1-参数列表" class="headerlink" title="1. 参数列表"></a>1. 参数列表</h3><p><img src="https://img-blog.csdnimg.cn/20190517105559481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h3 id="2-代码实现（一维数据滤波）"><a href="#2-代码实现（一维数据滤波）" class="headerlink" title="2. 代码实现（一维数据滤波）"></a>2. 代码实现（一维数据滤波）</h3><p>&#8195;&#8195;<strong>实际参数是参照别人已经选好的参数，不过也可以自己改变参数，去观察波形的效果，体会每个参数对于滤波效果的影响，这里不详细介绍</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 结构体类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> LastP;<span class="comment">//上次估算协方差 初始化值为0.02</span></span><br><span class="line">    <span class="keyword">float</span> Now_P;<span class="comment">//当前估算协方差 初始化值为0</span></span><br><span class="line">    <span class="keyword">float</span> out;<span class="comment">//卡尔曼滤波器输出 初始化值为0</span></span><br><span class="line">    <span class="keyword">float</span> Kg;<span class="comment">//卡尔曼增益 初始化值为0</span></span><br><span class="line">    <span class="keyword">float</span> Q;<span class="comment">//过程噪声协方差 初始化值为0.001</span></span><br><span class="line">    <span class="keyword">float</span> R;<span class="comment">//观测噪声协方差 初始化值为0.543</span></span><br><span class="line">&#125;KFP；<span class="comment">//Kalman Filter parameter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 以高度为例 定义卡尔曼结构体并初始化参数</span></span><br><span class="line">KFP KFP_height=&#123;<span class="number">0.02</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.001</span>,<span class="number">0.543</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *卡尔曼滤波器</span></span><br><span class="line"><span class="comment"> *@param KFP *kfp 卡尔曼结构体参数</span></span><br><span class="line"><span class="comment"> *   float input 需要滤波的参数的测量值（即传感器的采集值）</span></span><br><span class="line"><span class="comment"> *@return 滤波后的参数（最优值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">float</span> <span class="title">kalmanFilter</span><span class="params">(KFP *kfp,<span class="keyword">float</span> input)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="comment">//预测协方差方程：k时刻系统估算协方差 = k-1时刻的系统协方差 + 过程噪声协方差</span></span><br><span class="line">     kfp-&gt;Now_P = kfp-&gt;LastP + kfp-&gt;Q;</span><br><span class="line">     <span class="comment">//卡尔曼增益方程：卡尔曼增益 = k时刻系统估算协方差 / （k时刻系统估算协方差 + 观测噪声协方差）</span></span><br><span class="line">     kfp-&gt;Kg = kfp-&gt;Now_P / (kfp-&gt;NOw_P + kfp-&gt;R);</span><br><span class="line">     <span class="comment">//更新最优值方程：k时刻状态变量的最优值 = 状态变量的预测值 + 卡尔曼增益 * （测量值 - 状态变量的预测值）</span></span><br><span class="line">     kfp-&gt;out = kfp-&gt;out + kfp-&gt;Kg * (input -kfp-&gt;out);<span class="comment">//因为这一次的预测值就是上一次的输出值</span></span><br><span class="line">     <span class="comment">//更新协方差方程: 本次的系统协方差付给 kfp-&gt;LastP 威下一次运算准备。</span></span><br><span class="line">     kfp-&gt;LastP = (<span class="number">1</span>-kfp-&gt;Kg) * kfp-&gt;Now_P;</span><br><span class="line">     <span class="keyword">return</span> kfp-&gt;out；</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *调用卡尔曼滤波器 实践</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line"><span class="keyword">int</span> kalman_height=<span class="number">0</span>;</span><br><span class="line">kalman_height = kalmanFilter(&amp;KFP_height,(<span class="keyword">float</span>)<span class="built_in">height</span>);</span><br></pre></td></tr></table></figure></p><h2 id="五、发送波形到上位机显示"><a href="#五、发送波形到上位机显示" class="headerlink" title="五、发送波形到上位机显示"></a>五、发送波形到上位机显示</h2><p>&#8195;&#8195;这里使用的是匿名的上位机 V65 版本，具体如何使用可以参考茶大的博客，并且茶大博客里面有上位机的下载地址。茶大博客地址：<a href="https://blog.csdn.net/wangjt1988/article/details/83684188" target="_blank" rel="noopener">https://blog.csdn.net/wangjt1988/article/details/83684188</a><br>注：文章方程截图及参数来源于中科浩电。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kalman </tag>
            
            <tag> vl53l0x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四旋翼PID控制原理</title>
      <link href="/2018/07/26/%E5%9B%9B%E6%97%8B%E7%BF%BC-PID-%E6%8E%A7%E5%88%B6/"/>
      <url>/2018/07/26/%E5%9B%9B%E6%97%8B%E7%BF%BC-PID-%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、PID-原理"><a href="#一、PID-原理" class="headerlink" title="一、PID 原理"></a>一、PID 原理</h2><p>&#8195;&#8195; <strong>偏差控制</strong>，利用目标值（期望值）与实际测量值构成的偏差（误差）对被控对象进行线性的控制。<strong>偏差 = 目标值 - 测量值</strong>。</p><h2 id="二、四旋翼串级双闭环-PID-控制"><a href="#二、四旋翼串级双闭环-PID-控制" class="headerlink" title="二、四旋翼串级双闭环 PID 控制"></a>二、四旋翼串级双闭环 PID 控制</h2><p>&#8195;&#8195;对于四旋翼，可以理解外环为角度环，内环是角速度环。</p><h3 id="1-外环"><a href="#1-外环" class="headerlink" title="1. 外环"></a>1. 外环</h3><p><img src="https://img-blog.csdnimg.cn/20190517170845818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><ol><li>目标值：期望轨迹，即期望的姿态角度。</li><li>测量值：实际的姿态角度。</li><li>PID控制器的输入：目标值 - 测量值。</li><li>PID控制器的输出：提供使测量值趋近于目标值的方法<br><strong>注：</strong><br>①. <strong>外环是位置反馈 -&gt; 反馈了当前的位置，即当前偏航了多少角度。</strong><br>②. <strong>外环控制是为了达到期望的角度，因为角度是由角速度积分得到，dT时间，外环输出的控制量反应角度的偏差值，dT时间的角度偏差即角速度，所以把外环PID的输出作为角速度来用，外环的输出就是我们想要达到的角速度。把外环的输出作为内环的输入（内环的目标值），即我们期望角速度进行怎么样的变化，才能使姿态角度达到我们期望的姿态角度。</strong> <h3 id="2-内环"><a href="#2-内环" class="headerlink" title="2.内环"></a>2.内环</h3><img src="https://img-blog.csdnimg.cn/20190517195252408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></li><li>目标值：外环的输出，即期望的角速度。</li><li>测量值：实际的角速度。</li><li>PID 输入：目标值减去测量值。</li><li>PID 输出：提供使测量值趋近目标值的方法。<br><strong>注：</strong><br>①. 内环的目的是要达到期望的角速度，角速度直接与电机的转速有关系。所以内环 PID 的输出，作为实际调节电机转速的参数去使用。<br>②. 在纯姿态模式下，四旋翼电机的转速由两部分组成，遥控油门提供的是<strong>基础转速</strong>，PID的输出作为维持姿态平稳的<strong>调节转速</strong>。这就是纯姿态模式下飞机的高度不好控制的原因，要使飞机维持在一个高度，就需要基础转速所提供的升力刚好与重力相等。飞行过程中维持飞机平稳的是调节转速，它保证了飞机平衡的姿态。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PID </tag>
            
            <tag> 四旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CC3200实现浇水控制（实现一个简单的物联网系统-5）</title>
      <link href="/2018/05/10/CC3200%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E5%AE%9E%E7%8E%B0%E5%BC%95%E8%84%9A%E6%8B%89%E9%AB%98%E3%80%81%E6%8B%89%E4%BD%8E-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-5/"/>
      <url>/2018/05/10/CC3200%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E5%AE%9E%E7%8E%B0%E5%BC%95%E8%84%9A%E6%8B%89%E9%AB%98%E3%80%81%E6%8B%89%E4%BD%8E-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-5/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;前面已经可以实现从服务器获得用户想要的浇水量，下面就需要对IO口进行拉高拉低对水泵的启停进行控制。</p><h2 id="二、CC3200-GPIO-简介"><a href="#二、CC3200-GPIO-简介" class="headerlink" title="二、CC3200 GPIO 简介"></a>二、CC3200 GPIO 简介</h2><p>&#8195;&#8195;CC3200所有逻辑引脚和部分模拟引脚均可以用来作为通用输入/输出(GPIO)使用。GPIO功能可用于各种逻辑输入输出的场合。 GPIO有4组（GPIO A0~A3），每组8个。 具体如下：<br>&#8195;&#8195;①. &#8195;GPIO A0： GPIO_00~GPIO_07, 对应 GPIOA0.0~GPIOA0.7 。<br>&#8195;&#8195;②. &#8195;GPIO A1： GPIO_08~GPIO_15, 对应 GPIOA1.0~GPIOA1.7 。<br>&#8195;&#8195;③. &#8195;GPIO A2： GPIO_00~GPIO_07, 对应 GPIOA2.0~GPIOA2.7 。<br>&#8195;&#8195;④. &#8195;GPIO A3： GPIO_00~GPIO_07, 对应 GPIOA3.0~GPIOA3.7 。</p><p>&#8195;&#8195;根据功能引脚的配置不同， GPIO的数量有27个 。所有GPIO引脚具备中断能力(电平有效或者边沿有效、上升或下降沿触发、有中断屏蔽)。可用于出发DMA或作为唤醒源。</p><h2 id="三、简单易懂实现IO口拉高拉低"><a href="#三、简单易懂实现IO口拉高拉低" class="headerlink" title="三、简单易懂实现IO口拉高拉低"></a>三、简单易懂实现IO口拉高拉低</h2><p>&#8195;&#8195;CC3200 提供了一系列 API 去更方便的实现用户想要的功能。在SDK的 driverlib 和 src 下。我们导入的例程都包含了这些API。但是例程里面的实现方法显得过于复杂，不易理解，但是对我们来说是一个重要的参考。下面 过滤掉  “_if_” 层，通过直接调用 API 实现对IO的拉高拉低。==注意：==<strong>重要的说明在程序的注释中，对于每一个形参代表的意思的理解非常重要。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">BoardInit();<span class="comment">//板子初始化</span></span><br><span class="line"><span class="comment">/*--引脚配置  Start--*/</span></span><br><span class="line">        PinTypeGPIO(PIN_64, PIN_MODE_0, <span class="literal">false</span>);<span class="comment">//参数：引脚名 引脚功能模式  开漏模式或STD</span></span><br><span class="line">        GPIODirModeSet(GPIOA1_BASE, GPIO_PIN_1, GPIO_DIR_MODE_OUT);<span class="comment">//哪一组的端口地址  GPIO_A1的第1个 GPIO位权(0~7)   输入或者输出</span></span><br><span class="line">        <span class="comment">/*--引脚配置  End--*/</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        MAP_UtilsDelay(<span class="number">2000000</span>);</span><br><span class="line">        GPIOPinWrite(GPIOA1_BASE,GPIO_PIN_1,GPIO_PIN_1);<span class="comment">//拉高IO口</span></span><br><span class="line">        MAP_UtilsDelay(<span class="number">2000000</span>);</span><br><span class="line">        GPIOPinWrite(GPIOA1_BASE,GPIO_PIN_1,<span class="number">0</span>);<span class="comment">//拉低IO口</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样就实现了对于PIN_64引脚的拉高拉低操作，如果是launchpad的话就可以看到LED灯一直闪烁。<br>==注：== 在pin.h 和 gpio.h 中都对于每一个IO口的地址都进行了定义，对于每一个API只需要相对应的使用即可，但是，<strong>需要了解 T I对 CC3200 的引脚定义，知道其对应关系，具体参照下表。</strong>(引自源地的资料)<br><img src="https://img-blog.csdnimg.cn/20190211195928213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h2 id="四、学习方法"><a href="#四、学习方法" class="headerlink" title="四、学习方法"></a>四、学习方法</h2><p>&#8195;&#8195;TI 对于每一种功能都提供了例程，所以如果我们需要用到相应的功能就可以直接去参考例程中是如何配置的，这对于为了快速的上手开发是一个行之有效的好方法。 比如：我们模数转换会用到ADC ，那么就可以直接去参考例程中的ADC有关引脚的配置，等等。</p><h2 id="五、视频展示"><a href="#五、视频展示" class="headerlink" title="五、视频展示"></a>五、视频展示</h2><p>&#8195;&#8195;到此为止，整个远程浇水系统就完成了，达不到商品化的稳定性，但能够在较长时间内实现该功能。<br><strong>视频地址：</strong> <a href="https://www.bilibili.com/video/av43996928" target="_blank" rel="noopener">https://www.bilibili.com/video/av43996928</a></p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> CC3200 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CC3200上传数据到服务器（实现一个简单的物联网系统-4）</title>
      <link href="/2018/05/02/CC3200%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-4/"/>
      <url>/2018/05/02/CC3200%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-4/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;上篇文章已经完成了从服务器 get 数据，这篇将通过 post 的方式，将通过CC3200测得的花卉状态信息（如土壤湿度、光照强度）上传到服务器。其实post的方式也实现了接收服务器返回的数据，所以只发送一个post请求就可以完成数据的上传和获取，具体在下面说明。</p><h2 id="二、CC3200-连接到路由器（AP）"><a href="#二、CC3200-连接到路由器（AP）" class="headerlink" title="二、CC3200 连接到路由器（AP）"></a>二、CC3200 连接到路由器（AP）</h2><p>&#8195;&#8195;这里已经在上篇文章说过了，具体可以参照：<br>&#8195;&#8195;<a href="https://blog.csdn.net/CSDN_X_W/article/details/86756675" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_X_W/article/details/86756675</a></p><h2 id="三、CC3200-post-数据到服务器"><a href="#三、CC3200-post-数据到服务器" class="headerlink" title="三、CC3200 post 数据到服务器"></a>三、CC3200 post 数据到服务器</h2><p>&#8195;&#8195; 同样是将后台代码和CC3200的相关配置一起列出来。<br><strong>3.1 后台代码：</strong> 这里解析的数据是CC3200发送过来的花卉状态信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理CC3200 POST 给服务器的数据 -&gt;更新花卉的状态信息 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span>   <span class="comment">//用于接收CC3200 post 过来的数据</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/cc3200Post"</span>)   <span class="comment">//这个方法用来处理CC3200Post请求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">CC3200PostResponse</span><span class="params">(@RequestBody String flower_info)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">    <span class="comment">/*--更新花卉的状态信息--*/</span></span><br><span class="line">    <span class="keyword">int</span> monitorID;</span><br><span class="line">    <span class="keyword">float</span> co2;</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">    System.out.println(flower_info);</span><br><span class="line">    <span class="comment">//1.解析post过来的数据</span></span><br><span class="line">    JSONObject jsonObject = <span class="keyword">new</span> JSONObject(flower_info);</span><br><span class="line">    monitorID = jsonObject.getInt(<span class="string">"monitorID"</span>);</span><br><span class="line">    co2 = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"co2"</span>);</span><br><span class="line">    temperature = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"temperature"</span>);</span><br><span class="line">    humidity = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"humidity"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.根据花卉监测系统ID更新数据库的数据</span></span><br><span class="line">    String updateSql =</span><br><span class="line">            <span class="string">"update flowers set co2 ="</span> + <span class="string">"'"</span> + co2 + <span class="string">"'"</span> +<span class="string">","</span>+</span><br><span class="line">            <span class="string">"temperature ="</span>+<span class="string">"'"</span> + temperature + <span class="string">"'"</span> +<span class="string">","</span>+</span><br><span class="line">            <span class="string">"humidity ="</span>+<span class="string">"'"</span> + humidity + <span class="string">"'"</span> +</span><br><span class="line">            <span class="string">" WHERE monitor_id ="</span>+ <span class="string">"'"</span> + monitorID + <span class="string">"'"</span>;</span><br><span class="line">    jdbcTemplate.update(updateSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>3.2 CC3200 代码：</strong> </p><ol><li>CC3200 的相关配置，在main.c 中 , IP 和端口配置不再赘述，参考上篇文章。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POST_REQUEST_URI  <span class="meta-string">"/cc3200Post"</span>         <span class="comment">//请求方式 即发送什么样的请求</span></span></span><br><span class="line"><span class="comment">/*--Post过去的数据--*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POST_DATA       <span class="meta-string">"&#123;\n\"name\":\"xyz\",\n\"address\":\n&#123;\n\"plot#\":12,\n\"street\":\"abc\",\n\"city\":\"ijk\"\n&#125;,\n\"age\":30\n&#125;"</span></span></span><br></pre></td></tr></table></figure></li><li>在 CC3200 中post数据的具体实现通过调用 static int HTTPPostMethod(HTTPCli_Handle httpClient) 函数中调用的 TTPCli_sendRequestBody(httpClient, POST_DATA , (sizeof(POST_DATA )-1));  来实现的，这样运行后就能在后台接收到 POST_DATA 当中的数据。这样我们就已经实现了将数据 post 到服务器。<h2 id="四、疑问（重要）"><a href="#四、疑问（重要）" class="headerlink" title="四、疑问（重要）"></a>四、疑问（重要）</h2>&#8195;&#8195;1.==需要思考这样一个问题== ：我们 post 过去的数据是要有变量的，如温度（temperature），可是如何将这样一些变量拼接 JSON 形式的字符串当中去呢？早就有人帮我们写好了这样的库，即-&gt; cJSON , 需要引入 cJSON 的 .c 和 .h 文件后可参考下面这样一段代码：<br>&#8195;&#8195;2.定义 flowerStatusData 代替原来的 POST_DATA，则原来的 TTPCli_sendRequestBody函数的形参也要相应修改：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">char</span> *outData;</span><br><span class="line"><span class="keyword">char</span> flowerStatusData[<span class="number">63</span>]=&#123;<span class="number">0</span>&#125;;  <span class="comment">//数组长度应该是 strlen 得到的字符串长度加一   这个值根据上传的数据量经调试打印得到</span></span><br></pre></td></tr></table></figure>&#8195;&#8195;3.具体post数据的部分可以参考如下代码，main.c 中：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--根据测得的数据信息，post数据到服务器，从而更新花卉的状态数据--*/</span></span><br><span class="line"><span class="comment">//创建一个cJSON结构体指针并分配空间，然后赋值给root</span></span><br><span class="line">cJSON *root = cJSON_CreateObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在root结构体中创建一组健为"key",值为" value" 的键值对。</span></span><br><span class="line">cJSON_AddNumberToObject(root,<span class="string">"monitorID"</span>,monitor_id);</span><br><span class="line">cJSON_AddNumberToObject(root,<span class="string">"co2"</span>,co2);</span><br><span class="line">cJSON_AddNumberToObject(root,<span class="string">"temperature"</span>,temperature);</span><br><span class="line">cJSON_AddNumberToObject(root,<span class="string">"humidity"</span>,humidity);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--得到无格式形式的json字符串，即输出无回车和空格分离的键值对--*/</span></span><br><span class="line">        outData = cJSON_PrintUnformatted(root);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(flowerStatusData, outData, <span class="built_in">strlen</span>(outData));</span><br><span class="line">UART_PRINT(<span class="string">"\n\r"</span>);</span><br><span class="line">UART_PRINT(<span class="string">"HTTP Post Begin:\n\r"</span>);</span><br><span class="line">    lRetVal = HTTPPostMethod(&amp;httpClient);</span><br><span class="line">    <span class="keyword">if</span>(lRetVal &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    UART_PRINT(<span class="string">"HTTP Post failed.\n\r"</span>);</span><br><span class="line">&#125;</span><br><span class="line">UART_PRINT(<span class="string">"HTTP Post End:\n\r"</span>);</span><br><span class="line"><span class="built_in">free</span>(outData);<span class="comment">//释放malloc分配的空间</span></span><br><span class="line">        cJSON_Delete(root);<span class="comment">//释放cJSON结构体指针</span></span><br></pre></td></tr></table></figure></li></ol><p>注：具体 cJSON 的使用可以百度到很多博客，cJSON 的下载网址为：<br>&#8195;&#8195;<a href="https://sourceforge.net/projects/cjson/" target="_blank" rel="noopener">https://sourceforge.net/projects/cjson/</a><br>&#8195;&#8195;直接将cJSON.c  和 cJOSN.h 添加到工程调用即可。</p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> CC3200 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CC3200从服务器获取数据（实现一个简单的物联网系统-3）</title>
      <link href="/2018/04/28/CC3200-%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-3/"/>
      <url>/2018/04/28/CC3200-%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;借助 TI 公司的 CC3200 我们可以通过 http 轻松的完成与服务器之间的数据交互，体验CC3200的开箱即用的感觉，下面借助 http_client_demo 这个历程来实现从服务器 get 数据。实现我们从服务器得到用户的浇水信息。<br>&#8195;&#8195;<strong>CC3200的SDK 里面提供了所有的关于CC3200的资料，真的非常重要。</strong> 如：API文档、例程、例程使用文档、数据手册、原理图 … 等等。<br><img src="https://img-blog.csdnimg.cn/20190203100601961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"></p><h2 id="二、CC3200-连接到路由器（AP）"><a href="#二、CC3200-连接到路由器（AP）" class="headerlink" title="二、CC3200 连接到路由器（AP）"></a>二、CC3200 连接到路由器（AP）</h2><p>&#8195;&#8195;此时CC3200 作为站点，即工作在 Sta（station）模式。简单理解就好比我们手机连上路由器或者数据才能上网一样，所需配置的地方如下：在common.h 中</p><ol><li>SSID_NAME ：填入路由器所设置的名字。</li><li>SECURITY_TYPE ：安全方式，路由器设置为有密码时一般为  SL_SEC_TYPE_WPA_WPA2；没有密码时，定义为 SL_SEC_TYPE_OPEN。</li><li>SECURITY_KEY ：有密码时这里填入密码。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Values for below macros shall be modified as per access-point(AP) properties// Values for below macros shall be modified as per access-point(AP) properties</span></span><br><span class="line"><span class="comment">// SimpleLink device will connect to following AP when application is executed</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*--下面的设置为CC3200作为客户端时需要连接的路由器的相关信息 所以要根据所连接的路由器进行修改--*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SSID_NAME           <span class="meta-string">" "</span>    <span class="comment">/* AP SSID */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECURITY_TYPE       SL_SEC_TYPE_WPA_WPA2    <span class="comment">/* Security type (OPEN or WEP or WPA*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECURITY_KEY        <span class="meta-string">" "</span>              <span class="comment">/* Password of the secured AP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SSID_LEN_MAX        32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSSID_LEN_MAX       6</span></span><br></pre></td></tr></table></figure>&#8195;&#8195;运行程序仿真运行，可以登录路由器网关查看连接状态。或者直接用串口打印出来看连接是否成功，如下图：<br><img src="https://img-blog.csdnimg.cn/20190203105204365.png" width="80%" height="80%"><br>&#8195;&#8195;仿真报错时可以参考下面这篇博客：<br>&#8195;&#8195;<a href="https://blog.csdn.net/CSDN_X_W/article/details/86676351" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_X_W/article/details/86676351</a><h2 id="三、从服务器-get-数据"><a href="#三、从服务器-get-数据" class="headerlink" title="三、从服务器 get 数据"></a>三、从服务器 get 数据</h2>&#8195;&#8195;首先需要将上一节的服务器端运行起来，根据服务器去更改CC3200这边的相应请求，再贴上上一节后台服务器的代码一起参考：<br>&#8195;&#8195;<strong>3.1、后台代码：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 处理CC3200 发送过来的 GET 请求 -&gt;查询花卉的浇水量返回给CC3200  <span class="doctag">@TODO</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ResponseBody</span>   <span class="comment">//用于将数据写出去</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/cc3200Query"</span>)   <span class="comment">//这个方法用来处理query请求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt;  <span class="title">cc3200GetResponse</span><span class="params">(@RequestParam <span class="keyword">int</span> monitor_id)</span> </span>&#123;    <span class="comment">//这个字符串拼接的方法来实现sql语句中嵌套变量好嘛？</span></span><br><span class="line">    String querySql = <span class="string">"select * From flowers where monitor_id ="</span> + <span class="string">"'"</span> + monitor_id + <span class="string">"'"</span>;</span><br><span class="line">    <span class="comment">//这样返回的是一个map 而不是 list 的形式更方便CC3200那边去解析</span></span><br><span class="line">    Map&lt;String, Object&gt; map =jdbcTemplate.queryForMap(querySql);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&#8195;&#8195;<strong>3.2、CC3200 相关配置：</strong> </li><li>更改 main.c 中如下配置：&#8195;&#8195;&#8195;&#8195;ip根据自己的实际更改<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_REQUEST_URI  <span class="meta-string">"/cc3200Query?monitor_id=1"</span><span class="comment">//请求方式 即发送什么样的请求  请求参数为monitor_id</span></span></span><br><span class="line"><span class="comment">/*--HOST_NAME HTTP服务器的IP地址或者域名  如我的服务器的IP地址为......--*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST_NAME        <span class="meta-string">"192.168.43.148"</span> <span class="comment">//"&lt;host name&gt;"</span></span></span><br><span class="line"><span class="comment">/*--HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如tomcat的默认端口是8080 http://localhost:8080/--*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST_PORT           8080</span></span><br></pre></td></tr></table></figure><ol><li>==重点：更改所 get 的数据的长度== （没找到相关博客和TI教程我看代码研究了好久，可能C基础较差吧。）<br>&#8195;&#8195;①. len的长度决定了最终放到 g_buff 中数据的个数，否则g_buf中存放的是当前时间。<br>&#8195;&#8195;②. 最终get到的数据就存放再 g_buff 这个静态变量中，可以直接打印到控制台。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readResponse</span><span class="params">(HTTPCli_Handle httpClient)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">long</span> lRetVal = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> len = <span class="number">114</span>;  <span class="comment">//@TODO 重要：这里决定了收到的数据的长度  数值靠数   包括外面的大括号</span></span><br><span class="line"> <span class="keyword">int</span> json = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">char</span> *dataBuffer=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">bool</span> moreFlags = <span class="number">1</span>;</span><br><span class="line"> <span class="comment">//.......</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>再程序的最后把 get 到的数据打印到控制台。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">UART_PRINT(<span class="string">"\n\r"</span>);</span><br><span class="line">UART_PRINT(<span class="string">"HTTP Get Begin:\n\r"</span>);</span><br><span class="line">lRetVal = HTTPGetMethod(&amp;httpClient);</span><br><span class="line"><span class="keyword">if</span>(lRetVal &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    UART_PRINT(<span class="string">"HTTP Post Get failed.\n\r"</span>);</span><br><span class="line">&#125;</span><br><span class="line">UART_PRINT(<span class="string">"HTTP Get End:\n\r"</span>);</span><br><span class="line">UART_PRINT(<span class="string">"\n\r"</span>);</span><br><span class="line"><span class="comment">/*--根据得到的json数据进行解析 Start--*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"g_buff:%s\n"</span>,g_buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"size:%d\n"</span>,<span class="built_in">strlen</span>(g_buff));</span><br></pre></td></tr></table></figure>&#8195;&#8195;这样就可以在控制台打印出如下数据：<br><img src="https://img-blog.csdnimg.cn/2019020311590237.png" weight="70%" height="70%"><br>&#8195;&#8195;<strong>注意：</strong><br>&#8195;&#8195;&#8195;&#8195;①. ==在用printf(“”); 打印时一定要加上换行“\n” ;不然数据是打印不出来的。==<br>&#8195;&#8195;&#8195;&#8195;②. 现在得到的数据为 JSON 格式，如果想得到某一项数据，需要对得到的 JSON 数据进行解析，最好的办法是使用 cJSON 库，具体可参照下面一段代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cJSON *root;</span><br><span class="line">       cJSON *ret;</span><br><span class="line">       root = cJSON_Parse(g_buff);    <span class="comment">//将cJSON字符串转换为cJSON结构体指针</span></span><br><span class="line">       ret = cJSON_GetObjectItem(root, <span class="string">"bulk"</span>);    <span class="comment">//在root结构体中查找"key"这个键(一个字符串),成功返回一个cJSON结构体，失败返回NULL。</span></span><br><span class="line">       bulk=ret-&gt;valueint;<span class="comment">//获取到浇水量</span></span><br><span class="line">       cJSON_Delete(ret);    <span class="comment">//释放cJSON结构体指针</span></span><br><span class="line">       cJSON_Delete(root);    <span class="comment">//释放cJSON结构体指针</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,bulk);<span class="comment">//打印到控制台查看</span></span><br></pre></td></tr></table></figure>==注：== cJSON 的下载地址如下，直接复制 cJSON.c 和 cJSON.h 到工程中使用即可。<br>&#8195;&#8195;<a href="https://sourceforge.net/projects/cjson/" target="_blank" rel="noopener">https://sourceforge.net/projects/cjson/</a></li></ol></li></ol><h2 id="四、学习方法"><a href="#四、学习方法" class="headerlink" title="四、学习方法"></a>四、学习方法</h2><p>&#8195;&#8195;1.TI SDK 中提供了大量的例程，而直接导入例程稍作修改就能够实现我们想要的目的，是一个很好的参考，在看例程的过程中也可以加强编写程序的规范性。</p><p>&#8195;&#8195;2.如果项目中应用到了更多的功能，也可以将相关的例程融合到一起，对于 CC3200 主要的用到的是 driverlib 这个库，各个功能都封装成了API供我们快速开发，很方便。</p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> CC3200 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个简单的后端服务（实现一个简单的物联网系统-2）</title>
      <link href="/2018/04/23/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SpringBoot%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%EF%BC%88-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-2-%EF%BC%89/"/>
      <url>/2018/04/23/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SpringBoot%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%EF%BC%88-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-2-%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>&#8195;&#8195;可以说站在Spring Boot的肩膀上，相对于我之前用最古老的servlet，完成一个简单的后台服务实在变得太容易太容易。但是对于一个完全不了解的人可以参考目录中的<strong>学习方法</strong>。对于实现远程浇花的功能，只需要处理APP 和 CC3200 发送过来的 get 、post 请求即可。</p><h2 id="二、说明"><a href="#二、说明" class="headerlink" title="二、说明"></a>二、说明</h2><p>&#8195;&#8195;①．Spring Boot 只是一个框架，通过联网帮助我们完成了各种配置，简化开发。<br>&#8195;&#8195;②．具体详细的步骤可以在学习SpringBoot的过程中不断实践。<br><strong>注意：IDEA一定要用专业版，社区版的是不能构建SpringBoot项目的，如下图社区版根本没有红色圈中的那项：</strong><br><img src="https://img-blog.csdnimg.cn/20190202185505506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="40%/"></p><h2 id="三、数据库"><a href="#三、数据库" class="headerlink" title="三、数据库"></a>三、数据库</h2><p>&#8195;&#8195;当然后台要负责与数据库进行交互，花卉的信息也全都存放在数据库上。后台的代码就是要对数据库进行增、删、改、查等操作。我用的是MySQL。直接装，或者用Docker。</p><h2 id="四、后台服务代码"><a href="#四、后台服务代码" class="headerlink" title="四、后台服务代码"></a>四、后台服务代码</h2><ol><li>Cotroller部分：这里即包含了APP的后台服务，也包含了CC3200的后台服务，后面不再赘述。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowerManagerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-------------------处理 APP 与后台的交互-----------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 APP 发送过来的 GET 请求 -&gt; 查询花卉的所有信息返回给 APP</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flower_name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>   <span class="comment">//用于将数据写出去</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/appQuery"</span>)   <span class="comment">//这个方法用来处理query请求</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; appGetResponse(<span class="meta">@RequestParam</span> String flower_name) &#123;</span><br><span class="line">        <span class="comment">//字符串拼接的方法来实现sql语句中嵌套变量</span></span><br><span class="line">        String querySql = <span class="string">"select * From flowers where name ="</span> + <span class="string">"'"</span> + flower_name + <span class="string">"'"</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(querySql);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 APP POST 给服务器的数据 -&gt;更新数据库中的浇水量 bulk  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>   <span class="comment">//用于接收APP post 过来的数据</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/appPost"</span>)   <span class="comment">//这个方法用来处理App的post请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appPostResponse</span><span class="params">(@RequestBody String flower_info)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">        <span class="comment">/*--更改花卉的浇水量--*/</span></span><br><span class="line">        String flower_name;</span><br><span class="line">    <span class="keyword">int</span> bulk;</span><br><span class="line">        <span class="comment">//1.解析post过来的数据</span></span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject(flower_info);</span><br><span class="line">        mFlower_name = jsonObject.getString(<span class="string">"name"</span>);</span><br><span class="line">        mBulk = jsonObject.getInt(<span class="string">"bulk"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.根据花卉名称和浇水量更新DB的数据</span></span><br><span class="line">        String updateSql = <span class="string">"update flowers set bulk ="</span> + <span class="string">"'"</span> + bulk + <span class="string">"'"</span> + <span class="string">" WHERE name ="</span> + <span class="string">"'"</span> + flower_name + <span class="string">"'"</span>;    </span><br><span class="line">        jdbcTemplate.update(updateSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-----------------------处理 CC3200 与后台的交互-------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理CC3200 发送过来的 GET 请求 -&gt;查询花卉的浇水量返回给CC3200  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>   <span class="comment">//用于将数据写出去</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/cc3200Query"</span>)   <span class="comment">//这个方法用来处理query请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt;  <span class="title">cc3200GetResponse</span><span class="params">(@RequestParam <span class="keyword">int</span> monitor_id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串拼接的方法来实现sql语句中嵌套变量</span></span><br><span class="line">        String querySql = <span class="string">"select * From flowers where monitor_id ="</span> + <span class="string">"'"</span> + monitor_id + <span class="string">"'"</span>;</span><br><span class="line">        <span class="comment">//这样返回的是一个map 而不是 list 的形式更方便CC3200那边去解析</span></span><br><span class="line">        Map&lt;String, Object&gt; map =jdbcTemplate.queryForMap(querySql);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理CC3200 POST 给服务器的数据 -&gt;更新花卉的状态信息 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>   <span class="comment">//用于接收CC3200 post 过来的数据</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/cc3200Post"</span>)   <span class="comment">//这个方法用来处理CC3200Post请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">CC3200PostResponse</span><span class="params">(@RequestBody String flower_info)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">        <span class="comment">/*--更新花卉的状态信息--*/</span></span><br><span class="line">        <span class="keyword">int</span> monitorID;</span><br><span class="line">    <span class="keyword">float</span> co2;</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//1.解析post过来的数据</span></span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject(flower_info);</span><br><span class="line">        monitorID = jsonObject.getInt(<span class="string">"monitorID"</span>);</span><br><span class="line">        co2 = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"co2"</span>);</span><br><span class="line">        temperature = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"temperature"</span>);</span><br><span class="line">        humidity = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"humidity"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.根据花卉监测系统ID更新数据库的数据</span></span><br><span class="line">        String updateSql =</span><br><span class="line">                <span class="string">"update flowers set co2 ="</span> + <span class="string">"'"</span> + co2 + <span class="string">"'"</span> +<span class="string">","</span>+</span><br><span class="line">                <span class="string">"temperature ="</span>+<span class="string">"'"</span> + temperature + <span class="string">"'"</span> +<span class="string">","</span>+</span><br><span class="line">                <span class="string">"humidity ="</span>+<span class="string">"'"</span> + humidity + <span class="string">"'"</span> +</span><br><span class="line">                <span class="string">" WHERE monitor_id ="</span>+ <span class="string">"'"</span> + monitorID + <span class="string">"'"</span>;</span><br><span class="line">        jdbcTemplate.update(updateSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>application.yaml 部分：这里根据实际的情况配置即可<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://公网IP或域名:3306/数据库名</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="五、学习路线（仅供参考）"><a href="#五、学习路线（仅供参考）" class="headerlink" title="五、学习路线（仅供参考）"></a>五、学习路线（仅供参考）</h2><p>&#8195;&#8195;1. pringBoot 我是通过学习观看 尚硅谷 的Springboot视频学习的，下载地址可以搜哦，有人上传到网盘了，或者哔哩哔哩上也有，而IDEA的使用关注他的微信公众号就可以免费下载，个人感觉还是不错的。反正免费嘛。<br>&#8195;&#8195;2. 在Ubuntu 上使用 Docker 可以参考下面的链接（安装MySQL也是很方便的）。<br>&#8195;&#8195;&#8195;<a href="https://cloud.tencent.com/developer/article/1350956" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1350956</a></p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP与服务器数据交互（实现一个简单的物联网系统-1）</title>
      <link href="/2018/04/20/APP%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-1/"/>
      <url>/2018/04/20/APP%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、APP-POST-数据到服务器"><a href="#一、APP-POST-数据到服务器" class="headerlink" title="一、APP POST 数据到服务器"></a>一、APP POST 数据到服务器</h2><p>&#8195;&#8195;首先 post 的数据应该包括识别这个花卉的信息和我们想要浇水的量，这里我们识别花卉采用花卉的名字，这样后台程序通过花卉名来对应更新数据库中该花的浇水量。</p><ol><li>mFlower_name：花卉名  </li><li>mBulk : 浇水量 </li></ol><p>实现代码如下：<br><strong>注意：</strong></p><ol><li>String urlPath 中的 IP 地址是我局域网的地址，如果你的后台程序是在云服务器上运行的那么应改成云服务器的公网IP。不过可以先在局域网内实现嘛。</li><li>http 的默认端口号为80，但由于我用的是springboot框架打包成的jar包，自带了嵌入的tomcat，而tomcat容器默认的端口号为8080（可以在配置文件（.yml）中更改）。</li><li>服务端的代码可参照专栏中的下一篇文章。<br>&#8195;&#8195;<strong>Code:</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-- 将浇水量等信息上传到服务器    安卓4.0以后必须在子线程中执行 --*/</span></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String urlPath = <span class="string">"http://192.168.43.148:8080/appPost"</span>;  <span class="comment">//URL</span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(urlPath);</span><br><span class="line">            HttpURLConnection coon = (HttpURLConnection) url.openConnection();</span><br><span class="line">            coon.setRequestMethod(<span class="string">"POST"</span>);<span class="comment">//请求方式为POST</span></span><br><span class="line">            coon.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line">            coon.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>);     <span class="comment">//设置发送的数据为 json 类型，会被添加到http body当中</span></span><br><span class="line">            String json = <span class="string">"&#123;\"name\":\""</span>+ mFlower_name+<span class="string">"\","</span> + <span class="string">"\"bulk\":"</span> + <span class="string">"\""</span> +mBulk+ <span class="string">"\"&#125;"</span>;    <span class="comment">//将要发送的花卉数据字符串连接成json格式</span></span><br><span class="line">            coon.setRequestProperty(<span class="string">"Content-Length"</span>, String.valueOf(json.length()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//post请求把数据以流的方式写给服务器，指定请求的输出模式</span></span><br><span class="line">            coon.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">            coon.getOutputStream().write(json.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> code = coon.getResponseCode();</span><br><span class="line">            <span class="keyword">if</span> (code == <span class="number">200</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"请求成功"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"请求失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"请求失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></li></ol><h2 id="二、APP-从服务器-GET-数据"><a href="#二、APP-从服务器-GET-数据" class="headerlink" title="二、APP 从服务器 GET 数据"></a>二、APP 从服务器 GET 数据</h2><p>&#8195;&#8195;APP 同样需要从服务器获得花卉的状态信息来更新显示界面，如更新到最新的土壤湿度、光照强度等显示给用户。<br>实现代码如下：<br><strong>注意：</strong></p><ol><li>从服务器得到的数据为 list 形式，所以解析较复杂一些，这取决于你服务器返回什么样的数据，在下一篇文章会有说明。服务器直接返回 map 形式APP这边会更好解析。具体百度啦！<br><strong>Code:</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查询服务器 得到花卉的信息  更新显示的数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String urlPath = <span class="string">"http://192.168.43.148:8080/appQuery?flower_name="</span> + mFlower_name;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(urlPath);</span><br><span class="line">            HttpURLConnection coon = (HttpURLConnection) url.openConnection();</span><br><span class="line">            coon.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">            coon.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> code = coon.getResponseCode();</span><br><span class="line">            <span class="keyword">if</span> (code == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">//1.得到输入流</span></span><br><span class="line">                InputStream is = coon.getInputStream();</span><br><span class="line">                <span class="comment">//2.将流用自己写的StreamUtils转化为字符串  改字符串为json格式</span></span><br><span class="line">                String flowerInfo = StreamUtils.readStream(is);</span><br><span class="line">                <span class="comment">//3.解析json数据（这里是list形式）  并显示数据</span></span><br><span class="line">                JSONArray flowerJsonArray = <span class="keyword">new</span> JSONArray(flowerInfo);</span><br><span class="line">                <span class="comment">// 这里的数组长度其实是1</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerJsonArray.length(); i++) &#123;</span><br><span class="line">                    JSONObject flowerJsonObject = flowerJsonArray.getJSONObject(i);</span><br><span class="line">                    mTv_temperature.setText(flowerJsonObject.getString(<span class="string">"temperature"</span>));<span class="comment">//温度</span></span><br><span class="line">                    mTv_humidity.setText(flowerJsonObject.getString(<span class="string">"humidity"</span>));<span class="comment">//湿度</span></span><br><span class="line">                    mTv_co2.setText(flowerJsonObject.getString(<span class="string">"co2"</span>));<span class="comment">//CO2 浓度</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Message msg = Message.obtain();</span><br><span class="line">                msg.what = STATUS_ERROR;</span><br><span class="line">                mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><h2 id="三、APP-界面部分"><a href="#三、APP-界面部分" class="headerlink" title="三、APP 界面部分"></a>三、APP 界面部分</h2>&#8195;&#8195;这部分就主要看自己如何去设计了，主要还是要多学习一些，才能做出更好看、功能更加丰富的APP。下面展示一下我做的APP（由于技术原因以及没有艺术细胞，做的着实有些丑）。</li></ol><p><img src="https://img-blog.csdnimg.cn/20190202171426215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="40%" height="40%"></p><p><img src="https://img-blog.csdnimg.cn/20190202172717392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="40%" height="40%"></p><h2 id="四、相关疑问"><a href="#四、相关疑问" class="headerlink" title="四、相关疑问"></a>四、相关疑问</h2><ol><li>后台相关的代码呢？<br> 在下一节贴上我的服务端的代码，其实站在SpringBoot的肩膀上，我们后台的搭建显得异常的容易。</li><li>APP 的其他代码和功能呢？<br> 这里我之列出了POST 和 GET 过程相关的代码，如果真的要实现众多功能，还是要花好长一段时间去学习安卓。</li></ol><h2 id="五、学习方法"><a href="#五、学习方法" class="headerlink" title="五、学习方法"></a>五、学习方法</h2><ol><li>我个人是通过学习完Java以后，在某宝花了几十块钱买的教学视频，还有哔哩哔哩上的天哥在奔跑的视频也还不错，等等。这里仅仅只是个人的学习过程，仅供参考。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> 云服务器 </tag>
            
            <tag> APP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HC-05蓝牙配置</title>
      <link href="/2018/04/18/%E9%85%8D%E7%BD%AE%E8%93%9D%E7%89%99%EF%BC%88HC-05%EF%BC%89%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%88%E5%90%8D%E5%AD%97%E3%80%81%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E5%AF%86%E7%A0%81%E3%80%81%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E7%AD%89%EF%BC%89/"/>
      <url>/2018/04/18/%E9%85%8D%E7%BD%AE%E8%93%9D%E7%89%99%EF%BC%88HC-05%EF%BC%89%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%88%E5%90%8D%E5%AD%97%E3%80%81%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E5%AF%86%E7%A0%81%E3%80%81%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E7%AD%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;有时买回来的蓝牙模块的默认配置不能满足我们的使用需求时，就需要对买回来的蓝牙进行自行配置，比如更改波特率来适应自己的程序，或是更改主、从机的设置等等。即使是用默认的设置也需要对密码进行修改，以免设备和其他人也没有进行配置的蓝牙进行配对连接。下面介绍最长用的HC-05 蓝牙模块的<strong>简单配置方法</strong>。</p><h2 id="二、准备材料"><a href="#二、准备材料" class="headerlink" title="二、准备材料"></a>二、准备材料</h2><ol><li>官方的上位机<br>&#8195;&#8195;下载地址：<a href="http://www.hc01.com/service_download" target="_blank" rel="noopener">http://www.hc01.com/service_download</a><br>&#8195;&#8195;当然如果你是在淘宝买的，卖家基本上都会提供，具体是哪个上位机可以看后面配置过程中的图片。</li><li>一个USB转串口的模块（CH340等）<h2 id="三、连接方式"><a href="#三、连接方式" class="headerlink" title="三、连接方式"></a>三、连接方式</h2>&#8195;&#8195;如下图：<br><img src="https://img-blog.csdnimg.cn/20190514201728368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"><h2 id="四、配置方式"><a href="#四、配置方式" class="headerlink" title="四、配置方式"></a>四、配置方式</h2><h4 id="1-进入AT模式"><a href="#1-进入AT模式" class="headerlink" title="1. 进入AT模式"></a>1. 进入AT模式</h4>&#8195;&#8195;按住蓝牙上的小按键（不要松手），然后上电，上电后即可进入到蓝牙的AT模式下，此时蓝牙上的灯慢闪（两秒暗灭一次），此时松手即可<h4 id="2-打开上位机连接到蓝牙"><a href="#2-打开上位机连接到蓝牙" class="headerlink" title="2. 打开上位机连接到蓝牙"></a>2. 打开上位机连接到蓝牙</h4>&#8195;&#8195;波特率选择38400，这是AT模式下默认的配置所需波特率。点击搜索端口，在波特率右侧显示“端口 x已打开” 说明已经连接到蓝牙，如下图：<br><img src="https://img-blog.csdnimg.cn/20190514202632398.png" width="80%" height="80%"><h4 id="3-获取模块信息"><a href="#3-获取模块信息" class="headerlink" title="3.获取模块信息"></a>3.获取模块信息</h4>&#8195;&#8195;<strong>用手按住蓝牙上的按键，不要松手，同时点击上位机上的获取模块信息</strong>，这是右方的表格中就会显示出当前蓝牙的配置信息。全部显示完之后松开按键。显示如下图，这是默认买回来时的配置：<br><img src="https://img-blog.csdnimg.cn/20190514203312330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"><h4 id="4-更新自己想要的配置"><a href="#4-更新自己想要的配置" class="headerlink" title="4.更新自己想要的配置"></a>4.更新自己想要的配置</h4>&#8195;&#8195;直接在右侧来的输入框中，更改你想要的配置，比如名字、波特率、密码、主从模式等，更改好后，同样<strong>按住蓝牙上的按键，不要松手，点击更新模块信息</strong>，等更新完之后再松开按键，这时就已经配置好了。<br><img src="https://img-blog.csdnimg.cn/20190514203940880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width="80%" height="80%"><h4 id="5-验证配置"><a href="#5-验证配置" class="headerlink" title="5. 验证配置"></a>5. 验证配置</h4>&#8195;&#8195;可点击右上方的清楚表格数据，然后按照第三步的步骤获取模块信息，即可查看已经设置成功的配置了。同样也可以通过此方法查看一个未知蓝牙的配置。最后重新上电，蓝牙就可以进入使用状态了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝牙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建完整物联网系统（CC3200+云服务器）</title>
      <link href="/2018/04/17/%E5%AE%9E%E7%8E%B0%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9F%BA%E4%BA%8E-CC3200%E3%80%81%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89/"/>
      <url>/2018/04/17/%E5%AE%9E%E7%8E%B0%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9F%BA%E4%BA%8E-CC3200%E3%80%81%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;本系列文章主要讲解如何通过 CC3200（简单理解为单片机和WIFI模块的结合体）、云服务器、APP 来实现远程控制。所有的程序全部自己编写，我们可以真正意义上的实现：<br>①. 远程控制家中的热水器烧水<br>②. 远程控制监测环境数据<br>… … 等等。（可以尽情的发挥想象，想象好了就可以开始了！）<br>比如：<strong>我想实现远程浇花这个功能</strong>（因为室友养的花寒暑假没有人照看，实现这样一个功能就很不错）</p><h2 id="二、知识基础"><a href="#二、知识基础" class="headerlink" title="二、知识基础"></a>二、知识基础</h2><p>&#8195;&#8195;要想实现以上功能需要具备以下一些知识技能：<br>&#8195;&#8195;这些知识或许还有好多都不会，甚至有一部分都没有听说过（如果你会很多，那就再好不过了），但是所有的内容都可以去学习呀！我也是从大二下学期开始学习的，大三下学期实现的，而且是机械设计制造及其自动化专业。</p><ol><li>主要编程语言：C、Java。</li><li>主要IDE：CCS、IDEA、AndroidStudio。</li><li>框架：SpringBoot。</li><li>系统：Windows、Linux（Ubuntu）。<br><strong>注：</strong><br>&#8195;&#8195;其实在这个过程中所涉及到的知识还远不止上面这些，如果想学习的更多，理解的更彻底，每一部分都值得深入的去研究、学习。<h2 id="三、主要目标"><a href="#三、主要目标" class="headerlink" title="三、主要目标"></a>三、主要目标</h2></li><li><p>APP与服务器之间进行双向通讯：    要能够通过APP获得花卉的状态数据，比如土壤的湿度，光照强度等等；同时 APP 还要能够将用户浇水的命令上传到服务器。</p></li><li><p>CC3200 与服务器进行双向通讯：    CC3200 将土壤湿度、光照强度等信息上传到服务器，同时CC3200还要能从服务器获取数据。</p></li><li><p>CC3200 控制水泵的浇水实现：    这里主要是控制部分的实现，CC3200要根据从服务器获取的数据，进行浇水的控制。</p><h2 id="四、视频展示"><a href="#四、视频展示" class="headerlink" title="四、视频展示"></a>四、视频展示</h2><p>简单的实现远程的浇水功能：    <a href="https://www.bilibili.com/video/av43996928">点击观看</a></p><h2 id="五、相关疑问"><a href="#五、相关疑问" class="headerlink" title="五、相关疑问"></a>五、相关疑问</h2></li><li>真的有这么容易实现吗？<br>&#8195;&#8195;答案：当然可以，我是用课余时间学习了一年就实现了，不过最好有一部分基础。（比如我之前有单片机的基础，但对于java、安卓、后台一点都不会，就更别说什么框架、Linux了）。</li><li>我该如何学习？<br>①. C语言、Java语言肯定要先学会。<br>②. 单片机开发的基础：用C语言开发。CC3200是一款 TI 公司集MCU和WIFI功能为一体的芯片，或者先学一款单片机，比如STM32（这个教程多），MSP430（TI公司，教程少）等。一通百通。<br>③. 安卓基础：这个是用Java语言开发的。<br>④. 服务和后台：后台代码也是用Java开发，学习Linux的基本操作。<h2 id="六、学习方法"><a href="#六、学习方法" class="headerlink" title="六、学习方法"></a>六、学习方法</h2></li><li>视频资料：如果对某一项技术没有任何了解，通过视频来学习最好不过了，可以选择可以倍速播放视频的软件。</li><li>文档资料：当你有了一定基础之后，看相关文档才是最快，最好用的资料。</li><li>资料推荐：哔哩哔哩、尚硅谷、w3cschool等等。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> CC3200 </tag>
            
            <tag> 云服务 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
