<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PX4开发环境搭建（Ubuntu1804+QGC+Qt Creator ）</title>
      <link href="/2020/03/12/PX4%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88Ubuntu1804-QGC-Qt-Creator-%EF%BC%89/"/>
      <url>/2020/03/12/PX4%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88Ubuntu1804-QGC-Qt-Creator-%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在这之前作者完全没接触过PX4，安装过程遇到了很多坑，而且每安装下载一个东西都要等好久，出现问题又要重新开始，前后折腾了四天才弄好，希望此文对大家有所帮助。</p><h2 id="一、安装环境"><a href="#一、安装环境" class="headerlink" title="一、安装环境"></a>一、安装环境</h2><ol><li>操作系统：windows10</li><li>虚拟机：VMWare</li><li>Linux系统：Ubuntu1804 Desktop（官网推荐）</li><li>科学上网工具(f*q)：Shadowsocks</li></ol><p>备注：</p><ul><li>使用虚拟机而不使用双系统方式的原因在于环境不容易一次安装成功，虚拟机重装系统的话很方便。</li><li>教程中在下载项目中子模块的时候需要科学上网。（当然也提出了另一种加速方式，不过作者没有试验过）<h2 id="二、PX4环境搭建"><a href="#二、PX4环境搭建" class="headerlink" title="二、PX4环境搭建"></a>二、PX4环境搭建</h2><h3 id="1-在虚拟机中安装Ubuntu"><a href="#1-在虚拟机中安装Ubuntu" class="headerlink" title="1. 在虚拟机中安装Ubuntu"></a>1. 在虚拟机中安装Ubuntu</h3>安装过程就不细讲了，可以去找些教程，简单安装即可。</li></ul><ol><li>在电脑中安装VMware：<a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">VMware下载地址</a></li><li>下载Ubuntu1804系统的镜像：<a href="https://ubuntu.com/download/desktop" target="_blank" rel="noopener">Ubuntu镜像下载地址</a><br>注：①. 镜像应下载桌面版（<strong>Desktop</strong>）而非服务器版本（Server），可以通过种子下载也可直接下载，建议用迅雷加速下载。②. <strong>不需要换源</strong>，直接使用系统已有的就好。</li></ol><h3 id="2-安装PX4环境"><a href="#2-安装PX4环境" class="headerlink" title="2. 安装PX4环境"></a>2. 安装PX4环境</h3><p>&ensp;&ensp;&ensp;&ensp;安装过程只有<strong>两步</strong>，只要这两步<strong>没有任何错误</strong>。</p><p>&ensp;&ensp;&ensp;&ensp;参考教程：<a href="https://dev.px4.io/master/en/index.html" target="_blank" rel="noopener">官方教程首页</a>，链接是针对最新版本的代码的，当然搭建好以后也可以编译之前版本的代码，直接看英文的就完事了，中文的最新的可能会存在问题。</p><p>&ensp;&ensp;&ensp;&ensp;即使你可以科学上网，未必也能下载成功，<strong>强烈建议</strong>科学上网的情况下，<strong>早上六点到八点</strong>之间下载源码及安装工具链，<strong>正常情况下执行命令下载是不应该出现Faile和Err的。否则最终就可能出问题。</strong></p><h4 id="1-下载PX4源码："><a href="#1-下载PX4源码：" class="headerlink" title="(1)下载PX4源码："></a>(1)下载PX4源码：</h4><p>参考：<a href="https://dev.px4.io/master/en/setup/dev_env_linux_ubuntu.html" target="_blank" rel="noopener">官方文档</a></p><p>&ensp;&ensp;&ensp;&ensp;通过命令：<code>git clone https://github.com/PX4/Firmware.git --recursive</code> 克隆。克隆地址可以改成你的码云地址。如下：<br><img src="https://img-blog.csdnimg.cn/20200327163421203.png" alt="在这里插入图片描述"><br>①. 完整源码组成：完整的源码由PX4源码和其所需子模块，但是子模块的代码并没有在该仓库下，实际上 clone 时通过 <code>--recursive</code> 参数实现在其他仓库中拉取的。<br>②. 源码地址：<a href="https://github.com/PX4/Firmware" target="_blank" rel="noopener">PX4Github地址</a><br>③. 建议通过码云（国内的github）加速，就是在码云中新建自己的仓库，创建时选择从Github导入，这样相当于他给你做了加速下载这个过程，但是注意，<strong>其所需的子模块并没有实现加速。</strong>（我闲麻烦没有这样做：所有的所需 submodule子模块内容都可以通过修改 .gitmodules为国内码云上的地址来加速下载，当然就需要你为每一个子模块都在码云建一个仓库）</p><p>码云的仓库：<br><img src="https://img-blog.csdnimg.cn/20200327161608471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt=""><br>如果你采取全部通过码云加速的方式，需要修改如下位置（可以科学上网f*q的话不建议）：<br><img src="https://img-blog.csdnimg.cn/20200327161857574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-安装工具链"><a href="#2-安装工具链" class="headerlink" title="(2) 安装工具链"></a>(2) 安装工具链</h4><p><strong>重要</strong>：在这之前确保源码及其子模块都完整下载。<br>在Firmware目录下执行（建议早上8点前）：<code>bash ./Tools/setup/ubuntu.sh</code>，这个过程可能比较久，确保整个过程无错误，成功后最重要的就是已经安装了<strong>正确版本</strong>的arm-none-eabi-gcc，安装后执行<code>arm-none-eabi-gcc --version</code> 如下：<br><img src="https://img-blog.csdnimg.cn/20200327163909142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3-jMAVSim仿真"><a href="#3-jMAVSim仿真" class="headerlink" title="(3)  jMAVSim仿真"></a>(3)  jMAVSim仿真</h4><p>参考官方教程Firmware下去执行：<code>make px4_sitl jmavsim</code>，效果如下：<br><img src="https://img-blog.csdnimg.cn/20200327171019491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="4-编译验证"><a href="#4-编译验证" class="headerlink" title="(4) 编译验证"></a>(4) 编译验证</h4><p>根据你要编译的版本，在Firmware目录下执行<br><img src="https://img-blog.csdnimg.cn/20200327170525152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="三、安装QGC"><a href="#三、安装QGC" class="headerlink" title="三、安装QGC"></a>三、安装QGC</h2><p>官方文档：<a href="https://docs.qgroundcontrol.com/en/getting_started/download_and_install.html" target="_blank" rel="noopener">QGC安装教程</a>（建议点进来看看，因为我的所有内容都是按照官方教程写的）</p><p>1.按顺序执行以下命令  然后<strong>重启</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G dialout $USER</span><br><span class="line">sudo apt-get remove modemmanager -y</span><br><span class="line">sudo apt install gstreamer1.0-plugins-bad gstreamer1.0-libav -y</span><br></pre></td></tr></table></figure><br>2.下载QGC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;s3-us-west-2.amazonaws.com&#x2F;qgroundcontrol&#x2F;latest&#x2F;QGroundControl.AppImage</span><br></pre></td></tr></table></figure><br>3.安装<br><code>chmod +x ./QGroundControl.AppImage</code></p><p>4.运行</p><ul><li>通过命令运行<code>./QGroundControl.AppImage</code></li><li>或者双击图标：<br><img src="https://img-blog.csdnimg.cn/2020032716560175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="四、安装Qt-Creator"><a href="#四、安装Qt-Creator" class="headerlink" title="四、安装Qt Creator"></a>四、安装Qt Creator</h2></li></ul><ol><li>更新源：<code>sudo apt-get update</code></li><li>用户目录下直接执行 <code>sudo apt-get install qtcreator</code> </li><li>在应用内找打图标运行就OK<br><img src="https://img-blog.csdnimg.cn/20200327170204463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过QT Creator开发，照着文档做就好<br><img src="https://img-blog.csdnimg.cn/2020032717122713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4开发基础</title>
      <link href="/2020/03/07/PX4%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/03/07/PX4%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一、与无人机的缘分"><a href="#一、与无人机的缘分" class="headerlink" title="一、与无人机的缘分"></a>一、与无人机的缘分</h2><p>&ensp;&ensp;&ensp;&ensp;做无人机是源于<strong>电赛</strong>，因为对无人机比较发烧就分到了无人机的组里，参加的三次电赛两次是做的无人机的题目，虽然后来不再做该方向的，但也算我的一项爱好吧，加上现在毕设是给老师搭建一个<strong>PX4</strong>的平台（比赛没用过PX4），因为无人机开发比较小众，价格贵、学习环境少并具有一定难度，外加发展的时间并不是很长，开发中就遇到了很多问题，在此做一些记录。</p><h2 id="二、开发前"><a href="#二、开发前" class="headerlink" title="二、开发前"></a>二、开发前</h2><p>&ensp;&ensp;&ensp;&ensp;这套开源软件的功能相当的齐全，实际上通过烧录PX4的固件，通过地面站的设置，就可以实现<strong>很多</strong>功能了，因此决定了你是否需要涉及到源码层面的开发。</p><h2 id="三、背景知识"><a href="#三、背景知识" class="headerlink" title="三、背景知识"></a>三、背景知识</h2><p>注：内容来自于一些资料和自我总结</p><h3 id="硬件PIXHAWK"><a href="#硬件PIXHAWK" class="headerlink" title="硬件PIXHAWK"></a>硬件PIXHAWK</h3><p>&ensp;&ensp;&ensp;&ensp;Pixhawk是第一款专门为PX4自驾软件而设计的无人机飞控。Pixhawk飞控是开源硬件架构，pixhawk系列”的板子在NuttX操作系统上运行PX4。全世界很多公司出品了基于Pixhawk的飞控产品。他们都有共同的硬件架构和相同的连接方式、输出接口及功能，仅仅是具体形式不同而已，例如接口的位置不同、外壳不同等等。</p><h5 id="pixhawkV1："><a href="#pixhawkV1：" class="headerlink" title="pixhawkV1："></a>pixhawkV1：</h5><p>&ensp;&ensp;&ensp;&ensp;第一版飞控，也被称作FMUv1,它包含PX4FMU和PX4IO两部分。PX4FMU是Pixhawk v1飞控的核心控制部分，主要负责姿态解算等等算法的执行；PX4IO主要负责飞控各外设接口的管理。下面的样子（市面已经看不到了）：<br><img src="https://img-blog.csdnimg.cn/20200326214821478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"></p><h5 id="pixhawkV2："><a href="#pixhawkV2：" class="headerlink" title="pixhawkV2："></a>pixhawkV2：</h5><p>&ensp;&ensp;&ensp;&ensp;继FMUv1飞控之后，第二代飞控被称为Pixhawk v2或FMUv2。在FMUv2这个版本飞控中，第一代中的PX4FMU和PX4IO被合并到了一个PCB上，成为了真正的一体化飞控。（市面还有很多卖的主要都是在这个基础上改进优化，比如处理器、传感器等的提升）<br><img src="https://img-blog.csdnimg.cn/2020032621510640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"></p><h5 id="pixhawkV3x："><a href="#pixhawkV3x：" class="headerlink" title="pixhawkV3x："></a>pixhawkV3x：</h5><p>&ensp;&ensp;&ensp;&ensp;比如我用的是如下的雷迅生产的V3x，到现在甚至已经出了到了<strong>V5</strong>，但是主要没有差太多。</p><p><img src="https://img-blog.csdnimg.cn/20200326215221385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"></p><h3 id="软件代码"><a href="#软件代码" class="headerlink" title="软件代码"></a>软件代码</h3><h5 id="ArduPilot"><a href="#ArduPilot" class="headerlink" title="ArduPilot"></a>ArduPilot</h5><p>&ensp;&ensp;&ensp;&ensp;APM固件程序比较<strong>混乱，零散</strong>。维护者多，代码风格不太统一，而且是单片机这种调用程序，<strong>不好入门。但是成熟稳定</strong>，支持硬件多。APM固件有ArduCopter社区支撑。</p><h5 id="PX4（推荐）"><a href="#PX4（推荐）" class="headerlink" title="PX4（推荐）"></a>PX4（推荐）</h5><p>&ensp;&ensp;&ensp;&ensp;PX4固件，在<strong>nuttx</strong>嵌入式<strong>实时操作系统</strong>上运行。采用多任务，模块化设计。相对来说方便入门，代码风格比较统一。PX4的是BSD协议，BSD协议可以将开源软件<strong>二次开发后用作商业用途。</strong> 着=这也就是当前很多公司的产品甚至就是直接在这个上面改装的。</p><h3 id="地面站（GCS）"><a href="#地面站（GCS）" class="headerlink" title="地面站（GCS）"></a>地面站（GCS）</h3><h5 id="Mission-Planner（MP）"><a href="#Mission-Planner（MP）" class="headerlink" title="Mission Planner（MP）"></a>Mission Planner（MP）</h5><p>&ensp;&ensp;&ensp;&ensp;支持Mavlink协议，一般用于APM的代码，当前使用的人比较多（截至到2020年之前），不支持Mac OS</p><h5 id="QGroundControl（QGC）"><a href="#QGroundControl（QGC）" class="headerlink" title="QGroundControl（QGC）"></a>QGroundControl（QGC）</h5><p>&ensp;&ensp;&ensp;&ensp;支持Mavlink协议，一般用于PX4代码，使用的人较少（<strong>未来趋势</strong>），PX4官方推荐的地面站软件。</p><ul><li>手机系统: Android 和 iOS (目前专注于平板电脑)</li><li>桌面系统: Windows, Linux, Mac OS</li></ul><h2 id="四、我的开发环境"><a href="#四、我的开发环境" class="headerlink" title="四、我的开发环境"></a>四、我的开发环境</h2><ol><li>硬件（hardware）：pixhawkV3x</li><li>软件（software）：PX4</li><li>操作系统（OS）：Ubuntu 1804 桌面版</li><li>地面站（GCS）：QGC</li><li>集成开发环境（IDE）：QT creater</li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx代理时在gunicorn的日志中记录真实访问IP</title>
      <link href="/2020/02/25/Nginx%E4%BB%A3%E7%90%86%E6%97%B6%E5%9C%A8gunicorn%E7%9A%84%E6%97%A5%E5%BF%97%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9C%9F%E5%AE%9E%E8%AE%BF%E9%97%AEIP/"/>
      <url>/2020/02/25/Nginx%E4%BB%A3%E7%90%86%E6%97%B6%E5%9C%A8gunicorn%E7%9A%84%E6%97%A5%E5%BF%97%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9C%9F%E5%AE%9E%E8%AE%BF%E9%97%AEIP/</url>
      
        <content type="html"><![CDATA[<h2 id="一、问题概述"><a href="#一、问题概述" class="headerlink" title="一、问题概述"></a>一、问题概述</h2><p>在通过Nginx负载均衡的情况下，gunicorn的log中记录的访问访问日志并不是用户的IP，而是Nginx主机的IP。</p><h2 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h2><h4 id="1-Nginx配置："><a href="#1-Nginx配置：" class="headerlink" title="1. Nginx配置："></a>1. Nginx配置：</h4><p>其中<code>proxy_set_header X-Real-IP $remote_addr;</code>在请求头中加入了真实的用户IP信息，并一起发送给了后端的gunicorn 服务。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /api &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://zy_ems;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-gunicorn配置"><a href="#2-gunicorn配置" class="headerlink" title="2. gunicorn配置"></a>2. gunicorn配置</h4><p>在gunicorn的启动配置文件中添加下面一段配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log_format &#x3D; &#39;%(h)s %(l)s %(u)s %(t)s &quot;%(r)s&quot; %(s)s %(b)s &quot;%(f)s&quot; &quot;%(a)s&quot; &quot;%(&#123;X-Real-IP&#125;i)s&quot;&#39;</span><br></pre></td></tr></table></figure><br>前面的内容为其他的信息，最后的<code>&quot;%({X-Real-IP}i)s&quot;</code>是在日志中加入用户真实的访问IP。<br>具体关于日志格式的定制可参考：<br><a href="http://docs.gunicorn.org/en/latest/settings.html#logging" target="_blank" rel="noopener">1. gunicorn官网(logging)</a><br><a href="https://stackoverflow.com/questions/25737589/gunicorn-doesnt-log-real-ip-from-nginx" target="_blank" rel="noopener">2.Gunicorn doesn’t log real ip from nginx</a><br><img src="https://img-blog.csdnimg.cn/20200317212951176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" alt="官方文档"></p><h2 id="三、实现效果"><a href="#三、实现效果" class="headerlink" title="三、实现效果"></a>三、实现效果</h2><p>上面两条日志为访问配置前，日志的内容只有nginx的ip，最后一条日志为配置后，除了有nginx的ip之外，追加了用户的ip信息。<br><img src="https://img-blog.csdnimg.cn/20200317213156316.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> gunicorn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Docker部署Flask应用（gunicorn+gevent）</title>
      <link href="/2020/02/23/%E9%80%9A%E8%BF%87Docker%E9%83%A8%E7%BD%B2Flask%E5%BA%94%E7%94%A8%EF%BC%88gunicorn-gevent%EF%BC%89/"/>
      <url>/2020/02/23/%E9%80%9A%E8%BF%87Docker%E9%83%A8%E7%BD%B2Flask%E5%BA%94%E7%94%A8%EF%BC%88gunicorn-gevent%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、项目架构"><a href="#一、项目架构" class="headerlink" title="一、项目架构"></a>一、项目架构</h2><p>&ensp;&ensp;&ensp;&ensp;前后端分离项目中，为缓解服务器压力，通常我们后端代码会部署到多个服务器上，而通过Docker容器虚拟化技术可以让我们避免因开发和运维之间配置环境、运行环境、操作系统、运行依赖包等不同导致的项目部署后无法运行的问题，同时也简化了部署过程。这里后端使用的是gunicorn，相当于java开发者熟悉的tomcat。<br>&ensp;&ensp;&ensp;&ensp;当然下面的架构还可以进一步根据你的应用场景继续完善，如高可用的Nginx，一主二从的数据库等。<br><img src="https://img-blog.csdnimg.cn/202003161833256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><h2 id="二、Docker安装"><a href="#二、Docker安装" class="headerlink" title="二、Docker安装"></a>二、Docker安装</h2><p>&ensp;&ensp;&ensp;&ensp;默认你已经在宿主机上安装了Docker，如果没有安装可以参考：<a href="https://blog.csdn.net/CSDN_X_W/article/details/103847762" target="_blank" rel="noopener">Ubuntu安装Docker(阿里源/官方源)</a></p><h2 id="三、获取需求文件requirements-txt"><a href="#三、获取需求文件requirements-txt" class="headerlink" title="三、获取需求文件requirements.txt"></a>三、获取需求文件requirements.txt</h2><p>&ensp;&ensp;&ensp;&ensp;在虚拟环境中运行命令：<code>pip  freeze  &gt; requirements.txt</code>，requirements.txt文件内容为项目工程所需的模块。</p><h2 id="四、gunicorn配置文件"><a href="#四、gunicorn配置文件" class="headerlink" title="四、gunicorn配置文件"></a>四、gunicorn配置文件</h2><p>&ensp;&ensp;&ensp;&ensp;配置文件内容可根据自己的服务器配置进行调整。<br>gunicorn.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进程数</span></span><br><span class="line">workers = <span class="number">2</span></span><br><span class="line"><span class="comment"># 每个进程的线程数</span></span><br><span class="line">threads = <span class="number">4</span></span><br><span class="line"><span class="comment"># 端口5000</span></span><br><span class="line">bind = <span class="string">'0.0.0.0:5000'</span></span><br><span class="line"><span class="comment"># 工作模式协程</span></span><br><span class="line">worker_class = <span class="string">'gevent'</span></span><br><span class="line"><span class="comment"># 最大并发量</span></span><br><span class="line">worker_connections = <span class="number">100</span></span><br><span class="line"><span class="comment"># 进程pid文件</span></span><br><span class="line">pidfile = <span class="string">'gunicorn.pid'</span></span><br><span class="line"><span class="comment"># 访问日志和错误信息日志的路径</span></span><br><span class="line">accesslog = <span class="string">'/logs/gunicorn_acess.log'</span></span><br><span class="line">errorlog  = <span class="string">'/logs/gunicorn_error.log'</span></span><br><span class="line"><span class="comment"># 日志记录级别</span></span><br><span class="line">loglevel = <span class="string">'info'</span></span><br><span class="line"><span class="comment"># 代码发生变化是否自动重启</span></span><br><span class="line">reload = <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><h2 id="五、编写Dockerfile"><a href="#五、编写Dockerfile" class="headerlink" title="五、编写Dockerfile"></a>五、编写Dockerfile</h2><h4 id="0-前提"><a href="#0-前提" class="headerlink" title="0. 前提"></a>0. 前提</h4><p>&ensp;&ensp;&ensp;&ensp;在Linux系统下选择一个目录作为项目的工程目录：如<code>/beyonderwei/flask</code>，Dockerfile和requirements.txt均直接放在该目录下，并新建三个文件夹 <code>mkdir ./src ./logs ./conf</code>，作为与容器映射的数据卷。将gunicorn.py 放到conf文件夹下，src下存放的是你的项目代码，logs用来以后直接在宿主机查看运行日志，里面的文件在运行容器后自动生成。<br>src文件夹(项目代码)：<br><img src="https://img-blog.csdnimg.cn/20200316194218279.png"></p><h4 id="1-选择python环境"><a href="#1-选择python环境" class="headerlink" title="1. 选择python环境"></a>1. 选择python环境</h4><p>&ensp;&ensp;&ensp;&ensp;因为我们自己的镜像是以某个版本的python作为父镜像的，因此需要根据你的应用环境进行选择，并通过docker在DockerHub中下载相应版本的镜像到本地。比如我使用的python版本为3.7.4</p><h4 id="2-Dockerfile"><a href="#2-Dockerfile" class="headerlink" title="2. Dockerfile"></a>2. Dockerfile</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FROM python:<span class="number">3.7</span><span class="number">.4</span></span><br><span class="line">MAINTAINER <span class="string">"Beyonderwei&lt;beyonderwei@gmail.com&gt;"</span></span><br><span class="line"><span class="comment"># 清华源</span></span><br><span class="line">ENV PIP_SOURCE <span class="string">"https://pypi.tuna.tsinghua.edu.cn/simple"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来存放源程序、日志和配置文件</span></span><br><span class="line">RUN mkdir /src /logs /conf</span><br><span class="line"></span><br><span class="line">WORKDIR /logs</span><br><span class="line"></span><br><span class="line">RUN pip install -i $&#123;PIP_SOURCE&#125; flask</span><br><span class="line">RUN pip install -i $&#123;PIP_SOURCE&#125; gunicorn</span><br><span class="line">RUN pip install -i $&#123;PIP_SOURCE&#125; gevent</span><br><span class="line"></span><br><span class="line">COPY ./requirements.txt ./</span><br><span class="line">RUN pip install -i $&#123;PIP_SOURCE&#125; requirements.txt</span><br><span class="line">EXPOSE <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"gunicorn"</span>, <span class="string">"-c"</span>, <span class="string">"/conf/gunicorn.py"</span>, <span class="string">"main:app"</span>]</span><br></pre></td></tr></table></figure><h2 id="六、build得到镜像"><a href="#六、build得到镜像" class="headerlink" title="六、build得到镜像"></a>六、build得到镜像</h2><ol><li>直接在上述的工程目录下执行：<code>docker build -t 镜像名:[镜像版本] .</code></li><li>查看镜像：<code>docker images</code><h2 id="七、运行镜像"><a href="#七、运行镜像" class="headerlink" title="七、运行镜像"></a>七、运行镜像</h2><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4>&ensp;&ensp;&ensp;&ensp;确保你的src目录下已经存放了项目文件，不然会在运行容器时因为找不到对应的文件，（当然也可以在启动容器后将项目文件放入，但确保通过以下命令运行，因为通过容器数据卷映射的方式，当添加了项目文件后，容器内对应目录也会有该文件）。<h4 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h4>项目目录下执行：<br><code>docker run -d -p 5000:5000 --name 容器名 -v /beyonderwei/flask/src:/src -v /beyonderwei/flask/logs:/logs -v /beyonderwei/flask/conf:/conf 镜像名:[镜像版本号]</code><br>注：如果使用的端口不是5000的话，需要在Dockerfile中也进行修改。<h4 id="将镜像上传到阿里云"><a href="#将镜像上传到阿里云" class="headerlink" title="将镜像上传到阿里云"></a>将镜像上传到阿里云</h4>&ensp;&ensp;&ensp;&ensp;将镜像上传到阿里云的镜像仓库可方便以后在需求文件相同的时候直接拉下来使用，参考该文章后面部分：<a href="https://blog.csdn.net/CSDN_X_W/article/details/103847762" target="_blank" rel="noopener">阿里云镜像存储服务</a><h2 id="八、应用测试"><a href="#八、应用测试" class="headerlink" title="八、应用测试"></a>八、应用测试</h2>&ensp;&ensp;&ensp;&ensp;<strong>如果我们的项目main.app内容如下</strong>，可以在浏览器访问 <a href="http://ip:5000" target="_blank" rel="noopener">http://ip:5000</a> 并返回 “hello world”。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def index():</span><br><span class="line">    return &#39;hello world&#39;</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run(host&#x3D;&#39;0.0.0.0&#39;, port &#x3D; 5000)</span><br></pre></td></tr></table></figure></li></ol><h2 id="九、日志查看"><a href="#九、日志查看" class="headerlink" title="九、日志查看"></a>九、日志查看</h2><p>&ensp;&ensp;&ensp;&ensp;可在宿主机logs下查看访问日志：<br><img src="https://img-blog.csdnimg.cn/20200316201722464.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Flask </tag>
            
            <tag> gunicorn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装Nginx实现反向代理</title>
      <link href="/2020/02/15/Docker%E5%AE%89%E8%A3%85Nginx%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2020/02/15/Docker%E5%AE%89%E8%A3%85Nginx%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、配置文件"><a href="#一、配置文件" class="headerlink" title="一、配置文件"></a>一、配置文件</h2><p>&ensp;&ensp;&ensp;&ensp;以前的配置文件为一个nginx.conf，新的版本将其分成了两个，default.conf 和 nginx.conf，为通过数据卷映射的方式，但没有在github上找到分开的这两个文件，因此先通过直接运行的方式得到这两个文件。</p><ol><li>先普通方式运行一个nginx容器<br><code>docker run --name my-nginx -p 80:80 -d nginx</code><br>注：阿里云的80端口被占用了，因此要把原有的kill 掉。查看端口pid：<code>netstat -tanlp</code> ，杀掉进程：<code>kill 进程pid</code>。</li><li>进入容器，将default.conf 和 nginx.conf两个文件复制到宿主机。<br>将容器中的文件拷贝到宿主机：<code>docker cp 容器ID:容器内文件路径 宿主机路径</code>，（<strong>注：</strong>命令在宿主机中执行，冒号前后没有空格）。<h2 id="二、通过宿主机的配置文件启动"><a href="#二、通过宿主机的配置文件启动" class="headerlink" title="二、通过宿主机的配置文件启动"></a>二、通过宿主机的配置文件启动</h2>命令：<br><code>docker run --name my-nginx -p 80:80 -v /xxx/mynginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /xxx/mynginx/conf/default.conf:/etc/nginx/conf.d/default.conf -d nginx</code><br>说明：</li></ol><ul><li>-v：数据卷绑定（将宿主机的配置文件，与容器内配置文件进行绑定）</li><li>注：还可以绑定log等其他文件<h2 id="三、反向代理"><a href="#三、反向代理" class="headerlink" title="三、反向代理"></a>三、反向代理</h2>打开 default.conf ，如我们部署在tomcat /webapps/xxx/下的项目，配置如下：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        root  html;</span><br><span class="line">        proxy_pass http://你的ip:8080/xxx/;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><strong>重启nginx</strong>：</li></ul><ol><li>方式一：通过Docker重启容器：修改的配置文件会生效 <code>docker stop ID</code>，<code>docker start ID</code>。</li><li>方式二：在nginx容器内(/usr/local/sbin/)通过<code>nginx -s reload</code>重新加载配置的方式容器会直接停止，然后重新 <code>docker start ID</code> 启动即可。</li></ol><p>这样，当我们直接访问nginx所在服务器的ip（由于是80端口），即可直接访问到代理服务器。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打包Vue项目部署到Nginx并访问</title>
      <link href="/2020/02/08/%E6%89%93%E5%8C%85Vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Nginx%E5%B9%B6%E8%AE%BF%E9%97%AE/"/>
      <url>/2020/02/08/%E6%89%93%E5%8C%85Vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Nginx%E5%B9%B6%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>把 Nginx 做为静态资源服务器，用来部署前端项目，本文介绍 Vue 项目打包、部署到 Nginx 的过程，并解决部署后，因 vue-router 使用 history 模式导致的在直接访问项目和点击路由链接时可以访问，而根地址刷新页面空白的问题。</p><h2 id="二、打包项目"><a href="#二、打包项目" class="headerlink" title="二、打包项目"></a>二、打包项目</h2><p><strong>Vue的有关build、config的文件均保持原本的配置即可，无需更改</strong> ，终端输入<code>npm run build</code>，成功后会在项目中看到打包好的项目在dist文件夹中。为了去掉URL中的 “ # ”，此时我们 vue-router 使用的是 history 模式，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: [...]</span><br><span class="line">  )&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三、Docker安装Nginx并部署项目"><a href="#三、Docker安装Nginx并部署项目" class="headerlink" title="三、Docker安装Nginx并部署项目"></a>三、Docker安装Nginx并部署项目</h2><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><ol><li>阿里云ECS</li><li>Ubuntu 系统</li><li>Docker容器化<br><strong>注：</strong> 默认已经通过Docker下载好 Nginx 镜像<h3 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h3></li><li>运行 Nginx 容器<br>关于在 Docker 中运行 Nginx 容器，以及其<strong>配置文件</strong>的有关问题请参考：<a href="https://blog.csdn.net/CSDN_X_W/article/details/104721804" target="_blank" rel="noopener">在Docker中运行Nginx</a> 的前两部分。</li><li>进入容器，并在 根目录下新建文件夹 xxx（比如你项目的名字）<br>进入容器命令：<code>deocekr exec -it 容器名 bash</code></li><li>将打包好的文件（/dist 文件 index.html 和static文件夹）放到Nginx容器 /xxx/  下<br><strong>涉及的命令：</strong><br>①. <code>docker cp 宿主机中文件路径及容器文件名 容器名：要拷贝到容器里面对应的路径</code><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3>修改 http server 的location部分如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">root</span> <span class="string">/xxx;</span> <span class="comment"># index.html 和 static 所在的目录</span></span><br><span class="line"><span class="string">index</span> <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line"><span class="string">try_files</span> <span class="string">$uri</span> <span class="string">$uri/</span> <span class="string">/index.html;</span> <span class="comment"># 为解决 history 模式下，刷新页面时空白的额问题。</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>相关配置参考 <a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">vue-router官方教程。</a><h2 id="四、重启容器并访问"><a href="#四、重启容器并访问" class="headerlink" title="四、重启容器并访问"></a>四、重启容器并访问</h2></li><li>重启nginx容器：<code>docker stop 容器id</code>，<code>docker start 容器id</code>。</li><li>浏览器访问（docker 映射nginx为80端口时）：<a href="http://ip。" target="_blank" rel="noopener">http://ip。</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端通过MathJax显示数学公式</title>
      <link href="/2020/01/10/%E5%89%8D%E7%AB%AF%E9%80%9A%E8%BF%87MathJax%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%EF%BC%88vue-MathJax%EF%BC%89/"/>
      <url>/2020/01/10/%E5%89%8D%E7%AB%AF%E9%80%9A%E8%BF%87MathJax%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%EF%BC%88vue-MathJax%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于MathJax"><a href="#一、关于MathJax" class="headerlink" title="一、关于MathJax"></a>一、关于MathJax</h2><ol><li>官方网址：<a href="https://docs.mathjax.org/en/latest/web/start.html" target="_blank" rel="noopener">MathJax使用文档</a> </li><li>简介：MathJax支持使用LaTeX，MathML或AsciiMath语法在网页中渲染数学公式。我们常用的语法为LaTex,比如该论坛支持的也是<a href="https://www.latex-project.org/" target="_blank" rel="noopener">LaTex</a> 。<h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2>&ensp;&ensp;&ensp;&ensp;想实现在用户选择文件后能够直接在前端预览文件内容，如下：<br><img src="https://img-blog.csdnimg.cn/20200228192716795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width = 80% height =80%></li></ol><h2 id="三、遇到的问题"><a href="#三、遇到的问题" class="headerlink" title="三、遇到的问题"></a>三、遇到的问题</h2><h3 id="问题1-没有渲染效果"><a href="#问题1-没有渲染效果" class="headerlink" title="问题1(没有渲染效果)"></a>问题1(没有渲染效果)</h3><p><strong>问题描述：</strong><br>&ensp;&ensp;&ensp;&ensp;官网推荐使用CDN的方式，因此按照要求在index.html中添加了标签，并在vue组件中渲染。依然还是上面那个样子，并没有对公式进行渲染显示。<br>index.html:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">id</span>=<span class="string">"MathJax-script"</span> <span class="attr">async</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br>xxx.vue：对question进行监视，内容改变后渲染界面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">      question: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">window</span>.MathJax.Hub.Queue([<span class="string">"Typeset"</span>, MathJax.Hub]);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>解决办法：</strong><br>&ensp;&ensp;&ensp;&ensp;原来由于被qiang的原因，MathJax官网给出的加速的CDN是国外的，速度慢的感人，因此看不到效果，因此换成了国内的（<a href="https://www.bootcdn.cn/mathjax/" target="_blank" rel="noopener">BootCDN</a> 等），由于好多CDN不提供该服务，终于找到一个可以用的。cloudflare的，如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">async</span> </span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br>然后终于显示出来了，如下图：<br><img src="https://img-blog.csdnimg.cn/20200228194914607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width = 80% height =80%></p><h3 id="问题2-行间公式不被渲染"><a href="#问题2-行间公式不被渲染" class="headerlink" title="问题2(行间公式不被渲染)"></a>问题2(行间公式不被渲染)</h3><p><strong>问题描述：</strong><br>&ensp;&ensp;&ensp;&ensp;看上图红框中的内容发现，还是有一部分行间公式没有被渲染，显示的依然是原来的状态。<br><strong>解决办法：</strong><br>&ensp;&ensp;&ensp;&ensp;仔细阅读<a href="https://docs.mathjax.org/en/latest/web/start.html" target="_blank" rel="noopener">MathJax使用文档</a> 发现，在MathJax的配置中说明了，如果想支持行间公司，需要做如下配置：注意2.x版本与3.x版本配置的书写方式不同，当然上面用的是2.7.5版本，因此就使用如下配置方式：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"</span>&gt;</span></span><br><span class="line">     MathJax.Hub.Config(&#123;</span><br><span class="line"><span class="actionscript">       tex2jax: &#123;inlineMath: [[<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">'\('</span>,<span class="string">'\)'</span>]]&#125;</span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这样上面那个问题完美解决，效果如下：<br><img src="https://img-blog.csdnimg.cn/20200228195801995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width = 80% height =80%></p><h2 id="四、未来的方向"><a href="#四、未来的方向" class="headerlink" title="四、未来的方向"></a>四、未来的方向</h2><p>原本很想使用3.0及以上版本的，奈何没找到合适的国内CDN加速，待高手评论区指点~~~</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MathJax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册-登录实现过程详解</title>
      <link href="/2020/01/02/%E6%B3%A8%E5%86%8C-%E7%99%BB%E5%BD%95-%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/01/02/%E6%B3%A8%E5%86%8C-%E7%99%BB%E5%BD%95-%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>&ensp;&ensp;&ensp;&ensp;一般的平台基本上都有用户管理这一部分，虽然我们都是各个平台的用户，对于一般的流程有所了解，看似简单，但是真正实现的过程中确遇到了很多的困难。</p><h2 id="二、实现过程图解"><a href="#二、实现过程图解" class="headerlink" title="二、实现过程图解"></a>二、实现过程图解</h2><h3 id="注册："><a href="#注册：" class="headerlink" title="注册："></a>注册：</h3><p><img src="https://img-blog.csdnimg.cn/20200123183013482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width=90% height=90%><br>看似过程似乎很简单但是这过程还有很多需要考虑的因素，采取邮箱发送验证码的方式实现验证：</p><ol><li>验证码如何产生：<br> &ensp;&ensp;&ensp;&ensp;通常我们的验证码是0-9中的六个或者四个数字，因此需要循环产生四个或者六个随机数字。python版可参考：<a href="https://blog.csdn.net/CSDN_X_W/article/details/103844723" target="_blank" rel="noopener">使用Flask发送邮件</a></li><li>验证码保存到哪里？如何设置验证码的有效期？<br> &ensp;&ensp;&ensp;&ensp;验证码和用户邮箱是需要绑定存储到数据库用来后端验证的，而验证码是有有效期的，因此采用Redis来存储更为方便，在set数据时直接设置数据的有效期。当然也可以通过MySQL来实现。只是稍微繁琐些，但注册成功后的用户数据一般都是存储在MySQL中。</li><li>验证成功后，为了保证安全，用户名和密码等需要加密后存储到数据库<br>&ensp;&ensp;&ensp;&ensp;那么如何加密呢？加密算法有很多（对称、非对称、线性散列算法等），而用户的密码等信息是对安全度要求很高的信息，因此采用了SHA-1（线性散列加密的一种）加密。</li></ol><h3 id="登录："><a href="#登录：" class="headerlink" title="登录："></a>登录：</h3><p><img src="https://img-blog.csdnimg.cn/20200123201003163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=90% height=90%></p><ol><li>通常有些接口的访问都是有权限的，那么如何进行验证呢？<br>&ensp;&ensp;&ensp;&ensp;验证方式通常有cookie、session、token、JWT等，和加密方式一样，需要根据不同情况进行选择，在前后端分离中使用了JWT（Json Web Token），JWT使用公钥签名生成并保存到用户本地，减少了查询服务器的压力。</li><li>既然前端访问接口时需要携带jwt，那么jwt字符串存储在哪里呢？<br>因为每次访问某些接口时都需要携带jwt字符串，那么存储在哪里也是个问题，可以考虑的方式包括：cookie等（可根据场景选择），我选择的方式是localStrong方式来存储。</li></ol><p><strong>注：</strong> 各种加密算法的选择与对比、验证方式选择、jwt存储方式对比等仍需另外写博客完善。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 登录 </tag>
            
            <tag> 注册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GitBook完成你的创作</title>
      <link href="/2019/11/04/%E4%BD%BF%E7%94%A8GitBook%E5%AE%8C%E6%88%90%E4%BD%A0%E7%9A%84%E5%86%99%E4%BD%9C/"/>
      <url>/2019/11/04/%E4%BD%BF%E7%94%A8GitBook%E5%AE%8C%E6%88%90%E4%BD%A0%E7%9A%84%E5%86%99%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是GitBook"><a href="#一、什么是GitBook" class="headerlink" title="一、什么是GitBook"></a>一、什么是GitBook</h2><p><strong>Document everything for you,your users and your team.</strong><br>&#8195;&#8195;GitBook并不是Git的教程，而是以Git作为版本控制系统，结合Github、Markdown用来写书（文档等）的工具。你可以在GitBook的网站、计算机本地上进行你的创作，GitBook帮你制作出精美的电子书籍，同时GitBook的网站对于写作和协同创作都有较好的支持。</p><h2 id="二、GitBook特点"><a href="#二、GitBook特点" class="headerlink" title="二、GitBook特点"></a>二、GitBook特点</h2><ol><li>凭借这个平台可以创建精美的个人笔记、说明文档、甚至是写书等…</li></ol><p><img src="https://img-blog.csdnimg.cn/20200115111556464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><ol><li>Markdown书写，简单方便</li><li><strong>多地同步：</strong> 文档与GitHub仓库绑定，本地创作Push到Github后可自动同步到GitBook并展示，在GitBook上创作后可一键提交到Github仓库。</li><li>可输出各种格式化文档，包括PDF、HTML、eBook等</li><li><strong>缺点：</strong> GitBook网页创作及查看书籍目前需要翻墙才可以使用。<br>……<h2 id="三、开始使用"><a href="#三、开始使用" class="headerlink" title="三、开始使用"></a>三、开始使用</h2><strong>前提：</strong> 默认你是拥有Git和Github的使用经验的</li><li>在Github上创建一个仓库，并克隆到本地</li><li>注册登录GitBook（通过Github账号登录，方便后期绑定仓库），创建一个新的Space</li></ol><p><img src="https://img-blog.csdnimg.cn/20200115114648213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><ol><li>进入到创建好的Book中，在左侧intergrations开启Github并绑定之前创建好的仓库</li></ol><p><img src="https://img-blog.csdnimg.cn/20200115115220228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><ol><li>因为GitBook是基于Node.js的工具，因此需要在计算机本地安装Node.js，可以在<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 下载并傻瓜式安装，安装完成后可以在命令行通过 <code>node -v</code> 和 <code>npm -v</code> 查看版本号</li></ol><p><img src="https://img-blog.csdnimg.cn/20200115114302945.png"width=60% height=60%></p><ol><li>在本地安装GitBook脚手架：<code>npm install gitbook-cli -g</code>  通过 <code>gitbook -V</code> 查看gitbook和CLI的版本。</li><li>在之前拉取的仓库目录下执行 <code>gitbook init</code> 来初始化书籍，这时由于已经有了原有仓库的README.dm  因此GitBook自带的README.md便不会再生成。成功后会包含如下三个文件夹：</li></ol><p><img src="https://img-blog.csdnimg.cn/20200115120133652.png" width=60% height=60%></p><p> 注：_book为自动生成的文件，SUMMARY.md为书籍的目录文件，这个需要按照一定格式来书写，很简单，以下分别表示一级、二级…目录，以此类推。括号内为与之绑定要显示的内容的文件</p><p> <img src="https://img-blog.csdnimg.cn/20200115120716178.png" width=60% height=60%></p><ol><li>运行 <code>gitbook serve</code> 即可在本地运行项目，并可以通过 访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 查看效果。</li><li>最后add commit push 项目到github 仓库，这时由于GitBook已经绑定了该仓库，因此，访问GitBook即可查看到最新的书籍状态。</li></ol>]]></content>
      
      
      <categories>
          
          <category> GitBook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装Docker（官方/阿里源）</title>
      <link href="/2019/10/15/Ubuntu%E5%AE%89%E8%A3%85Docker%EF%BC%88%E5%AE%98%E6%96%B9-%E9%98%BF%E9%87%8C%E6%BA%90%EF%BC%89/"/>
      <url>/2019/10/15/Ubuntu%E5%AE%89%E8%A3%85Docker%EF%BC%88%E5%AE%98%E6%96%B9-%E9%98%BF%E9%87%8C%E6%BA%90%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、为什么使用Docker"><a href="#一、为什么使用Docker" class="headerlink" title="一、为什么使用Docker"></a>一、为什么使用Docker</h2><p>&#8195;&#8195;构建后处处运行：Build Ship and Run Any App Anywhere<br>&#8195;&#8195;Docker解决了因为配置、环境等不同造成的项目部署后无法运行的问题，避免多台机器部署时的反复配置。相对于虚拟机来说，因为Docker使用的是宿主机的内核，具有轻量、占用资源少、启动快等特点，容器间相互隔离，不会相互影响。</p><h2 id="二、Ubuntu安装Docker"><a href="#二、Ubuntu安装Docker" class="headerlink" title="二、Ubuntu安装Docker"></a>二、Ubuntu安装Docker</h2><p>注：root用户下不需要sudo，官方和阿里的源选择其一，建议使用阿里源，速度快。</p><ol><li>安装必要的系统工具 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure></li><li>将Docker存储库添加到APT源：<br> ①. 官方源  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</span><br></pre></td></tr></table></figure> ②. 阿里源 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"</span><br></pre></td></tr></table></figure></li><li>将Docker存储库的GPG密钥添加到系统：<br> ①. 官方的GPG证书 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure> ②. 阿里的GPG证书 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li>确保从Docker repo 安装docker <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache policy docker-ce</span><br></pre></td></tr></table></figure></li><li>安装Docker(社区版) <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y docker-ce</span><br></pre></td></tr></table></figure></li><li>查看docker版本 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker -v</span><br></pre></td></tr></table></figure></li><li>启动Docker <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure><h2 id="三、配置阿里源"><a href="#三、配置阿里源" class="headerlink" title="三、配置阿里源"></a>三、配置阿里源</h2>&#8195;&#8195;由于从国外的网站拉镜像比较慢，因此国内如阿里云提供了容器镜像服务（如果不使用国内的镜像服务也没关系）。注册阿里云账号后，一般进入控制台/产品与服务/容器镜像服务/镜像加速器（第一次进入会让你设置一个Rigistry密码,这个密码当以后想上传镜像到阿里的docker仓库时会用到，类似于github，不过由于DockerHub太慢了）。然后就可以看到你的专属加速器地址和配置使用方法(<strong>根据系统按照操作文档中的命令运行即可（推荐），或者通过修改配置文件内容的方式</strong>)。如下图：<br><img src="https://img-blog.csdnimg.cn/20200105215657348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%><h2 id="四、查看所使用的源"><a href="#四、查看所使用的源" class="headerlink" title="四、查看所使用的源"></a>四、查看所使用的源</h2>注：命令最后是数字1，不是小写的L<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info|grep Mirrors -A 1</span><br></pre></td></tr></table></figure></li></ol><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask发送邮件</title>
      <link href="/2019/10/01/Flask-%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
      <url>/2019/10/01/Flask-%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是POP3、SMTP和IMAP"><a href="#一、什么是POP3、SMTP和IMAP" class="headerlink" title="一、什么是POP3、SMTP和IMAP?"></a>一、什么是POP3、SMTP和IMAP?</h1><p><a href="https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac22dc0e9af8168582a" target="_blank" rel="noopener">POP3、SMTP和IMAP</a></p><h1 id="二、开启邮箱的SMTP服务"><a href="#二、开启邮箱的SMTP服务" class="headerlink" title="二、开启邮箱的SMTP服务"></a>二、开启邮箱的SMTP服务</h1><p>以常用的<strong>网易邮箱</strong>为例(其他同理)：登录后进入常规设置</p><ol><li>选择POP3/SMTP/IMAP：开启如下两条服务,并注意到这里提示<strong>使用的是授权码登录第三方客户端，而非邮箱密码（有些邮箱使用的是密码而非授权码）</strong>。<br><img src="https://img-blog.csdnimg.cn/20200105164619496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></li><li>页面的最下方还有一个提示内容如下，这个也会在后面用到,有两个重要信息：</li></ol><ul><li>SMTP的服务器：smtp.163.com</li><li>安全支持：POP3/SMTP/IMAP服务是全部支持SSL连接的<br><img src="https://img-blog.csdnimg.cn/20200105165609472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></li></ul><ol><li>设置中选择 客户端授权密码 这一栏并选择开启，并记住这个授权码，开启后如下：<br><img src="https://img-blog.csdnimg.cn/20200105170144837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></li><li>网易邮箱的相关服务器信息：<br><img src="https://img-blog.csdnimg.cn/20200105171212581.png" width=80% height=80%><h1 id="三、Python-Flask框架发送邮件"><a href="#三、Python-Flask框架发送邮件" class="headerlink" title="三、Python Flask框架发送邮件"></a>三、Python Flask框架发送邮件</h1></li><li>安装依赖包：flask_mail<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask_mail</span><br></pre></td></tr></table></figure></li><li>这里假设一种情况，比如一般在注册一个网站时，会给用户发送验证邮件，这时我们用浏览器访问这个接口（<a href="http://localhost:5000/register）时就会发送对应的邮件到用户邮箱（当然省略了很多如生成验证码等内容）。" target="_blank" rel="noopener">http://localhost:5000/register）时就会发送对应的邮件到用户邮箱（当然省略了很多如生成验证码等内容）。</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_mail <span class="keyword">import</span> Mail, Message</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span><span class="params">(object)</span>:</span></span><br><span class="line">    DEBUG = <span class="literal">True</span></span><br><span class="line">    MAIL_SERVER = <span class="string">'smtp.163.com'</span> <span class="comment"># 邮件服务器地址</span></span><br><span class="line">    MAIL_PORT = <span class="string">'465'</span> <span class="comment"># SSL协议端口号</span></span><br><span class="line">    MAIL_USE_SSL = <span class="literal">True</span> <span class="comment"># 使用SSL加密</span></span><br><span class="line">    MAIL_USERNAME = <span class="string">'youremail@163.com'</span> <span class="comment"># 邮箱</span></span><br><span class="line">    MAIL_PASSWORD = <span class="string">'xxxxxxxx'</span> <span class="comment"># 授权码（某些邮箱是直接使用密码）</span></span><br><span class="line">app.config.from_object(Config)</span><br><span class="line"></span><br><span class="line">mail = Mail(app)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/register', strict_slashes = False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">()</span>:</span></span><br><span class="line">    msg = Message(<span class="string">'填写邮件标题'</span>, sender=<span class="string">'youremail@163.com'</span>, recipients=[<span class="string">'xxx@gmail.com'</span>, <span class="string">'xxx@qq.com'</span>])</span><br><span class="line">    msg.body = <span class="string">'邮件内容'</span></span><br><span class="line">    mail.send(msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'邮件发送成功！'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host = <span class="string">'0.0.0.0'</span>,port = <span class="number">5000</span>)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> 邮件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础环境搭建</title>
      <link href="/2019/09/16/Python-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/09/16/Python-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Python-IDE"><a href="#一、Python-IDE" class="headerlink" title="一、Python IDE"></a>一、Python IDE</h1><ol><li>常用的很多，可根据自己的习惯去选择，以 Sublime Text3211为例（我安装时的最新版本）。</li><li>下载地址：<a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">http://www.sublimetext.com/3</a> （安装时勾选Add to explorer context menu选项）</li></ol><h1 id="二、Sublime-Text配置"><a href="#二、Sublime-Text配置" class="headerlink" title="二、Sublime Text配置"></a>二、Sublime Text配置</h1><ol><li><strong>安装Package Control 插件：</strong>（通过这个插件可以来管理其他软件） : 快捷键 Ctrl + Shift + P 输入 “install Package Control” 搜索，点击一下后稍等就会提示安装成功，然后重启软件。</li><li><strong>汉化软件：</strong> Preferrence -&gt; Package Control -&gt; 点击Package Control：Install Package -&gt; 在搜索框内输入 chinese -&gt; 点击 Chinese Localizations 即可。稍等片刻，安装成功，所有的界面会变成中文。</li><li><strong>更改Sublime Text字体：</strong> 由于汉化后对于中文的支持并不是很好（部分中文显示错误），需要在计算机内装一个新的字体来使用。字体下载地址：<a href="https://github.com/yakumioto/YaHei-Consolas-Hybrid-1.12" target="_blank" rel="noopener">https://github.com/yakumioto/YaHei-Consolas-Hybrid-1.12</a> 下载后安装即可。安装好后点击Sublime Text中的首选项 -&gt; 设置 -&gt; 填入如下内容：(第二行内容)<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line"> <span class="attr">"color_scheme":</span> <span class="string">"Packages/ayu/ayu-dark.sublime-color-scheme"</span><span class="string">,</span></span><br><span class="line"> <span class="attr">"font_face":</span> <span class="string">"YaHei Consolas Hybrid"</span><span class="string">,</span></span><br><span class="line"> <span class="attr">"font_size":</span> <span class="number">13</span><span class="string">,</span></span><br><span class="line"> <span class="attr">"ignored_packages":</span></span><br><span class="line"> <span class="string">[</span></span><br><span class="line">  <span class="string">"Vintage"</span></span><br><span class="line"> <span class="string">],</span></span><br><span class="line"> <span class="attr">"theme":</span> <span class="string">"ayu-light.sublime-theme"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>主题更改：</strong><br>&#8195;&#8195;①.首选项 -&gt; 主题 选择ayu-light-sublime-theme (这个更改的是软件外部的框，并没有包含编辑部分)<br>&#8195;&#8195;②. 首选项 -&gt; 配色方案 选择Monokai Color Scheme - Default(为了后面更改注释颜色) 效果如下图所示：（也可以根据喜好选择其他的）</li></ol><p><img src="https://img-blog.csdnimg.cn/20191002214101963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><ol><li>注释颜色更改：① Ctrl + Shift +P 搜索 PackageResourceViewer:Open Resource 点击进入 ② 再搜索Color Scheme -Default,点击进入 ③ 搜索Monokai.sublime-color-scheme 进入，在文件的颜色部分添加你想要的颜色，并在Comment 处更改为你想要的颜色。如下<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加颜色</span></span><br><span class="line"><span class="attr">"green":</span> <span class="string">"hsl(144, 100%, 39%)"</span><span class="string">,</span></span><br><span class="line"><span class="comment">#配置颜色</span></span><br><span class="line"><span class="attr">"rules":</span></span><br><span class="line">    <span class="string">[</span></span><br><span class="line">        <span class="string">&#123;</span></span><br><span class="line">            <span class="attr">"name":</span> <span class="string">"Comment"</span><span class="string">,</span></span><br><span class="line">            <span class="attr">"scope":</span> <span class="string">"comment"</span><span class="string">,</span></span><br><span class="line">            <span class="attr">"foreground":</span> <span class="string">"var(green)"</span></span><br><span class="line">        <span class="string">&#125;,</span></span><br><span class="line">    <span class="string">]</span></span><br></pre></td></tr></table></figure>效果如图：<br><img src="https://img-blog.csdnimg.cn/20191003172630999.png"width=60% height=60%></li></ol><h1 id="三、Python-解释器（CPython）安装"><a href="#三、Python-解释器（CPython）安装" class="headerlink" title="三、Python 解释器（CPython）安装"></a>三、Python 解释器（CPython）安装</h1><p>注：Python 各个版本之间不兼容，这里使用3。</p><ol><li>安装包下载地址：<a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a>  （选则最新的稳定发行版本即可）</li><li>安装时选择自定义安装，并勾选Add Python to enviroemnt variables 选项来将Python的安装路径添加到PATH环境变量中。</li><li>更改安装路径，因为Python的默认安装路径太深了。</li><li>在命令行输入python来验证安装情况。</li><li>与此同时也安装了 IDEL （Python 的交互界面，但是并不用它来写代码，可以做测试用）。<h1 id="四、Sublime-整合Python解释器"><a href="#四、Sublime-整合Python解释器" class="headerlink" title="四、Sublime 整合Python解释器"></a>四、Sublime 整合Python解释器</h1><strong>目的：</strong> 为了可以在Sublime中直接执行Python 代码，而不需要切换到 Python 的交互界面中去执行写好的Python 代码。</li><li>可直接在 Sublime 中按 CTRL + B 来执行。</li><li>安装使用SublimeREPL 来执行Python程序。<br>安装方法：首选项 -&gt; Package Control -&gt; 点击Package Control：Install Package -&gt; 在搜索框内输入SublimeREPL 点击安装。安装后即可通过 工具 -&gt; SublimeREPL  -&gt; Python -&gt; Python -RUN current file 来执行代码。但是这样很麻烦，因此可以配置快捷键(F8 可自行选择快捷键，保证与软件已有的快捷键不冲突即可)来执行。在首选项 -&gt; 快捷键设置 中添加如下代码：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[</span></span><br><span class="line"> <span class="string">&#123;</span> <span class="attr">"keys":</span> <span class="string">["f8"],</span> <span class="attr">"caption":</span></span><br><span class="line">  <span class="string">"SublimeREPL:Python"</span><span class="string">,"command":</span> </span><br><span class="line">  <span class="string">"run_existing_window_command"</span><span class="string">,</span> <span class="attr">"args":</span></span><br><span class="line">  <span class="string">&#123;"id":</span> <span class="string">"repl_python_run"</span><span class="string">,"file":"config/Python/Main.sublime-menu"&#125;&#125;,</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><h1 id="五、配置sublime的终端"><a href="#五、配置sublime的终端" class="headerlink" title="五、配置sublime的终端"></a>五、配置sublime的终端</h1></li><li>Ctrl + Shift +P 搜索 package install</li><li>搜索Terminal 并点击安装（等待安装好后会在首选项（）下找到Package setting-&gt;Terminal-&gt;Setting -&gt;User 并进入）</li><li>配置文件中填写如下内容并保存退出：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">路径</span></span><br><span class="line"><span class="attr">"terminal":</span> <span class="string">"C:\\MyAPP\\cmder\\Cmder.exe"</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span> <span class="string">参数</span></span><br><span class="line"><span class="attr">"parameters":</span> <span class="string">["/START",</span> <span class="string">"%CWD%"</span><span class="string">]</span></span><br></pre></td></tr></table></figure></li><li>这样就可以通过快捷键 ctrl+shift+T 直接打开终端，并处于当前文件所在的路径。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git提交代码书写多行日志</title>
      <link href="/2019/08/12/Git-%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E6%97%B6%E4%B9%A6%E5%86%99%E5%A4%9A%E8%A1%8C%E6%97%A5%E5%BF%97%EF%BC%88%E9%85%8D%E7%BD%AEGit-commit-template/"/>
      <url>/2019/08/12/Git-%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E6%97%B6%E4%B9%A6%E5%86%99%E5%A4%9A%E8%A1%8C%E6%97%A5%E5%BF%97%EF%BC%88%E9%85%8D%E7%BD%AEGit-commit-template/</url>
      
        <content type="html"><![CDATA[<h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><p>&#8195;&#8195;通常我们会采用git commit -m “提交日志” 的方式去提交代码，但是如果我们程序更改的地方很多，那就需要写更多的日志来记录，当我们查看log以后是下面这个样子：（当然也可以在github上去点击查看效果）<br><img src="https://img-blog.csdnimg.cn/20190719104541808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%><br>这样的提交日志就相对来说很清除，下面就来记录一下实现提交多行日志的方式。</p><h2 id="二、配置-Git-提交模板"><a href="#二、配置-Git-提交模板" class="headerlink" title="二、配置 Git 提交模板"></a>二、配置 Git 提交模板</h2><ol><li>在仓库的根目录下新建一个模板文件：如：git_commit_template.txt</li><li>git config commit.template git_commit_template.txt     &#8195;&#8195; <strong>#注意这里文件要加后缀名，该方式设置的是当前分支的提交模板</strong><br>git config —global commit.template git_commit_template.txt  &#8195;&#8195;  <strong>#设置的是全局的提交模板。</strong></li><li>git config —global core.editor vim  &#8195;&#8195; #设置模板的文本编辑器为vim,当然就需要我们在编写日志时会用简单的vim命令。</li><li>git commit  &#8195;&#8195; #当我们再次提交时直接执行git commit 命令时会进入下图所示的模板界面，我们就可以“任意”书写多行的提交日志了。<br>&#8195;&#8195;日志模板中会提示当前所处的分支和修改过的文件可以很方便我们去写提交日志。<strong>强烈建议使用Git Bash   因为windows的命令行下不支持中文的输入，同时命令行对于高亮的支持也不好。</strong><br><img src="https://img-blog.csdnimg.cn/20190719111809358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%><h2 id="三、日志模板书写格式"><a href="#三、日志模板书写格式" class="headerlink" title="三、日志模板书写格式"></a>三、日志模板书写格式</h2>&#8195;&#8195;当然我们可以写多行提交日志也不是随便的写，是有一些通用的格式的，下面部分从网上复制过来的常用的格式可以参考。<br>&#8195;&#8195;1. 常用格式：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;type&gt;(&lt;scope&gt;):</span> <span class="string">&lt;subject&gt;</span></span><br><span class="line"><span class="string">//</span> <span class="string">空一行</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">//</span> <span class="string">空一行</span></span><br><span class="line"><span class="string">&lt;footer&gt;</span></span><br></pre></td></tr></table></figure>&#8195;&#8195;2. 参数要求<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span></span><br><span class="line">feat：新功能（feature）</span><br><span class="line">fix：修补bug</span><br><span class="line">docs：文档（documentation）</span><br><span class="line">style： 格式（不影响代码运行的变动）</span><br><span class="line">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span><br><span class="line">test：增加测试</span><br><span class="line">chore：构建过程或辅助工具的变动</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Body 部分是对本次 commit 的详细描述，可以分成多行</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">可以根据自己的需要书写。如影响范围等。</span><br></pre></td></tr></table></figure><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2>&#8195;&#8195;1. 书写完以后保存退出即可，直接git push 即可。<br>&#8195;&#8195;2. 提交后可以通过git log  或直接去github 上点击查看效果。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过GPRS上传GPS数据到服务器</title>
      <link href="/2019/07/10/%E9%80%9A%E8%BF%87GPRS%E5%B0%86GPS%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/07/10/%E9%80%9A%E8%BF%87GPRS%E5%B0%86GPS%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h2><p>&#8195;&#8195;将GPS获取到的位置信息，通过GPRS将数据上传到服务器，当然也可以传输其他的信息，这样就可以实现对某些东西的时时定位，比如共享单车、汽车的定位等等。</p><h2 id="二、使用的器件"><a href="#二、使用的器件" class="headerlink" title="二、使用的器件"></a>二、使用的器件</h2><h3 id="1-GPRS模块和物联网卡"><a href="#1-GPRS模块和物联网卡" class="headerlink" title="1. GPRS模块和物联网卡"></a>1. GPRS模块和物联网卡</h3><p>&#8195;&#8195;①. GPRS模块使用的是有方的N10标准版，如下图：<br><img src="https://img-blog.csdnimg.cn/20190704091553351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%><br>&#8195;&#8195;②. 腾讯云上购买的移动卡，比自己买方便许多，腾讯还会提供后台管理和其他接口服务，续费什么的也很方便。如下图：<br><img src="https://img-blog.csdnimg.cn/20190704092310820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><h3 id="2-GPS模块"><a href="#2-GPS模块" class="headerlink" title="2. GPS模块"></a>2. GPS模块</h3><p>&#8195;&#8195;使用的是中科微电子的ATGM332D 5N-31,如下图：<br><img src="https://img-blog.csdnimg.cn/20190704093646522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><h3 id="3-MCU"><a href="#3-MCU" class="headerlink" title="3. MCU"></a>3. MCU</h3><p>&#8195;&#8195;我使用的是TI的TM4C123G，不同MCU基本没有区别，使用这个的原因就是比赛TI送了好多块，总得找个地方用吧，哈哈。</p><h2 id="三、电路连接"><a href="#三、电路连接" class="headerlink" title="三、电路连接"></a>三、电路连接</h2><p>&#8195;&#8195;因为要GPS和GPRS通信，所以需要两个UART，一个用来解析GPS返回的数据和打印数据到控制台调试，另一个则与GPRS通信，向GPRS发送数据和接收GPRS返回的数据。<br>&#8195;&#8195;GPS的TX &lt;————————————-&gt; UART0的RX<br>&#8195;&#8195;UART0的TX &lt;——————————-&gt; 串口模块的RX<br>&#8195;&#8195;GPRS的TX &lt;———————————-&gt; UART1的RX<br>&#8195;&#8195;GPRS的RX &lt;———————————-&gt; UART1的TX</p><h2 id="四、程序设计"><a href="#四、程序设计" class="headerlink" title="四、程序设计"></a>四、程序设计</h2><p>&#8195;&#8195;①. <strong>GPS数据解析：</strong> 根据返回的数据是否有效，有效的话则将数据更新存放GPS数据的结构体，卖家也有相应的例程作为参考，移植过来用就可以了。<br>&#8195;&#8195;②. <strong>GPS数据转化：</strong> 因为要将数据通过GPRS上传到服务器，通信协议采用HTTP，这就需要将有用的GPS数据转成Json格式，当然要使用cJson了，<strong>但是这里有个坑，创建cJson对象时涉及内存申请，需要去startup_TM4C123.s 文件中将堆改到合适的大小，但堆栈加起来不要超过RAM的大小。</strong> 如下图所示（这是我修改后的，不然每次创建对象时程序会直接卡死）：<br><img src="https://img-blog.csdnimg.cn/2019070410333030.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%><br>&#8195;&#8195;③. <strong>解析GPRS返回的数据：</strong> 因为每发一条命令后，要等待GPRS会返回不同的数据并进行判断，然后根据实际情况去进行相应的处理，对于返回结果包含特殊字串的可以直接通过strstr()来判断，如“OK”、“ERROR”、“&gt;”等。但实际测试中还是发现，连接几百上千次之后还是会掉入循环卡死，为了保持稳定性，索性直接写个看门狗，卡死强行复位程序。<br>&#8195;&#8195;④. <strong>看门狗部分：</strong> 因为程序执行周期(每完成一次连接，发送数据)，大概需要三秒多一点，看门狗的触发时间我设置的7秒，如果超过此时间没有喂狗，直接复位。（注：TM4C123G的WDT有二次触发特性）。最后实际测试了四个半小时，建立连接4000次左右，程序没有出现卡死现象。<br><img src="https://img-blog.csdnimg.cn/20190704110839589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%><br>&#8195;&#8195;⑤. 后台的程序就简单用SpringBoot写一下，用来测试。</p><h2 id="五、程序代码"><a href="#五、程序代码" class="headerlink" title="五、程序代码"></a>五、程序代码</h2><ol><li>获取方式：<br>①. github下载：<a href="https://github.com/Beyonderwei/GPS-positioning-system" target="_blank" rel="noopener">https://github.com/Beyonderwei/GPS-positioning-system</a><br>②. CSDN下载：<a href="https://download.csdn.net/download/csdn_x_w/11274960" target="_blank" rel="noopener">https://download.csdn.net/download/csdn_x_w/11274960</a></li><li>IDE：keil5  下载后直接全编译即可使用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPRS </tag>
            
            <tag> GPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——交换排序（冒泡、快排）</title>
      <link href="/2019/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%89/"/>
      <url>/2019/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><h3 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h3><p>&ensp;&ensp;&ensp;&ensp;从头到尾，两两比较相邻的两个元素，如果顺序不对，则交换顺序，这样每一次即可将参与比较中最小的找出来。</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>&ensp;&ensp;&ensp;&ensp;从下向上，如果array[i] &lt; array[i-1]则进行交换，如最左侧的一列，35交换-37交换-32不换-21不换-14交换-16交换。这样就得到了第二列，循环执行。<br><img src="https://img-blog.csdnimg.cn/20200301175854542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% heiht=80%></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param array[] 要排序的数组</span></span><br><span class="line"><span class="comment">  *        length 数组长度</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span> [],<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> change = TURE; <span class="comment">// 用来标识之前比较过的是否已经有序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;length<span class="number">-1</span> &amp;&amp; change ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        change = FALSE;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;length-(i+<span class="number">1</span>); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[j]&gt;<span class="built_in">array</span>[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=<span class="built_in">array</span>[j+<span class="number">1</span>];</span><br><span class="line">                <span class="built_in">array</span>[j+<span class="number">1</span>]=<span class="built_in">array</span>[j];</span><br><span class="line">                <span class="built_in">array</span>[j]=temp;</span><br><span class="line">                change=TURE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span> a /<span class="keyword">sizeof</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[i], i == length <span class="number">-1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    bubbleSort(a, length);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[i], i == length <span class="number">-1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、快速排序"><a href="#二、快速排序" class="headerlink" title="二、快速排序"></a>二、快速排序</h2><h3 id="排序思想-1"><a href="#排序思想-1" class="headerlink" title="排序思想"></a>排序思想</h3><p>&ensp;&ensp;&ensp;&ensp;选取一个元素值，通过比较（从数组两侧向中间比较），比该值小得交换到其左边，大的被交换到右边，这样将待排序的数组分成两部分，左侧都比该元素值小，右侧都比该元素值大，针对每一个部分再执行以上的过程，直到不能再分为止。</p><h3 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>元素选取：</strong> 每一次以该组数组的第一个值作为被选取得元素值。一次排序后分成两部分，左侧比4小，右侧比4大。不断执行该过程<br><img src="https://img-blog.csdnimg.cn/20200301183814422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% heigt=80%></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>&ensp;&ensp;&ensp;&ensp;递归方式实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( length &lt;= <span class="number">1</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=length<span class="number">-1</span>, temp = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>( i&lt;j ) &#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">array</span>[j]&gt;temp &amp;&amp; j&gt;i ) j--; <span class="built_in">array</span>[i] = <span class="built_in">array</span>[j];</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">array</span>[i]&lt;=temp &amp;&amp; i&lt;j ) i++; <span class="built_in">array</span>[j] = <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[i] = temp;</span><br><span class="line">    sort(<span class="built_in">array</span>, i);</span><br><span class="line">    sort(<span class="built_in">array</span>+i+<span class="number">1</span>, length-i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——插入排序</title>
      <link href="/2019/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、排序思想"><a href="#一、排序思想" class="headerlink" title="一、排序思想"></a>一、排序思想</h2><p>将数据元素，一个一个的插入到当前已经排序好的表中。</p><h2 id="二、图解"><a href="#二、图解" class="headerlink" title="二、图解"></a>二、图解</h2><p><img src="https://img-blog.csdnimg.cn/2020030120233792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, tmp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; <span class="built_in">array</span>[j] &gt; tmp; j--)</span><br><span class="line">                <span class="built_in">array</span>[j+<span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">            <span class="built_in">array</span>[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">-100</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">-10</span>, <span class="number">9</span>, <span class="number">46</span>, <span class="number">-4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">44</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span> a /<span class="keyword">sizeof</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[i], i == n <span class="number">-1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    insertSort(a, n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[i], i == n <span class="number">-1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——选择排序</title>
      <link href="/2019/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、排序思想"><a href="#一、排序思想" class="headerlink" title="一、排序思想"></a>一、排序思想</h2><p>每一次取出没有被排序的元素中最小的元素。</p><h2 id="二、图解"><a href="#二、图解" class="headerlink" title="二、图解"></a>二、图解</h2><ol><li>先从已有的七个中找到最小的（下标为2），记住下标，与下标为0的交换。</li><li>从剩下的六个中再找到这六个中最小的（下标为3），记住下标，与下标为1的交换。</li><li>直到循环六次（N-1次），全部排好。<br><img src="https://img-blog.csdnimg.cn/20200301160349301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param array[] 要排序的数组</span></span><br><span class="line"><span class="comment">  *        length 数组长度</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i, j, <span class="built_in">min</span>, temp;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">min</span> = i;</span><br><span class="line">         <span class="keyword">for</span>(j=i+<span class="number">1</span>; j&lt;length; j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(<span class="built_in">array</span>[<span class="built_in">min</span>] &gt; <span class="built_in">array</span>[j])</span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(i != <span class="built_in">min</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             temp = <span class="built_in">array</span>[<span class="built_in">min</span>];</span><br><span class="line">             <span class="built_in">array</span>[<span class="built_in">min</span>] = <span class="built_in">array</span>[i];</span><br><span class="line">             <span class="built_in">array</span>[i] = temp;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span> a /<span class="keyword">sizeof</span> a[<span class="number">0</span>]; <span class="comment">// 得到数组长度</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) <span class="comment">//打印原有数组</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[i], i == length <span class="number">-1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    selectSort(a, length);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) <span class="comment">// 打印</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, a[i], i == length <span class="number">-1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——查找（平衡二叉树、分块索引、哈希表）</title>
      <link href="/2019/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE%EF%BC%88%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%88%86%E5%9D%97%E7%B4%A2%E5%BC%95%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AF%B9%E6%AF%94%EF%BC%89/"/>
      <url>/2019/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE%EF%BC%88%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%88%86%E5%9D%97%E7%B4%A2%E5%BC%95%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AF%B9%E6%AF%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、平衡二叉树"><a href="#一、平衡二叉树" class="headerlink" title="一、平衡二叉树"></a>一、平衡二叉树</h2><h4 id="1-解决的问题"><a href="#1-解决的问题" class="headerlink" title="1. 解决的问题"></a>1. 解决的问题</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;对于<strong>顺序存储</strong>的有序表在查找时可以采用二分法、插值法等查找方式，使查找的时间复杂度由 $O[n]$ 提高到了$O[log_n]$ ,但是面临的问题是，<strong>顺序存储</strong>的有序表在插入和删除元素时的效率很低，为 $O[n]$，因此如何使查找、插入和删除的的效率都很高呢？</p><h4 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;<strong>平衡二叉树：</strong> 每个结点左右子树的深度差不大于1的有序二叉树。</p><h4 id="3-分析"><a href="#3-分析" class="headerlink" title="3. 分析"></a>3. 分析</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;因为有序的完全二叉树在查找时的时间复杂度为$O[log_n]$，而平衡二叉树和有序的完全二叉树在查找时时间复杂度相同，在插入或删除元素时只需要维护该树仍然为平衡二叉树即可，因此时间复杂度依然为$O[log_n]$，即查找时所花费的时间。</p><h2 id="二、分块索引"><a href="#二、分块索引" class="headerlink" title="二、分块索引"></a>二、分块索引</h2><h4 id="1-解决的问题-1"><a href="#1-解决的问题-1" class="headerlink" title="1. 解决的问题"></a>1. 解决的问题</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;当某个数据表中的内容过多时，即使有序，也使得查询的速度不尽人意。</p><h4 id="2-概念-1"><a href="#2-概念-1" class="headerlink" title="2. 概念"></a>2. 概念</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;<strong>分块索引：</strong> 将数据集按照关键字范围或者某个特定的关键字进行分块，各个块之间有序，块内无序或者有序均可。</p><h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h4><p>①. 按范围分块：将用户按照索引大小，每5000个分到一个块中。查找时先查找所属块，再到块内查找。<br>②. 电话的区号：先锁定区，再到该取的数据中去查找，从而缩小被查找的数据量。</p><h2 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h2><h4 id="1-解决的问题-2"><a href="#1-解决的问题-2" class="headerlink" title="1. 解决的问题"></a>1. 解决的问题</h4><p>&ensp;&ensp;&ensp;&ensp;&ensp;在之前的基础上，进一步提高插入、删除、查找的效率，将时间复杂度提高到 $O[1]$ ，但是<strong>缺点</strong>在于：要查找在一定范围内的数据时时间复杂度较低。</p><h4 id="2-概念-2"><a href="#2-概念-2" class="headerlink" title="2. 概念"></a>2. 概念</h4><p><strong>哈希表：</strong> 通过Hash函数，实现关键字与存储地址之间确定一种对应关系，在增删改查的过程中，直接通过函数关系找到存储地址。但也要解决因为散列不均匀而引发的冲突问题。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>①. 对于查询效率要求比较高，但很少或者几乎不涉及到范围查找的情况。<br>②. 如Redis等常见key-value数据库的实现。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——最小生成树</title>
      <link href="/2019/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2019/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><ol><li>连通图：图中的任意两个节点之间都是联通的，即：总能从A节点按照一定路径走到B节点。</li><li>生成树：为联通图的一个联通子图，包含N个结点和N-1条边。</li><li>最小生成树：当联通图中的每条边带有权值时，所有边权值和最小的生成树。<h2 id="二、问题导向"><a href="#二、问题导向" class="headerlink" title="二、问题导向"></a>二、问题导向</h2>&ensp;&ensp;&ensp;&ensp;各个城市之间修建铁路，城市之间铺设电缆、水管等，不考虑环境等复杂因素，肯定最小生成树对应的权值（对应管线、铁路等长度）和最小怎样才能成本最低。因此如何铺设的问题转化成了找到这个最小生成树的问题。如下图(A~F表示城市，线上的数字表示距离)：<br><img src="https://img-blog.csdnimg.cn/20200228215520217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width = 60% height = 60%><h2 id="三、相关算法"><a href="#三、相关算法" class="headerlink" title="三、相关算法"></a>三、相关算法</h2>注：正常情况下没有办法一眼看出来该如何选择的，如果更复杂一点的话就更难用眼睛看出来的了，因此面对该问题需要有响应的算法来解决。<strong>听着很高端、实际实现的代码逻辑很复杂，但是懂了思想理解起来很容易。</strong><br><strong>最终目的：</strong> 找到我们想要的N-1条线。<h4 id="Prim算法："><a href="#Prim算法：" class="headerlink" title="Prim算法："></a>Prim算法：</h4><strong>通俗理解：</strong> </li><li>任意选择一个结点开始（从此已有结点多了一个0到1）</li><li>从已有的结点中，找与已有结点和剩下的结点连线权限最小的那个</li><li>迭代重复第二步，直到所有结点都被连接。此时刚哈N-1条边。</li></ol><p><strong>举例：</strong> 假设以A为第一个点，我们依次被连接的顶点顺序为：A-&gt;F-&gt;E-&gt;D-&gt;C-&gt;B，边被选择的顺序为：4、2、3、4、3。步骤为红色12345的顺序。<br><img src="https://img-blog.csdnimg.cn/20200228215957777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width = 60% height = 60%></p><h4 id="Kruskal算法："><a href="#Kruskal算法：" class="headerlink" title="Kruskal算法："></a>Kruskal算法：</h4><p><strong>通俗理解：</strong></p><ol><li>从所有的边中找最短的边</li><li>保证，所有的边连起来不能构成环路，如果构成环路则选择次小的边、或者次次小的边，</li><li>按照第二部的要求，重复第一步的过程，直到所有的结点被连接。</li></ol><p><strong>举例：</strong> 依次被选择的边：2(EF)-&gt;3(D)-&gt;3(BC)-&gt;4(A)-&gt;4。步骤为红色12345的顺序。<br><img src="https://img-blog.csdnimg.cn/20200228220137507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width = 60% height = 60%></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
            <tag> Prim </tag>
            
            <tag> Kruskal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——赫夫曼树</title>
      <link href="/2019/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2019/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="一、实际问题场景"><a href="#一、实际问题场景" class="headerlink" title="一、实际问题场景"></a>一、实际问题场景</h2><p>&#8195;&#8195;比如要为学生的成绩按照分数线分为优、良、中、及格、和不及格，对应的分数线如下：</p><div class="table-container"><table><thead><tr><th>等级</th><th>优</th><th>良</th><th>中</th><th>及格</th><th>不及格</th></tr></thead><tbody><tr><td>分数区间</td><td>90-100</td><td>80-89</td><td>70-79</td><td>60-69</td><td>0-59</td></tr><tr><td>分数在该区间的概率</td><td>10%</td><td>30%</td><td>40%</td><td>10%</td><td>10%</td></tr></tbody></table></div><p>&#8195;&#8195;现在有大量的学生的成绩需要对比，如果按照下面两种顺序进行比较：由于不同分数段的概率不一样，因此不同的比较顺序需要比较的次数不一样，所需时间也就不一样了：(如对于大概率的分数75，图一比较了3次。而图二比较2<br>次)</p><p><img src="https://img-blog.csdnimg.cn/20200217083711945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=60% height=60%><br><img src="https://img-blog.csdnimg.cn/20200217083945912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%><br>&#8195;&#8195;因此为了得到最少的比较次数，就需要一种方法得到最优的比较顺序，即赫夫曼树。</p><h2 id="二、赫夫曼树"><a href="#二、赫夫曼树" class="headerlink" title="二、赫夫曼树"></a>二、赫夫曼树</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>路径长度：节点到节点之间的路径数<br>带权路径长度：节点上的权数与路径长度的乘机。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>&#8195;&#8195;下图的带权路径长度=10+2x10+3x40+4x30+4x10=310,显然按照这个概率和这种比较方式，100个成绩需要比较310次。因此问题就在于获得最小的带权路径长度。<br><img src="https://img-blog.csdnimg.cn/20200217090623227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=60% height=60%></p><h3 id="构造赫夫曼树："><a href="#构造赫夫曼树：" class="headerlink" title="构造赫夫曼树："></a>构造赫夫曼树：</h3><p>&#8195;&#8195;注：为方便表示，将优、良、中、及格、和不及格命名为A、B、C、D、E。</p><ol><li>将有权值的节点排序：A-10，B-30，C-40，D-10，E-10；</li><li>将最小权值的两个节点A-10、D-10作为新节点AD-20的左右孩子，权值小的作为左孩子，大的作为右孩子。并将新的节点AD与剩下的比较，并重复上述过程，直到只剩两个节点为止。</li><li>过程如下:</li></ol><ul><li>A-10，B-30，C-40，D-10，E-10；</li><li>E-10，AD-20，B-30，C-40；</li><li>EAD-30，B-30，C-40；</li><li>C-40，BEAD-60；</li></ul><ol><li>逆向上述过程，得到赫夫曼树(注意左子树或左孩子为权值小的)：<br><img src="https://img-blog.csdnimg.cn/20200217094215741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=60% height=60%></li><li>计算：带权路径长度=40+30x2+10x2+10x3+10x3=130,这时如果有100个数据，仅需要比较130次即可。</li><li>代码转换： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getGread</span><span class="params">(<span class="keyword">int</span> score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(score &gt;=<span class="number">70</span> &amp;&amp; score &lt;= <span class="number">79</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'C'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &gt;=<span class="number">80</span> &amp;&amp; score &lt;= <span class="number">89</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'B'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &gt;=<span class="number">0</span> &amp;&amp; score &lt;= <span class="number">59</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'E'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &gt;=<span class="number">90</span> &amp;&amp; score &lt;= <span class="number">100</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'D'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 赫夫曼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——KMP模式匹配算法</title>
      <link href="/2019/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
      <url>/2019/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="代码内容简介："><a href="#代码内容简介：" class="headerlink" title="代码内容简介："></a>代码内容简介：</h3><ol><li>常规的匹配方式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 常规匹配查找子串</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    str_o: 原始串  original string</span></span><br><span class="line"><span class="comment"> *    str_t: 要查找的目标字符串  target string</span></span><br><span class="line"><span class="comment"> * @return 成功：指向目标字符串所在原始串中的位置  失败：NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strStr</span><span class="params">(<span class="keyword">char</span> *str_o, <span class="keyword">char</span> *<span class="keyword">str_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len_str_o = <span class="built_in">strlen</span>(str_o);</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">len_str_t</span> = <span class="built_in">strlen</span>(<span class="keyword">str_t</span>);</span><br><span class="line"><span class="keyword">int</span> cnt_str_o = <span class="number">0</span>, <span class="keyword">cnt_str_t</span> = <span class="number">0</span>; <span class="comment">// 记录原始串与目标串 进行对比的下标</span></span><br><span class="line"><span class="keyword">while</span> (cnt_str_o &lt; len_str_o &amp;&amp; <span class="keyword">cnt_str_t</span> &lt; <span class="keyword">len_str_t</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str_o[cnt_str_o] == <span class="keyword">str_t</span>[<span class="keyword">cnt_str_t</span>])</span><br><span class="line">&#123;</span><br><span class="line">cnt_str_o++;</span><br><span class="line"><span class="keyword">cnt_str_t</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cnt_str_o = cnt_str_o - <span class="keyword">cnt_str_t</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">cnt_str_t</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">cnt_str_t</span> == <span class="keyword">len_str_t</span>)</span><br><span class="line">    <span class="comment">//返回目标字符串在原字符串中的位置指针</span></span><br><span class="line"><span class="keyword">return</span> str_o + (cnt_str_o - <span class="keyword">cnt_str_t</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li>KMP算法匹配字符串的方式，实现快速查找子串。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------KMP匹配-----------------*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 获取要查找的目标字符串的next数组</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    str: 指向目标字符串的指针</span></span><br><span class="line"><span class="comment"> *    next: 指向next数组的指针</span></span><br><span class="line"><span class="comment"> * @return 指向next数组的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; (len<span class="number">-1</span>) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">-1</span> || str[i] == str[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">            <span class="keyword">if</span>(str[i] != str[j])</span><br><span class="line">    next[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[i] = next[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function KMP算法匹配查找子串</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    str_o: 原始串  original string</span></span><br><span class="line"><span class="comment"> *    str_t: 要查找的目标字符串  target string</span></span><br><span class="line"><span class="comment"> *    next: </span></span><br><span class="line"><span class="comment"> * @return 指向next数组的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">kmp</span><span class="params">(<span class="keyword">char</span> *str_o, <span class="keyword">char</span> *<span class="keyword">str_t</span>, <span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt_str_o = <span class="number">0</span>, <span class="keyword">cnt_str_t</span> = <span class="number">0</span>; <span class="comment">// 记录原始串与目标串 进行对比的下标</span></span><br><span class="line"><span class="keyword">int</span> len_str_o = <span class="built_in">strlen</span>(str_o);</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">len_str_t</span> = <span class="built_in">strlen</span>(<span class="keyword">str_t</span>);</span><br><span class="line"><span class="keyword">while</span>(cnt_str_o &lt; len_str_o &amp;&amp; <span class="keyword">cnt_str_t</span> &lt; <span class="keyword">len_str_t</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">cnt_str_t</span> == <span class="number">-1</span> || str_o[cnt_str_o] == <span class="keyword">str_t</span>[<span class="keyword">cnt_str_t</span>])</span><br><span class="line">&#123;</span><br><span class="line">cnt_str_o++;</span><br><span class="line"><span class="keyword">cnt_str_t</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">cnt_str_t</span> = next[<span class="keyword">cnt_str_t</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">cnt_str_t</span> &gt;= <span class="keyword">len_str_t</span>)</span><br><span class="line"><span class="keyword">return</span> str_o + (cnt_str_o - <span class="keyword">cnt_str_t</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在最后对上述两种方式的测试</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmp.c</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created on: 2020年1月31日</span></span><br><span class="line"><span class="comment"> *     Author: Beyonderwei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试部分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">"123456789 abab 123456789"</span>; <span class="comment">// 注意空格也算一个字符</span></span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">"abab"</span>;</span><br><span class="line">    <span class="keyword">char</span> *status = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="built_in">strlen</span>(str2)];</span><br><span class="line">    getNext(str2, next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试普通查找方法</span></span><br><span class="line">    status = strStr(str1, str2);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"在原始字符串中子串位置第一个字符:%c\n"</span>, *status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子串在原始字符串中的位置：%d\n"</span>, (status-str1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试kmp算法查找</span></span><br><span class="line">    status = kmp(str1, str2, next);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"在原始字符串中子串位置第一个字符:%c\n"</span>, *status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子串位置：%d\n"</span>, (status-str1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——栈、队列</title>
      <link href="/2019/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/"/>
      <url>/2019/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>概念：一种特殊的线性表——先进后出（Last In First Out ）的线性表。</li><li>特点：先进后出，只能从栈顶弹出(pop)或压入(push)数据。</li><li>存储结构：顺序存储和链式存储（常用）。<h3 id="结构代码"><a href="#结构代码" class="headerlink" title="结构代码"></a>结构代码</h3>注：链式存储<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表元素所存储的数据类型（以int为例）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="comment">// 定义栈的结点结构及结点指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>;</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType data；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *StackNodePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义指向栈的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">StackNodePtr top; <span class="comment">// 指向栈顶结点的指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cnt; <span class="comment">// 栈内元素的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3>&ensp;&ensp;&ensp;&ensp;计算器（利用后缀表达书）、页面的跳转回退等。<h2 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3></li><li>概念：一种特殊的线性表——先进先出（First In First Out）.的线性表</li><li>特点：先进先出，队尾插入、对头删除。</li><li>存储结构：顺序存储（循环队列）和链式存储（常用）。<h3 id="结构代码-1"><a href="#结构代码-1" class="headerlink" title="结构代码"></a>结构代码</h3>注：链式存储<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表元素所存储的数据类型（以int为例）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列的结点结构及结点指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QueueNOde, *QueueNodePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列的链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueueNodePtr head, tail; <span class="comment">// 指向队列头部和尾部的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3>&ensp;&ensp;&ensp;&ensp;排队买票、抢购等先到先得的场景。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——链表</title>
      <link href="/2019/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><ul><li>线性表：多个数据元素组成的有限序列。</li><li>链表：线性表的链式存储结构<h2 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h2><h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1.单链表"></a>1.单链表</h3></li><li>概念： 链表的结点包含数据域和指针域，指针域只有一个，并指向下一个结点。</li><li>特点：插入删除数据的时间复杂度仅为O(1)，不需要预分配存储空间。<h3 id="2-循环链表"><a href="#2-循环链表" class="headerlink" title="2. 循环链表"></a>2. 循环链表</h3></li><li>概念：单链表中，终端结点的指针由空指针改为指向头结点的指针，形成一个环。</li><li>特点：相对于单链表，循环链表可以在任意位置开始访问到整个链表，尾指针的存在方便了链表的合并。<h3 id="3-双向链表"><a href="#3-双向链表" class="headerlink" title="3. 双向链表"></a>3. 双向链表</h3></li><li>概念：结点中除数据域以外包含两个指针域，一个指向前驱结点，一个指向后继结点。</li><li>特点：相对于单项链表可以实现双向的查找。<h2 id="三、单链表"><a href="#三、单链表" class="headerlink" title="三、单链表"></a>三、单链表</h2>&ensp;&ensp;&ensp;&ensp;注：C语言实现，包括单链表的创建、增加数据、查询某一个数据、删除某个结点、获取链表长度等。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * singly_linked_list.c</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created on: 2020年1月27日</span></span><br><span class="line"><span class="comment"> *     Author: Beyonderwei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------单链表----------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表元素所存储的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="comment">// 定义节点的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">// 定义链表指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 创建带有头节点的单链表，即创建一个头节点</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    list: 链表</span></span><br><span class="line"><span class="comment"> * @return 指向链表的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LinkList <span class="title">createList</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LinkList <span class="built_in">list</span>;</span><br><span class="line">  <span class="built_in">list</span> = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">  <span class="built_in">list</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 向链表追加数据</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    list: 链表</span></span><br><span class="line"><span class="comment"> *    elem: 要追加的数据</span></span><br><span class="line"><span class="comment"> * @return 指向链表的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LinkList <span class="title">listAppend</span><span class="params">(LinkList <span class="built_in">list</span>, ElemType elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LinkList tmp, node;</span><br><span class="line">  tmp = <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">while</span>(tmp-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  node = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//生成一个新的节点，来存储数据</span></span><br><span class="line">  node-&gt;data = elem;</span><br><span class="line">  node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  tmp-&gt;next = node;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 按照条件查找链表中的某个元素</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    list: 链表</span></span><br><span class="line"><span class="comment"> *    elem: 要查找的数据</span></span><br><span class="line"><span class="comment"> * @return 指向该结点的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LinkList <span class="title">getElem</span><span class="params">(LinkList <span class="built_in">list</span>, ElemType elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LinkList tmp = <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">while</span>(tmp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp-&gt;data == elem) <span class="comment">// 可以改为按照data中的某个条件来查找</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 获取链表的长度</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    list: 链表</span></span><br><span class="line"><span class="comment"> * @return 链表的长度（不包括头节点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(LinkList <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">  LinkList tmp;</span><br><span class="line">  tmp = <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">while</span>(tmp-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    length++;</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 按照条件删除链表的某一个结点</span></span><br><span class="line"><span class="comment"> * @param:</span></span><br><span class="line"><span class="comment"> *    list: 链表</span></span><br><span class="line"><span class="comment"> *    elem: 要删除的元素</span></span><br><span class="line"><span class="comment"> * @return list: 删除成功</span></span><br><span class="line"><span class="comment"> *         NULL: 删除失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LinkList <span class="title">deleteElem</span><span class="params">(LinkList <span class="built_in">list</span>, ElemType elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LinkList last_node;</span><br><span class="line">  LinkList tmp = <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">while</span>(tmp-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    last_node = tmp;</span><br><span class="line">    tmp = tmp-&gt;next; <span class="comment">//因为头结点没有存储数据，直接略过</span></span><br><span class="line">    <span class="keyword">if</span>(tmp-&gt;data == elem)</span><br><span class="line">    &#123;</span><br><span class="line">      last_node-&gt;next = tmp-&gt;next;</span><br><span class="line">      <span class="built_in">free</span>(tmp);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------测试代码----------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LinkList <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> length;</span><br><span class="line">  <span class="built_in">list</span> = createList();</span><br><span class="line">  LinkList e;</span><br><span class="line">  listAppend(<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">  listAppend(<span class="built_in">list</span>, <span class="number">2</span>);</span><br><span class="line">  listAppend(<span class="built_in">list</span>, <span class="number">3</span>);</span><br><span class="line">  listAppend(<span class="built_in">list</span>, <span class="number">4</span>);</span><br><span class="line">  listAppend(<span class="built_in">list</span>, <span class="number">5</span>);</span><br><span class="line">  listAppend(<span class="built_in">list</span>, <span class="number">6</span>);</span><br><span class="line">  </span><br><span class="line">  deleteElem(<span class="built_in">list</span>, <span class="number">7</span>);</span><br><span class="line">  deleteElem(<span class="built_in">list</span>, <span class="number">5</span>);</span><br><span class="line">  length = getLength(<span class="built_in">list</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"链表长度为:%d\n"</span>,length);</span><br><span class="line">  e = getElem(<span class="built_in">list</span>, <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span>(e != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"查询的值为:%d\n"</span>,e-&gt;data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"链表第一个元素:%d"</span>,<span class="built_in">list</span>-&gt;next-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、循环链表与双向链表"><a href="#四、循环链表与双向链表" class="headerlink" title="四、循环链表与双向链表"></a>四、循环链表与双向链表</h2><p>&ensp;&ensp;&ensp;&ensp;对于以上功能的实现仅仅是在单项链表上做了一些改变。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kalman滤波算法</title>
      <link href="/2018/10/15/%E5%8D%A1%E5%B0%94%E6%9B%BC-Kalman-%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E3%80%81C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
      <url>/2018/10/15/%E5%8D%A1%E5%B0%94%E6%9B%BC-Kalman-%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E3%80%81C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h1><h2 id="一、滤波效果展示"><a href="#一、滤波效果展示" class="headerlink" title="一、滤波效果展示"></a>一、滤波效果展示</h2><p>&#8195;&#8195;蓝色的波形是实际测得的数据，红色的波形是经 Kalman 滤波后的数据波形。<br><strong>注：这里是实际应用激光测距传感器（TOF）vl53l0x 测得的距离数据。</strong><br><img src="https://img-blog.csdnimg.cn/20190517104449922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><h2 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h2><p>&#8195;&#8195;采用递归的方法解决线性滤波问题，只需要当前的测量值和前一个采样周期的估计值就能进行状态估计，需要的存储空间小，每一步的计算量小。</p><h2 id="三、组成"><a href="#三、组成" class="headerlink" title="三、组成"></a>三、组成</h2><h3 id="1-预测状态方程"><a href="#1-预测状态方程" class="headerlink" title="1. 预测状态方程"></a>1. 预测状态方程</h3><h4 id="（1）目的："><a href="#（1）目的：" class="headerlink" title="（1）目的："></a>（1）目的：</h4><p>&#8195;&#8195;由 <strong>系统状态变量k-1时刻的最优值</strong> 和 <strong>系统输入</strong> 计算出k时刻的 <strong>系统预测值</strong>。</p><h4 id="（2）方程："><a href="#（2）方程：" class="headerlink" title="（2）方程："></a>（2）方程：</h4><p><img src="https://img-blog.csdnimg.cn/20190517104648876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><h4 id="（3）备注"><a href="#（3）备注" class="headerlink" title="（3）备注"></a>（3）备注</h4><p>&#8195;&#8195;①.  X k-1|k-1  为k-1时刻的输出。<br>&#8195;&#8195;②.  当X为一维数据时，Fk的值是1。<br>&#8195;&#8195;③. <strong>一维数据下（uk=0时）：系统预测值 = 系统状态变量k-1时刻的最优值。</strong></p><h3 id="2-预测协方差方程"><a href="#2-预测协方差方程" class="headerlink" title="2. 预测协方差方程"></a>2. 预测协方差方程</h3><h4 id="（1）目的"><a href="#（1）目的" class="headerlink" title="（1）目的"></a>（1）目的</h4><p>&#8195;&#8195;根据 <strong>k-1时刻的系统协方差</strong> 预测 <strong>k时刻系统协方差</strong>。</p><h4 id="（2）方程"><a href="#（2）方程" class="headerlink" title="（2）方程"></a>（2）方程</h4><p><img src="https://img-blog.csdnimg.cn/20190517104838972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><h4 id="（3）备注-1"><a href="#（3）备注-1" class="headerlink" title="（3）备注"></a>（3）备注</h4><p>&#8195;&#8195;①. 当X为一维数据时，Fk的值是1。</p><h3 id="3-卡尔曼增益方程"><a href="#3-卡尔曼增益方程" class="headerlink" title="3. 卡尔曼增益方程"></a>3. 卡尔曼增益方程</h3><h4 id="（1）目的-1"><a href="#（1）目的-1" class="headerlink" title="（1）目的"></a>（1）目的</h4><p>&#8195;&#8195;根据（k时刻） <strong>协方差矩阵的预测值</strong> 计算 <strong>卡尔曼增益</strong>。</p><h4 id="（2）方程-1"><a href="#（2）方程-1" class="headerlink" title="（2）方程"></a>（2）方程</h4><p><img src="https://img-blog.csdnimg.cn/20190517105000426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><h4 id="（3）备注-2"><a href="#（3）备注-2" class="headerlink" title="（3）备注"></a>（3）备注</h4><p>&#8195;&#8195;①. 当 Pk|k-1 为一个一维矩阵时，Hk 是1。</p><h3 id="4-跟新最优值方程（卡尔曼滤波的输出）"><a href="#4-跟新最优值方程（卡尔曼滤波的输出）" class="headerlink" title="4. 跟新最优值方程（卡尔曼滤波的输出）"></a>4. 跟新最优值方程（卡尔曼滤波的输出）</h3><h4 id="（1）目的-2"><a href="#（1）目的-2" class="headerlink" title="（1）目的"></a>（1）目的</h4><p>&#8195;&#8195;根据 <strong>状态变量的预测值</strong> 和 <strong>系统测量值</strong> 计算出 <strong>k时刻状态变量的最优值</strong>。</p><h4 id="（2）方程-2"><a href="#（2）方程-2" class="headerlink" title="（2）方程"></a>（2）方程</h4><p><img src="https://img-blog.csdnimg.cn/20190517105207503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><h4 id="（3）备注-3"><a href="#（3）备注-3" class="headerlink" title="（3）备注"></a>（3）备注</h4><p>&#8195;&#8195;①. 当 Pk|k-1 为一个一维矩阵时，Hk 是1。</p><h3 id="5-更新协方差方程"><a href="#5-更新协方差方程" class="headerlink" title="5. 更新协方差方程"></a>5. 更新协方差方程</h3><h4 id="（1）目的-3"><a href="#（1）目的-3" class="headerlink" title="（1）目的"></a>（1）目的</h4><p>&#8195;&#8195;为了求 <strong>k时刻的协方差矩阵</strong>。（为得到k+1时刻的卡尔曼输出值做准备）</p><h4 id="（2）方程-3"><a href="#（2）方程-3" class="headerlink" title="（2）方程"></a>（2）方程</h4><p><img src="https://img-blog.csdnimg.cn/20190517105449503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><h4 id="（3）备注-4"><a href="#（3）备注-4" class="headerlink" title="（3）备注"></a>（3）备注</h4><p>&#8195;&#8195;①. 当 Pk|k-1 为一个一维矩阵时，Hk 是1。</p><h2 id="四、C-程序代码实现"><a href="#四、C-程序代码实现" class="headerlink" title="四、C 程序代码实现"></a>四、C 程序代码实现</h2><h3 id="1-参数列表"><a href="#1-参数列表" class="headerlink" title="1. 参数列表"></a>1. 参数列表</h3><p><img src="https://img-blog.csdnimg.cn/20190517105559481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><h3 id="2-代码实现（一维数据滤波）"><a href="#2-代码实现（一维数据滤波）" class="headerlink" title="2. 代码实现（一维数据滤波）"></a>2. 代码实现（一维数据滤波）</h3><p>&#8195;&#8195;<strong>实际参数是参照别人已经选好的参数，不过也可以自己改变参数，去观察波形的效果，体会每个参数对于滤波效果的影响，这里不详细介绍</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 结构体类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> LastP;<span class="comment">//上次估算协方差 初始化值为0.02</span></span><br><span class="line">    <span class="keyword">float</span> Now_P;<span class="comment">//当前估算协方差 初始化值为0</span></span><br><span class="line">    <span class="keyword">float</span> out;<span class="comment">//卡尔曼滤波器输出 初始化值为0</span></span><br><span class="line">    <span class="keyword">float</span> Kg;<span class="comment">//卡尔曼增益 初始化值为0</span></span><br><span class="line">    <span class="keyword">float</span> Q;<span class="comment">//过程噪声协方差 初始化值为0.001</span></span><br><span class="line">    <span class="keyword">float</span> R;<span class="comment">//观测噪声协方差 初始化值为0.543</span></span><br><span class="line">&#125;KFP；<span class="comment">//Kalman Filter parameter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 以高度为例 定义卡尔曼结构体并初始化参数</span></span><br><span class="line">KFP KFP_height=&#123;<span class="number">0.02</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.001</span>,<span class="number">0.543</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *卡尔曼滤波器</span></span><br><span class="line"><span class="comment"> *@param KFP *kfp 卡尔曼结构体参数</span></span><br><span class="line"><span class="comment"> *   float input 需要滤波的参数的测量值（即传感器的采集值）</span></span><br><span class="line"><span class="comment"> *@return 滤波后的参数（最优值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">float</span> <span class="title">kalmanFilter</span><span class="params">(KFP *kfp,<span class="keyword">float</span> input)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="comment">//预测协方差方程：k时刻系统估算协方差 = k-1时刻的系统协方差 + 过程噪声协方差</span></span><br><span class="line">     kfp-&gt;Now_P = kfp-&gt;LastP + kfp-&gt;Q;</span><br><span class="line">     <span class="comment">//卡尔曼增益方程：卡尔曼增益 = k时刻系统估算协方差 / （k时刻系统估算协方差 + 观测噪声协方差）</span></span><br><span class="line">     kfp-&gt;Kg = kfp-&gt;Now_P / (kfp-&gt;NOw_P + kfp-&gt;R);</span><br><span class="line">     <span class="comment">//更新最优值方程：k时刻状态变量的最优值 = 状态变量的预测值 + 卡尔曼增益 * （测量值 - 状态变量的预测值）</span></span><br><span class="line">     kfp-&gt;out = kfp-&gt;out + kfp-&gt;Kg * (input -kfp-&gt;out);<span class="comment">//因为这一次的预测值就是上一次的输出值</span></span><br><span class="line">     <span class="comment">//更新协方差方程: 本次的系统协方差付给 kfp-&gt;LastP 威下一次运算准备。</span></span><br><span class="line">     kfp-&gt;LastP = (<span class="number">1</span>-kfp-&gt;Kg) * kfp-&gt;Now_P;</span><br><span class="line">     <span class="keyword">return</span> kfp-&gt;out；</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *调用卡尔曼滤波器 实践</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line"><span class="keyword">int</span> kalman_height=<span class="number">0</span>;</span><br><span class="line">kalman_height = kalmanFilter(&amp;KFP_height,(<span class="keyword">float</span>)<span class="built_in">height</span>);</span><br></pre></td></tr></table></figure></p><h2 id="五、发送波形到上位机显示"><a href="#五、发送波形到上位机显示" class="headerlink" title="五、发送波形到上位机显示"></a>五、发送波形到上位机显示</h2><p>&#8195;&#8195;这里使用的是匿名的上位机 V65 版本，具体如何使用可以参考茶大的博客，并且茶大博客里面有上位机的下载地址。茶大博客地址：<a href="https://blog.csdn.net/wangjt1988/article/details/83684188" target="_blank" rel="noopener">https://blog.csdn.net/wangjt1988/article/details/83684188</a><br>注：文章方程截图及参数来源于中科浩电。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kalman </tag>
            
            <tag> vl53l0x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四旋翼PID控制原理</title>
      <link href="/2018/07/26/%E5%9B%9B%E6%97%8B%E7%BF%BC-PID-%E6%8E%A7%E5%88%B6/"/>
      <url>/2018/07/26/%E5%9B%9B%E6%97%8B%E7%BF%BC-PID-%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、PID-原理"><a href="#一、PID-原理" class="headerlink" title="一、PID 原理"></a>一、PID 原理</h2><p>&#8195;&#8195; <strong>偏差控制</strong>，利用目标值（期望值）与实际测量值构成的偏差（误差）对被控对象进行线性的控制。<strong>偏差 = 目标值 - 测量值</strong>。</p><h2 id="二、四旋翼串级双闭环-PID-控制"><a href="#二、四旋翼串级双闭环-PID-控制" class="headerlink" title="二、四旋翼串级双闭环 PID 控制"></a>二、四旋翼串级双闭环 PID 控制</h2><p>&#8195;&#8195;对于四旋翼，可以理解外环为角度环，内环是角速度环。</p><h3 id="1-外环"><a href="#1-外环" class="headerlink" title="1. 外环"></a>1. 外环</h3><p><img src="https://img-blog.csdnimg.cn/20190517170845818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><ol><li>目标值：期望轨迹，即期望的姿态角度。</li><li>测量值：实际的姿态角度。</li><li>PID控制器的输入：目标值 - 测量值。</li><li>PID控制器的输出：提供使测量值趋近于目标值的方法<br><strong>注：</strong><br>①. <strong>外环是位置反馈 -&gt; 反馈了当前的位置，即当前偏航了多少角度。</strong><br>②. <strong>外环控制是为了达到期望的角度，因为角度是由角速度积分得到，dT时间，外环输出的控制量反应角度的偏差值，dT时间的角度偏差即角速度，所以把外环PID的输出作为角速度来用，外环的输出就是我们想要达到的角速度。把外环的输出作为内环的输入（内环的目标值），即我们期望角速度进行怎么样的变化，才能使姿态角度达到我们期望的姿态角度。</strong> <h3 id="2-内环"><a href="#2-内环" class="headerlink" title="2.内环"></a>2.内环</h3><img src="https://img-blog.csdnimg.cn/20190517195252408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></li><li>目标值：外环的输出，即期望的角速度。</li><li>测量值：实际的角速度。</li><li>PID 输入：目标值减去测量值。</li><li>PID 输出：提供使测量值趋近目标值的方法。<br><strong>注：</strong><br>①. 内环的目的是要达到期望的角速度，角速度直接与电机的转速有关系。所以内环 PID 的输出，作为实际调节电机转速的参数去使用。<br>②. 在纯姿态模式下，四旋翼电机的转速由两部分组成，遥控油门提供的是<strong>基础转速</strong>，PID的输出作为维持姿态平稳的<strong>调节转速</strong>。这就是纯姿态模式下飞机的高度不好控制的原因，要使飞机维持在一个高度，就需要基础转速所提供的升力刚好与重力相等。飞行过程中维持飞机平稳的是调节转速，它保证了飞机平衡的姿态。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PID </tag>
            
            <tag> 四旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CC3200实现浇水控制（实现一个简单的物联网系统-5）</title>
      <link href="/2018/05/10/CC3200%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E5%AE%9E%E7%8E%B0%E5%BC%95%E8%84%9A%E6%8B%89%E9%AB%98%E3%80%81%E6%8B%89%E4%BD%8E-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-5/"/>
      <url>/2018/05/10/CC3200%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E5%AE%9E%E7%8E%B0%E5%BC%95%E8%84%9A%E6%8B%89%E9%AB%98%E3%80%81%E6%8B%89%E4%BD%8E-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-5/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;前面已经可以实现从服务器获得用户想要的浇水量，下面就需要对IO口进行拉高拉低对水泵的启停进行控制。</p><h2 id="二、CC3200-GPIO-简介"><a href="#二、CC3200-GPIO-简介" class="headerlink" title="二、CC3200 GPIO 简介"></a>二、CC3200 GPIO 简介</h2><p>&#8195;&#8195;CC3200所有逻辑引脚和部分模拟引脚均可以用来作为通用输入/输出(GPIO)使用。GPIO功能可用于各种逻辑输入输出的场合。 GPIO有4组（GPIO A0~A3），每组8个。 具体如下：<br>&#8195;&#8195;①. &#8195;GPIO A0： GPIO_00~GPIO_07, 对应 GPIOA0.0~GPIOA0.7 。<br>&#8195;&#8195;②. &#8195;GPIO A1： GPIO_08~GPIO_15, 对应 GPIOA1.0~GPIOA1.7 。<br>&#8195;&#8195;③. &#8195;GPIO A2： GPIO_00~GPIO_07, 对应 GPIOA2.0~GPIOA2.7 。<br>&#8195;&#8195;④. &#8195;GPIO A3： GPIO_00~GPIO_07, 对应 GPIOA3.0~GPIOA3.7 。</p><p>&#8195;&#8195;根据功能引脚的配置不同， GPIO的数量有27个 。所有GPIO引脚具备中断能力(电平有效或者边沿有效、上升或下降沿触发、有中断屏蔽)。可用于出发DMA或作为唤醒源。</p><h2 id="三、简单易懂实现IO口拉高拉低"><a href="#三、简单易懂实现IO口拉高拉低" class="headerlink" title="三、简单易懂实现IO口拉高拉低"></a>三、简单易懂实现IO口拉高拉低</h2><p>&#8195;&#8195;CC3200 提供了一系列 API 去更方便的实现用户想要的功能。在SDK的 driverlib 和 src 下。我们导入的例程都包含了这些API。但是例程里面的实现方法显得过于复杂，不易理解，但是对我们来说是一个重要的参考。下面 过滤掉  “_if_” 层，通过直接调用 API 实现对IO的拉高拉低。==注意：==<strong>重要的说明在程序的注释中，对于每一个形参代表的意思的理解非常重要。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">BoardInit();<span class="comment">//板子初始化</span></span><br><span class="line"><span class="comment">/*--引脚配置  Start--*/</span></span><br><span class="line">        PinTypeGPIO(PIN_64, PIN_MODE_0, <span class="literal">false</span>);<span class="comment">//参数：引脚名 引脚功能模式  开漏模式或STD</span></span><br><span class="line">        GPIODirModeSet(GPIOA1_BASE, GPIO_PIN_1, GPIO_DIR_MODE_OUT);<span class="comment">//哪一组的端口地址  GPIO_A1的第1个 GPIO位权(0~7)   输入或者输出</span></span><br><span class="line">        <span class="comment">/*--引脚配置  End--*/</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        MAP_UtilsDelay(<span class="number">2000000</span>);</span><br><span class="line">        GPIOPinWrite(GPIOA1_BASE,GPIO_PIN_1,GPIO_PIN_1);<span class="comment">//拉高IO口</span></span><br><span class="line">        MAP_UtilsDelay(<span class="number">2000000</span>);</span><br><span class="line">        GPIOPinWrite(GPIOA1_BASE,GPIO_PIN_1,<span class="number">0</span>);<span class="comment">//拉低IO口</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样就实现了对于PIN_64引脚的拉高拉低操作，如果是launchpad的话就可以看到LED灯一直闪烁。<br>==注：== 在pin.h 和 gpio.h 中都对于每一个IO口的地址都进行了定义，对于每一个API只需要相对应的使用即可，但是，<strong>需要了解 T I对 CC3200 的引脚定义，知道其对应关系，具体参照下表。</strong>(引自源地的资料)<br><img src="https://img-blog.csdnimg.cn/20190211195928213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><h2 id="四、学习方法"><a href="#四、学习方法" class="headerlink" title="四、学习方法"></a>四、学习方法</h2><p>&#8195;&#8195;TI 对于每一种功能都提供了例程，所以如果我们需要用到相应的功能就可以直接去参考例程中是如何配置的，这对于为了快速的上手开发是一个行之有效的好方法。 比如：我们模数转换会用到ADC ，那么就可以直接去参考例程中的ADC有关引脚的配置，等等。</p><h2 id="五、视频展示"><a href="#五、视频展示" class="headerlink" title="五、视频展示"></a>五、视频展示</h2><p>&#8195;&#8195;到此为止，整个远程浇水系统就完成了，达不到商品化的稳定性，但能够在较长时间内实现该功能。<br><strong>视频地址：</strong> <a href="https://www.bilibili.com/video/av43996928" target="_blank" rel="noopener">https://www.bilibili.com/video/av43996928</a></p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> CC3200 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CC3200上传数据到服务器（实现一个简单的物联网系统-4）</title>
      <link href="/2018/05/02/CC3200%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-4/"/>
      <url>/2018/05/02/CC3200%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-4/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;上篇文章已经完成了从服务器 get 数据，这篇将通过 post 的方式，将通过CC3200测得的花卉状态信息（如土壤湿度、光照强度）上传到服务器。其实post的方式也实现了接收服务器返回的数据，所以只发送一个post请求就可以完成数据的上传和获取，具体在下面说明。</p><h2 id="二、CC3200-连接到路由器（AP）"><a href="#二、CC3200-连接到路由器（AP）" class="headerlink" title="二、CC3200 连接到路由器（AP）"></a>二、CC3200 连接到路由器（AP）</h2><p>&#8195;&#8195;这里已经在上篇文章说过了，具体可以参照：<br>&#8195;&#8195;<a href="https://blog.csdn.net/CSDN_X_W/article/details/86756675" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_X_W/article/details/86756675</a></p><h2 id="三、CC3200-post-数据到服务器"><a href="#三、CC3200-post-数据到服务器" class="headerlink" title="三、CC3200 post 数据到服务器"></a>三、CC3200 post 数据到服务器</h2><p>&#8195;&#8195; 同样是将后台代码和CC3200的相关配置一起列出来。<br><strong>3.1 后台代码：</strong> 这里解析的数据是CC3200发送过来的花卉状态信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理CC3200 POST 给服务器的数据 -&gt;更新花卉的状态信息 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span>   <span class="comment">//用于接收CC3200 post 过来的数据</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/cc3200Post"</span>)   <span class="comment">//这个方法用来处理CC3200Post请求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">CC3200PostResponse</span><span class="params">(@RequestBody String flower_info)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">    <span class="comment">/*--更新花卉的状态信息--*/</span></span><br><span class="line">    <span class="keyword">int</span> monitorID;</span><br><span class="line">    <span class="keyword">float</span> co2;</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">    System.out.println(flower_info);</span><br><span class="line">    <span class="comment">//1.解析post过来的数据</span></span><br><span class="line">    JSONObject jsonObject = <span class="keyword">new</span> JSONObject(flower_info);</span><br><span class="line">    monitorID = jsonObject.getInt(<span class="string">"monitorID"</span>);</span><br><span class="line">    co2 = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"co2"</span>);</span><br><span class="line">    temperature = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"temperature"</span>);</span><br><span class="line">    humidity = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"humidity"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.根据花卉监测系统ID更新数据库的数据</span></span><br><span class="line">    String updateSql =</span><br><span class="line">            <span class="string">"update flowers set co2 ="</span> + <span class="string">"'"</span> + co2 + <span class="string">"'"</span> +<span class="string">","</span>+</span><br><span class="line">            <span class="string">"temperature ="</span>+<span class="string">"'"</span> + temperature + <span class="string">"'"</span> +<span class="string">","</span>+</span><br><span class="line">            <span class="string">"humidity ="</span>+<span class="string">"'"</span> + humidity + <span class="string">"'"</span> +</span><br><span class="line">            <span class="string">" WHERE monitor_id ="</span>+ <span class="string">"'"</span> + monitorID + <span class="string">"'"</span>;</span><br><span class="line">    jdbcTemplate.update(updateSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>3.2 CC3200 代码：</strong> </p><ol><li>CC3200 的相关配置，在main.c 中 , IP 和端口配置不再赘述，参考上篇文章。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POST_REQUEST_URI  <span class="meta-string">"/cc3200Post"</span>         <span class="comment">//请求方式 即发送什么样的请求</span></span></span><br><span class="line"><span class="comment">/*--Post过去的数据--*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POST_DATA       <span class="meta-string">"&#123;\n\"name\":\"xyz\",\n\"address\":\n&#123;\n\"plot#\":12,\n\"street\":\"abc\",\n\"city\":\"ijk\"\n&#125;,\n\"age\":30\n&#125;"</span></span></span><br></pre></td></tr></table></figure></li><li>在 CC3200 中post数据的具体实现通过调用 static int HTTPPostMethod(HTTPCli_Handle httpClient) 函数中调用的 TTPCli_sendRequestBody(httpClient, POST_DATA , (sizeof(POST_DATA )-1));  来实现的，这样运行后就能在后台接收到 POST_DATA 当中的数据。这样我们就已经实现了将数据 post 到服务器。<h2 id="四、疑问（重要）"><a href="#四、疑问（重要）" class="headerlink" title="四、疑问（重要）"></a>四、疑问（重要）</h2>&#8195;&#8195;1.==需要思考这样一个问题== ：我们 post 过去的数据是要有变量的，如温度（temperature），可是如何将这样一些变量拼接 JSON 形式的字符串当中去呢？早就有人帮我们写好了这样的库，即-&gt; cJSON , 需要引入 cJSON 的 .c 和 .h 文件后可参考下面这样一段代码：<br>&#8195;&#8195;2.定义 flowerStatusData 代替原来的 POST_DATA，则原来的 TTPCli_sendRequestBody函数的形参也要相应修改：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">char</span> *outData;</span><br><span class="line"><span class="keyword">char</span> flowerStatusData[<span class="number">63</span>]=&#123;<span class="number">0</span>&#125;;  <span class="comment">//数组长度应该是 strlen 得到的字符串长度加一   这个值根据上传的数据量经调试打印得到</span></span><br></pre></td></tr></table></figure>&#8195;&#8195;3.具体post数据的部分可以参考如下代码，main.c 中：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--根据测得的数据信息，post数据到服务器，从而更新花卉的状态数据--*/</span></span><br><span class="line"><span class="comment">//创建一个cJSON结构体指针并分配空间，然后赋值给root</span></span><br><span class="line">cJSON *root = cJSON_CreateObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在root结构体中创建一组健为"key",值为" value" 的键值对。</span></span><br><span class="line">cJSON_AddNumberToObject(root,<span class="string">"monitorID"</span>,monitor_id);</span><br><span class="line">cJSON_AddNumberToObject(root,<span class="string">"co2"</span>,co2);</span><br><span class="line">cJSON_AddNumberToObject(root,<span class="string">"temperature"</span>,temperature);</span><br><span class="line">cJSON_AddNumberToObject(root,<span class="string">"humidity"</span>,humidity);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--得到无格式形式的json字符串，即输出无回车和空格分离的键值对--*/</span></span><br><span class="line">        outData = cJSON_PrintUnformatted(root);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(flowerStatusData, outData, <span class="built_in">strlen</span>(outData));</span><br><span class="line">UART_PRINT(<span class="string">"\n\r"</span>);</span><br><span class="line">UART_PRINT(<span class="string">"HTTP Post Begin:\n\r"</span>);</span><br><span class="line">    lRetVal = HTTPPostMethod(&amp;httpClient);</span><br><span class="line">    <span class="keyword">if</span>(lRetVal &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    UART_PRINT(<span class="string">"HTTP Post failed.\n\r"</span>);</span><br><span class="line">&#125;</span><br><span class="line">UART_PRINT(<span class="string">"HTTP Post End:\n\r"</span>);</span><br><span class="line"><span class="built_in">free</span>(outData);<span class="comment">//释放malloc分配的空间</span></span><br><span class="line">        cJSON_Delete(root);<span class="comment">//释放cJSON结构体指针</span></span><br></pre></td></tr></table></figure></li></ol><p>注：具体 cJSON 的使用可以百度到很多博客，cJSON 的下载网址为：<br>&#8195;&#8195;<a href="https://sourceforge.net/projects/cjson/" target="_blank" rel="noopener">https://sourceforge.net/projects/cjson/</a><br>&#8195;&#8195;直接将cJSON.c  和 cJOSN.h 添加到工程调用即可。</p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> CC3200 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CC3200从服务器获取数据（实现一个简单的物联网系统-3）</title>
      <link href="/2018/04/28/CC3200-%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-3/"/>
      <url>/2018/04/28/CC3200-%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;借助 TI 公司的 CC3200 我们可以通过 http 轻松的完成与服务器之间的数据交互，体验CC3200的开箱即用的感觉，下面借助 http_client_demo 这个历程来实现从服务器 get 数据。实现我们从服务器得到用户的浇水信息。<br>&#8195;&#8195;<strong>CC3200的SDK 里面提供了所有的关于CC3200的资料，真的非常重要。</strong> 如：API文档、例程、例程使用文档、数据手册、原理图 … 等等。<br><img src="https://img-blog.csdnimg.cn/20190203100601961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%></p><h2 id="二、CC3200-连接到路由器（AP）"><a href="#二、CC3200-连接到路由器（AP）" class="headerlink" title="二、CC3200 连接到路由器（AP）"></a>二、CC3200 连接到路由器（AP）</h2><p>&#8195;&#8195;此时CC3200 作为站点，即工作在 Sta（station）模式。简单理解就好比我们手机连上路由器或者数据才能上网一样，所需配置的地方如下：在common.h 中</p><ol><li>SSID_NAME ：填入路由器所设置的名字。</li><li>SECURITY_TYPE ：安全方式，路由器设置为有密码时一般为  SL_SEC_TYPE_WPA_WPA2；没有密码时，定义为 SL_SEC_TYPE_OPEN。</li><li>SECURITY_KEY ：有密码时这里填入密码。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Values for below macros shall be modified as per access-point(AP) properties// Values for below macros shall be modified as per access-point(AP) properties</span></span><br><span class="line"><span class="comment">// SimpleLink device will connect to following AP when application is executed</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*--下面的设置为CC3200作为客户端时需要连接的路由器的相关信息 所以要根据所连接的路由器进行修改--*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SSID_NAME           <span class="meta-string">" "</span>    <span class="comment">/* AP SSID */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECURITY_TYPE       SL_SEC_TYPE_WPA_WPA2    <span class="comment">/* Security type (OPEN or WEP or WPA*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECURITY_KEY        <span class="meta-string">" "</span>              <span class="comment">/* Password of the secured AP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SSID_LEN_MAX        32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSSID_LEN_MAX       6</span></span><br></pre></td></tr></table></figure>&#8195;&#8195;运行程序仿真运行，可以登录路由器网关查看连接状态。或者直接用串口打印出来看连接是否成功，如下图：<br><img src="https://img-blog.csdnimg.cn/20190203105204365.png"width=80% height=80%><br>&#8195;&#8195;仿真报错时可以参考下面这篇博客：<br>&#8195;&#8195;<a href="https://blog.csdn.net/CSDN_X_W/article/details/86676351" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_X_W/article/details/86676351</a><h2 id="三、从服务器-get-数据"><a href="#三、从服务器-get-数据" class="headerlink" title="三、从服务器 get 数据"></a>三、从服务器 get 数据</h2>&#8195;&#8195;首先需要将上一节的服务器端运行起来，根据服务器去更改CC3200这边的相应请求，再贴上上一节后台服务器的代码一起参考：<br>&#8195;&#8195;<strong>3.1、后台代码：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 处理CC3200 发送过来的 GET 请求 -&gt;查询花卉的浇水量返回给CC3200  <span class="doctag">@TODO</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ResponseBody</span>   <span class="comment">//用于将数据写出去</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/cc3200Query"</span>)   <span class="comment">//这个方法用来处理query请求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt;  <span class="title">cc3200GetResponse</span><span class="params">(@RequestParam <span class="keyword">int</span> monitor_id)</span> </span>&#123;    <span class="comment">//这个字符串拼接的方法来实现sql语句中嵌套变量好嘛？</span></span><br><span class="line">    String querySql = <span class="string">"select * From flowers where monitor_id ="</span> + <span class="string">"'"</span> + monitor_id + <span class="string">"'"</span>;</span><br><span class="line">    <span class="comment">//这样返回的是一个map 而不是 list 的形式更方便CC3200那边去解析</span></span><br><span class="line">    Map&lt;String, Object&gt; map =jdbcTemplate.queryForMap(querySql);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&#8195;&#8195;<strong>3.2、CC3200 相关配置：</strong> </li><li>更改 main.c 中如下配置：&#8195;&#8195;&#8195;&#8195;ip根据自己的实际更改<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_REQUEST_URI  <span class="meta-string">"/cc3200Query?monitor_id=1"</span><span class="comment">//请求方式 即发送什么样的请求  请求参数为monitor_id</span></span></span><br><span class="line"><span class="comment">/*--HOST_NAME HTTP服务器的IP地址或者域名  如我的服务器的IP地址为......--*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST_NAME        <span class="meta-string">"192.168.43.148"</span> <span class="comment">//"&lt;host name&gt;"</span></span></span><br><span class="line"><span class="comment">/*--HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如tomcat的默认端口是8080 http://localhost:8080/--*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST_PORT           8080</span></span><br></pre></td></tr></table></figure><ol><li>==重点：更改所 get 的数据的长度== （没找到相关博客和TI教程我看代码研究了好久，可能C基础较差吧。）<br>&#8195;&#8195;①. len的长度决定了最终放到 g_buff 中数据的个数，否则g_buf中存放的是当前时间。<br>&#8195;&#8195;②. 最终get到的数据就存放再 g_buff 这个静态变量中，可以直接打印到控制台。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readResponse</span><span class="params">(HTTPCli_Handle httpClient)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">long</span> lRetVal = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> len = <span class="number">114</span>;  <span class="comment">//@TODO 重要：这里决定了收到的数据的长度  数值靠数   包括外面的大括号</span></span><br><span class="line"> <span class="keyword">int</span> json = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">char</span> *dataBuffer=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">bool</span> moreFlags = <span class="number">1</span>;</span><br><span class="line"> <span class="comment">//.......</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>再程序的最后把 get 到的数据打印到控制台。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">UART_PRINT(<span class="string">"\n\r"</span>);</span><br><span class="line">UART_PRINT(<span class="string">"HTTP Get Begin:\n\r"</span>);</span><br><span class="line">lRetVal = HTTPGetMethod(&amp;httpClient);</span><br><span class="line"><span class="keyword">if</span>(lRetVal &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    UART_PRINT(<span class="string">"HTTP Post Get failed.\n\r"</span>);</span><br><span class="line">&#125;</span><br><span class="line">UART_PRINT(<span class="string">"HTTP Get End:\n\r"</span>);</span><br><span class="line">UART_PRINT(<span class="string">"\n\r"</span>);</span><br><span class="line"><span class="comment">/*--根据得到的json数据进行解析 Start--*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"g_buff:%s\n"</span>,g_buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"size:%d\n"</span>,<span class="built_in">strlen</span>(g_buff));</span><br></pre></td></tr></table></figure>&#8195;&#8195;这样就可以在控制台打印出如下数据：<br><img src="https://img-blog.csdnimg.cn/2019020311590237.png"weight=70% height=70%><br>&#8195;&#8195;<strong>注意：</strong><br>&#8195;&#8195;&#8195;&#8195;①. ==在用printf(“”); 打印时一定要加上换行“\n” ;不然数据是打印不出来的。==<br>&#8195;&#8195;&#8195;&#8195;②. 现在得到的数据为 JSON 格式，如果想得到某一项数据，需要对得到的 JSON 数据进行解析，最好的办法是使用 cJSON 库，具体可参照下面一段代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cJSON *root;</span><br><span class="line">       cJSON *ret;</span><br><span class="line">       root = cJSON_Parse(g_buff);    <span class="comment">//将cJSON字符串转换为cJSON结构体指针</span></span><br><span class="line">       ret = cJSON_GetObjectItem(root, <span class="string">"bulk"</span>);    <span class="comment">//在root结构体中查找"key"这个键(一个字符串),成功返回一个cJSON结构体，失败返回NULL。</span></span><br><span class="line">       bulk=ret-&gt;valueint;<span class="comment">//获取到浇水量</span></span><br><span class="line">       cJSON_Delete(ret);    <span class="comment">//释放cJSON结构体指针</span></span><br><span class="line">       cJSON_Delete(root);    <span class="comment">//释放cJSON结构体指针</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,bulk);<span class="comment">//打印到控制台查看</span></span><br></pre></td></tr></table></figure>==注：== cJSON 的下载地址如下，直接复制 cJSON.c 和 cJSON.h 到工程中使用即可。<br>&#8195;&#8195;<a href="https://sourceforge.net/projects/cjson/" target="_blank" rel="noopener">https://sourceforge.net/projects/cjson/</a></li></ol></li></ol><h2 id="四、学习方法"><a href="#四、学习方法" class="headerlink" title="四、学习方法"></a>四、学习方法</h2><p>&#8195;&#8195;1.TI SDK 中提供了大量的例程，而直接导入例程稍作修改就能够实现我们想要的目的，是一个很好的参考，在看例程的过程中也可以加强编写程序的规范性。</p><p>&#8195;&#8195;2.如果项目中应用到了更多的功能，也可以将相关的例程融合到一起，对于 CC3200 主要的用到的是 driverlib 这个库，各个功能都封装成了API供我们快速开发，很方便。</p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> CC3200 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个简单的后端服务（实现一个简单的物联网系统-2）</title>
      <link href="/2018/04/23/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SpringBoot%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%EF%BC%88-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-2-%EF%BC%89/"/>
      <url>/2018/04/23/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SpringBoot%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%EF%BC%88-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-2-%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>&#8195;&#8195;可以说站在Spring Boot的肩膀上，相对于我之前用最古老的servlet，完成一个简单的后台服务实在变得太容易太容易。但是对于一个完全不了解的人可以参考目录中的<strong>学习方法</strong>。对于实现远程浇花的功能，只需要处理APP 和 CC3200 发送过来的 get 、post 请求即可。</p><h2 id="二、说明"><a href="#二、说明" class="headerlink" title="二、说明"></a>二、说明</h2><p>&#8195;&#8195;①．Spring Boot 只是一个框架，通过联网帮助我们完成了各种配置，简化开发。<br>&#8195;&#8195;②．具体详细的步骤可以在学习SpringBoot的过程中不断实践。<br><strong>注意：IDEA一定要用专业版，社区版的是不能构建SpringBoot项目的，如下图社区版根本没有红色圈中的那项：</strong><br><img src="https://img-blog.csdnimg.cn/20190202185505506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width = 80% height = 40%/></p><h2 id="三、数据库"><a href="#三、数据库" class="headerlink" title="三、数据库"></a>三、数据库</h2><p>&#8195;&#8195;当然后台要负责与数据库进行交互，花卉的信息也全都存放在数据库上。后台的代码就是要对数据库进行增、删、改、查等操作。我用的是MySQL。直接装，或者用Docker。</p><h2 id="四、后台服务代码"><a href="#四、后台服务代码" class="headerlink" title="四、后台服务代码"></a>四、后台服务代码</h2><ol><li>Cotroller部分：这里即包含了APP的后台服务，也包含了CC3200的后台服务，后面不再赘述。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowerManagerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-------------------处理 APP 与后台的交互-----------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 APP 发送过来的 GET 请求 -&gt; 查询花卉的所有信息返回给 APP</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flower_name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>   <span class="comment">//用于将数据写出去</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/appQuery"</span>)   <span class="comment">//这个方法用来处理query请求</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; appGetResponse(<span class="meta">@RequestParam</span> String flower_name) &#123;</span><br><span class="line">        <span class="comment">//字符串拼接的方法来实现sql语句中嵌套变量</span></span><br><span class="line">        String querySql = <span class="string">"select * From flowers where name ="</span> + <span class="string">"'"</span> + flower_name + <span class="string">"'"</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(querySql);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 APP POST 给服务器的数据 -&gt;更新数据库中的浇水量 bulk  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>   <span class="comment">//用于接收APP post 过来的数据</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/appPost"</span>)   <span class="comment">//这个方法用来处理App的post请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appPostResponse</span><span class="params">(@RequestBody String flower_info)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">        <span class="comment">/*--更改花卉的浇水量--*/</span></span><br><span class="line">        String flower_name;</span><br><span class="line">    <span class="keyword">int</span> bulk;</span><br><span class="line">        <span class="comment">//1.解析post过来的数据</span></span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject(flower_info);</span><br><span class="line">        mFlower_name = jsonObject.getString(<span class="string">"name"</span>);</span><br><span class="line">        mBulk = jsonObject.getInt(<span class="string">"bulk"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.根据花卉名称和浇水量更新DB的数据</span></span><br><span class="line">        String updateSql = <span class="string">"update flowers set bulk ="</span> + <span class="string">"'"</span> + bulk + <span class="string">"'"</span> + <span class="string">" WHERE name ="</span> + <span class="string">"'"</span> + flower_name + <span class="string">"'"</span>;    </span><br><span class="line">        jdbcTemplate.update(updateSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-----------------------处理 CC3200 与后台的交互-------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理CC3200 发送过来的 GET 请求 -&gt;查询花卉的浇水量返回给CC3200  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>   <span class="comment">//用于将数据写出去</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/cc3200Query"</span>)   <span class="comment">//这个方法用来处理query请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt;  <span class="title">cc3200GetResponse</span><span class="params">(@RequestParam <span class="keyword">int</span> monitor_id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串拼接的方法来实现sql语句中嵌套变量</span></span><br><span class="line">        String querySql = <span class="string">"select * From flowers where monitor_id ="</span> + <span class="string">"'"</span> + monitor_id + <span class="string">"'"</span>;</span><br><span class="line">        <span class="comment">//这样返回的是一个map 而不是 list 的形式更方便CC3200那边去解析</span></span><br><span class="line">        Map&lt;String, Object&gt; map =jdbcTemplate.queryForMap(querySql);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理CC3200 POST 给服务器的数据 -&gt;更新花卉的状态信息 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>   <span class="comment">//用于接收CC3200 post 过来的数据</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/cc3200Post"</span>)   <span class="comment">//这个方法用来处理CC3200Post请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">CC3200PostResponse</span><span class="params">(@RequestBody String flower_info)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">        <span class="comment">/*--更新花卉的状态信息--*/</span></span><br><span class="line">        <span class="keyword">int</span> monitorID;</span><br><span class="line">    <span class="keyword">float</span> co2;</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//1.解析post过来的数据</span></span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject(flower_info);</span><br><span class="line">        monitorID = jsonObject.getInt(<span class="string">"monitorID"</span>);</span><br><span class="line">        co2 = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"co2"</span>);</span><br><span class="line">        temperature = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"temperature"</span>);</span><br><span class="line">        humidity = (<span class="keyword">float</span>) jsonObject.getDouble(<span class="string">"humidity"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.根据花卉监测系统ID更新数据库的数据</span></span><br><span class="line">        String updateSql =</span><br><span class="line">                <span class="string">"update flowers set co2 ="</span> + <span class="string">"'"</span> + co2 + <span class="string">"'"</span> +<span class="string">","</span>+</span><br><span class="line">                <span class="string">"temperature ="</span>+<span class="string">"'"</span> + temperature + <span class="string">"'"</span> +<span class="string">","</span>+</span><br><span class="line">                <span class="string">"humidity ="</span>+<span class="string">"'"</span> + humidity + <span class="string">"'"</span> +</span><br><span class="line">                <span class="string">" WHERE monitor_id ="</span>+ <span class="string">"'"</span> + monitorID + <span class="string">"'"</span>;</span><br><span class="line">        jdbcTemplate.update(updateSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>application.yaml 部分：这里根据实际的情况配置即可<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://公网IP或域名:3306/数据库名</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="五、学习路线（仅供参考）"><a href="#五、学习路线（仅供参考）" class="headerlink" title="五、学习路线（仅供参考）"></a>五、学习路线（仅供参考）</h2><p>&#8195;&#8195;1. pringBoot 我是通过学习观看 尚硅谷 的Springboot视频学习的，下载地址可以搜哦，有人上传到网盘了，或者哔哩哔哩上也有，而IDEA的使用关注他的微信公众号就可以免费下载，个人感觉还是不错的。反正免费嘛。<br>&#8195;&#8195;2. 在Ubuntu 上使用 Docker 可以参考下面的链接（安装MySQL也是很方便的）。<br>&#8195;&#8195;&#8195;<a href="https://cloud.tencent.com/developer/article/1350956" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1350956</a></p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP与服务器数据交互（实现一个简单的物联网系统-1）</title>
      <link href="/2018/04/20/APP%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-1/"/>
      <url>/2018/04/20/APP%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、APP-POST-数据到服务器"><a href="#一、APP-POST-数据到服务器" class="headerlink" title="一、APP POST 数据到服务器"></a>一、APP POST 数据到服务器</h2><p>&#8195;&#8195;首先 post 的数据应该包括识别这个花卉的信息和我们想要浇水的量，这里我们识别花卉采用花卉的名字，这样后台程序通过花卉名来对应更新数据库中该花的浇水量。</p><ol><li>mFlower_name：花卉名  </li><li>mBulk : 浇水量 </li></ol><p>实现代码如下：<br><strong>注意：</strong></p><ol><li>String urlPath 中的 IP 地址是我局域网的地址，如果你的后台程序是在云服务器上运行的那么应改成云服务器的公网IP。不过可以先在局域网内实现嘛。</li><li>http 的默认端口号为80，但由于我用的是springboot框架打包成的jar包，自带了嵌入的tomcat，而tomcat容器默认的端口号为8080（可以在配置文件（.yml）中更改）。</li><li>服务端的代码可参照专栏中的下一篇文章。<br>&#8195;&#8195;<strong>Code:</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-- 将浇水量等信息上传到服务器    安卓4.0以后必须在子线程中执行 --*/</span></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String urlPath = <span class="string">"http://192.168.43.148:8080/appPost"</span>;  <span class="comment">//URL</span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(urlPath);</span><br><span class="line">            HttpURLConnection coon = (HttpURLConnection) url.openConnection();</span><br><span class="line">            coon.setRequestMethod(<span class="string">"POST"</span>);<span class="comment">//请求方式为POST</span></span><br><span class="line">            coon.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line">            coon.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>);     <span class="comment">//设置发送的数据为 json 类型，会被添加到http body当中</span></span><br><span class="line">            String json = <span class="string">"&#123;\"name\":\""</span>+ mFlower_name+<span class="string">"\","</span> + <span class="string">"\"bulk\":"</span> + <span class="string">"\""</span> +mBulk+ <span class="string">"\"&#125;"</span>;    <span class="comment">//将要发送的花卉数据字符串连接成json格式</span></span><br><span class="line">            coon.setRequestProperty(<span class="string">"Content-Length"</span>, String.valueOf(json.length()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//post请求把数据以流的方式写给服务器，指定请求的输出模式</span></span><br><span class="line">            coon.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">            coon.getOutputStream().write(json.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> code = coon.getResponseCode();</span><br><span class="line">            <span class="keyword">if</span> (code == <span class="number">200</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"请求成功"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"请求失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"请求失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></li></ol><h2 id="二、APP-从服务器-GET-数据"><a href="#二、APP-从服务器-GET-数据" class="headerlink" title="二、APP 从服务器 GET 数据"></a>二、APP 从服务器 GET 数据</h2><p>&#8195;&#8195;APP 同样需要从服务器获得花卉的状态信息来更新显示界面，如更新到最新的土壤湿度、光照强度等显示给用户。<br>实现代码如下：<br><strong>注意：</strong></p><ol><li>从服务器得到的数据为 list 形式，所以解析较复杂一些，这取决于你服务器返回什么样的数据，在下一篇文章会有说明。服务器直接返回 map 形式APP这边会更好解析。具体百度啦！<br><strong>Code:</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查询服务器 得到花卉的信息  更新显示的数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String urlPath = <span class="string">"http://192.168.43.148:8080/appQuery?flower_name="</span> + mFlower_name;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(urlPath);</span><br><span class="line">            HttpURLConnection coon = (HttpURLConnection) url.openConnection();</span><br><span class="line">            coon.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">            coon.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> code = coon.getResponseCode();</span><br><span class="line">            <span class="keyword">if</span> (code == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">//1.得到输入流</span></span><br><span class="line">                InputStream is = coon.getInputStream();</span><br><span class="line">                <span class="comment">//2.将流用自己写的StreamUtils转化为字符串  改字符串为json格式</span></span><br><span class="line">                String flowerInfo = StreamUtils.readStream(is);</span><br><span class="line">                <span class="comment">//3.解析json数据（这里是list形式）  并显示数据</span></span><br><span class="line">                JSONArray flowerJsonArray = <span class="keyword">new</span> JSONArray(flowerInfo);</span><br><span class="line">                <span class="comment">// 这里的数组长度其实是1</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerJsonArray.length(); i++) &#123;</span><br><span class="line">                    JSONObject flowerJsonObject = flowerJsonArray.getJSONObject(i);</span><br><span class="line">                    mTv_temperature.setText(flowerJsonObject.getString(<span class="string">"temperature"</span>));<span class="comment">//温度</span></span><br><span class="line">                    mTv_humidity.setText(flowerJsonObject.getString(<span class="string">"humidity"</span>));<span class="comment">//湿度</span></span><br><span class="line">                    mTv_co2.setText(flowerJsonObject.getString(<span class="string">"co2"</span>));<span class="comment">//CO2 浓度</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Message msg = Message.obtain();</span><br><span class="line">                msg.what = STATUS_ERROR;</span><br><span class="line">                mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><h2 id="三、APP-界面部分"><a href="#三、APP-界面部分" class="headerlink" title="三、APP 界面部分"></a>三、APP 界面部分</h2>&#8195;&#8195;这部分就主要看自己如何去设计了，主要还是要多学习一些，才能做出更好看、功能更加丰富的APP。下面展示一下我做的APP（由于技术原因以及没有艺术细胞，做的着实有些丑）。</li></ol><p><img src="https://img-blog.csdnimg.cn/20190202171426215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width = 40% height = 40% /></p><p><img src="https://img-blog.csdnimg.cn/20190202172717392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70" width = 40% height = 40% /></p><h2 id="四、相关疑问"><a href="#四、相关疑问" class="headerlink" title="四、相关疑问"></a>四、相关疑问</h2><ol><li>后台相关的代码呢？<br> 在下一节贴上我的服务端的代码，其实站在SpringBoot的肩膀上，我们后台的搭建显得异常的容易。</li><li>APP 的其他代码和功能呢？<br> 这里我之列出了POST 和 GET 过程相关的代码，如果真的要实现众多功能，还是要花好长一段时间去学习安卓。</li></ol><h2 id="五、学习方法"><a href="#五、学习方法" class="headerlink" title="五、学习方法"></a>五、学习方法</h2><ol><li>我个人是通过学习完Java以后，在某宝花了几十块钱买的教学视频，还有哔哩哔哩上的天哥在奔跑的视频也还不错，等等。这里仅仅只是个人的学习过程，仅供参考。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务器 </tag>
            
            <tag> IOT </tag>
            
            <tag> APP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HC-05蓝牙配置</title>
      <link href="/2018/04/18/%E9%85%8D%E7%BD%AE%E8%93%9D%E7%89%99%EF%BC%88HC-05%EF%BC%89%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%88%E5%90%8D%E5%AD%97%E3%80%81%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E5%AF%86%E7%A0%81%E3%80%81%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E7%AD%89%EF%BC%89/"/>
      <url>/2018/04/18/%E9%85%8D%E7%BD%AE%E8%93%9D%E7%89%99%EF%BC%88HC-05%EF%BC%89%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%88%E5%90%8D%E5%AD%97%E3%80%81%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E5%AF%86%E7%A0%81%E3%80%81%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E7%AD%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;有时买回来的蓝牙模块的默认配置不能满足我们的使用需求时，就需要对买回来的蓝牙进行自行配置，比如更改波特率来适应自己的程序，或是更改主、从机的设置等等。即使是用默认的设置也需要对密码进行修改，以免设备和其他人也没有进行配置的蓝牙进行配对连接。下面介绍最长用的HC-05 蓝牙模块的<strong>简单配置方法</strong>。</p><h2 id="二、准备材料"><a href="#二、准备材料" class="headerlink" title="二、准备材料"></a>二、准备材料</h2><ol><li>官方的上位机<br>&#8195;&#8195;下载地址：<a href="http://www.hc01.com/service_download" target="_blank" rel="noopener">http://www.hc01.com/service_download</a><br>&#8195;&#8195;当然如果你是在淘宝买的，卖家基本上都会提供，具体是哪个上位机可以看后面配置过程中的图片。</li><li>一个USB转串口的模块（CH340等）<h2 id="三、连接方式"><a href="#三、连接方式" class="headerlink" title="三、连接方式"></a>三、连接方式</h2>&#8195;&#8195;如下图：<br><img src="https://img-blog.csdnimg.cn/20190514201728368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%><h2 id="四、配置方式"><a href="#四、配置方式" class="headerlink" title="四、配置方式"></a>四、配置方式</h2><h4 id="1-进入AT模式"><a href="#1-进入AT模式" class="headerlink" title="1. 进入AT模式"></a>1. 进入AT模式</h4>&#8195;&#8195;按住蓝牙上的小按键（不要松手），然后上电，上电后即可进入到蓝牙的AT模式下，此时蓝牙上的灯慢闪（两秒暗灭一次），此时松手即可<h4 id="2-打开上位机连接到蓝牙"><a href="#2-打开上位机连接到蓝牙" class="headerlink" title="2. 打开上位机连接到蓝牙"></a>2. 打开上位机连接到蓝牙</h4>&#8195;&#8195;波特率选择38400，这是AT模式下默认的配置所需波特率。点击搜索端口，在波特率右侧显示“端口 x已打开” 说明已经连接到蓝牙，如下图：<br><img src="https://img-blog.csdnimg.cn/20190514202632398.png"width=80% height=80%><h4 id="3-获取模块信息"><a href="#3-获取模块信息" class="headerlink" title="3.获取模块信息"></a>3.获取模块信息</h4>&#8195;&#8195;<strong>用手按住蓝牙上的按键，不要松手，同时点击上位机上的获取模块信息</strong>，这是右方的表格中就会显示出当前蓝牙的配置信息。全部显示完之后松开按键。显示如下图，这是默认买回来时的配置：<br><img src="https://img-blog.csdnimg.cn/20190514203312330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%><h4 id="4-更新自己想要的配置"><a href="#4-更新自己想要的配置" class="headerlink" title="4.更新自己想要的配置"></a>4.更新自己想要的配置</h4>&#8195;&#8195;直接在右侧来的输入框中，更改你想要的配置，比如名字、波特率、密码、主从模式等，更改好后，同样<strong>按住蓝牙上的按键，不要松手，点击更新模块信息</strong>，等更新完之后再松开按键，这时就已经配置好了。<br><img src="https://img-blog.csdnimg.cn/20190514203940880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fWF9X,size_16,color_FFFFFF,t_70"width=80% height=80%><h4 id="5-验证配置"><a href="#5-验证配置" class="headerlink" title="5. 验证配置"></a>5. 验证配置</h4>&#8195;&#8195;可点击右上方的清楚表格数据，然后按照第三步的步骤获取模块信息，即可查看已经设置成功的配置了。同样也可以通过此方法查看一个未知蓝牙的配置。最后重新上电，蓝牙就可以进入使用状态了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝牙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建完整物联网系统（CC3200+云服务器）</title>
      <link href="/2018/04/17/%E5%AE%9E%E7%8E%B0%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9F%BA%E4%BA%8E-CC3200%E3%80%81%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89/"/>
      <url>/2018/04/17/%E5%AE%9E%E7%8E%B0%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9F%BA%E4%BA%8E-CC3200%E3%80%81%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>&#8195;&#8195;本系列文章主要讲解如何通过 CC3200（简单理解为单片机和WIFI模块的结合体）、云服务器、APP 来实现远程控制。所有的程序全部自己编写，我们可以真正意义上的实现：<br>①. 远程控制家中的热水器烧水<br>②. 远程控制监测环境数据<br>… … 等等。（可以尽情的发挥想象，想象好了就可以开始了！）<br>比如：<strong>我想实现远程浇花这个功能</strong>（因为室友养的花寒暑假没有人照看，实现这样一个功能就很不错）</p><h2 id="二、知识基础"><a href="#二、知识基础" class="headerlink" title="二、知识基础"></a>二、知识基础</h2><p>&#8195;&#8195;要想实现以上功能需要具备以下一些知识技能：<br>&#8195;&#8195;这些知识或许还有好多都不会，甚至有一部分都没有听说过（如果你会很多，那就再好不过了），但是所有的内容都可以去学习呀！我也是从大二下学期开始学习的，大三下学期实现的，而且是机械设计制造及其自动化专业。</p><ol><li>主要编程语言：C、Java。</li><li>主要IDE：CCS、IDEA、AndroidStudio。</li><li>框架：SpringBoot。</li><li>系统：Windows、Linux（Ubuntu）。<br><strong>注：</strong><br>&#8195;&#8195;其实在这个过程中所涉及到的知识还远不止上面这些，如果想学习的更多，理解的更彻底，每一部分都值得深入的去研究、学习。<h2 id="三、主要目标"><a href="#三、主要目标" class="headerlink" title="三、主要目标"></a>三、主要目标</h2></li><li><p>APP与服务器之间进行双向通讯：    要能够通过APP获得花卉的状态数据，比如土壤的湿度，光照强度等等；同时 APP 还要能够将用户浇水的命令上传到服务器。</p></li><li><p>CC3200 与服务器进行双向通讯：    CC3200 将土壤湿度、光照强度等信息上传到服务器，同时CC3200还要能从服务器获取数据。</p></li><li><p>CC3200 控制水泵的浇水实现：    这里主要是控制部分的实现，CC3200要根据从服务器获取的数据，进行浇水的控制。</p><h2 id="四、视频展示"><a href="#四、视频展示" class="headerlink" title="四、视频展示"></a>四、视频展示</h2><p>简单的实现远程的浇水功能：    <a  href ="https://www.bilibili.com/video/av43996928">点击观看</a></p><h2 id="五、相关疑问"><a href="#五、相关疑问" class="headerlink" title="五、相关疑问"></a>五、相关疑问</h2></li><li>真的有这么容易实现吗？<br>&#8195;&#8195;答案：当然可以，我是用课余时间学习了一年就实现了，不过最好有一部分基础。（比如我之前有单片机的基础，但对于java、安卓、后台一点都不会，就更别说什么框架、Linux了）。</li><li>我该如何学习？<br>①. C语言、Java语言肯定要先学会。<br>②. 单片机开发的基础：用C语言开发。CC3200是一款 TI 公司集MCU和WIFI功能为一体的芯片，或者先学一款单片机，比如STM32（这个教程多），MSP430（TI公司，教程少）等。一通百通。<br>③. 安卓基础：这个是用Java语言开发的。<br>④. 服务和后台：后台代码也是用Java开发，学习Linux的基本操作。<h2 id="六、学习方法"><a href="#六、学习方法" class="headerlink" title="六、学习方法"></a>六、学习方法</h2></li><li>视频资料：如果对某一项技术没有任何了解，通过视频来学习最好不过了，可以选择可以倍速播放视频的软件。</li><li>文档资料：当你有了一定基础之后，看相关文档才是最快，最好用的资料。</li><li>资料推荐：哔哩哔哩、尚硅谷、w3cschool等等。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> CC3200 </tag>
            
            <tag> 云服务 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
